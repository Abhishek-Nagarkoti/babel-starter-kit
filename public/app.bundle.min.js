/*!
 * babel-starter-kit v0.0.0
 * A project template for authoring and publishing JavaScript libraries
 * https://www.kriasoft.com/babel-starter-kit/
 * Copyright (c) 2015-2016 RightFit, Inc. All Rights Reserved.
 * Are you a frontend Ninja? work with us! email at hi@hitesh.io
 */
webpackJsonp([0],[
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(1);
	module.exports = __webpack_require__(2);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	(function () {

	    'use strict';

	    function Bullet() {
	        // ------------------------------------------------------------------------------------------
	        // -- Custom Errors
	        // ------------------------------------------------------------------------------------------
	        function ParamCountError(methodName, expectedParamsString, paramCount) {

	            this.message = 'Bullet:: [' + methodName + '] ' + expectedParamsString + ', but received: ' + paramCount;
	            var error = new Error(this.message);
	            if (typeof error.stack !== 'undefined') this.stack = error.stack;
	        }
	        ParamCountError.prototype = new Error();
	        ParamCountError.prototype.name = ParamCountError.name;
	        ParamCountError.prototype.constructor = ParamCountError;

	        function ParamTypeError(methodName, parameterName, parameter, expectedType) {

	            this.message = 'Bullet:: [' + methodName + '] Expected parameter - ' + parameterName + ' - to be type: ' + expectedType + ', but received type: ' + (typeof parameter === 'undefined' ? 'undefined' : _typeof(parameter));
	            var error = new TypeError(this.message);
	            if (typeof error.stack !== 'undefined') this.stack = error.stack;
	        }
	        ParamTypeError.prototype = new TypeError();
	        ParamTypeError.prototype.name = ParamTypeError.name;
	        ParamTypeError.prototype.constructor = ParamTypeError;

	        function EventNameLengthError(methodName) {

	            this.message = 'Bullet:: [' + methodName + '] Expected event name parameter to be longer than 0 characters';
	            var error = new Error(this.message);
	            if (typeof error.stack !== 'undefined') this.stack = error.stack;
	        }
	        EventNameLengthError.prototype = new Error();
	        EventNameLengthError.prototype.name = EventNameLengthError.name;
	        EventNameLengthError.prototype.constructor = EventNameLengthError;

	        function UndeclaredEventError(methodName, eventName) {

	            this.message = 'Bullet:: [' + methodName + '] Event string: "' + eventName + '" does not exist within the events dictionary\nPlease use the Bullet.addEventName method to add this string.';

	            var error = new Error(this.message);
	            if (typeof error.stack !== 'undefined') this.stack = error.stack;
	        }
	        UndeclaredEventError.prototype = new Error();
	        UndeclaredEventError.prototype.name = UndeclaredEventError.name;
	        UndeclaredEventError.prototype.constructor = UndeclaredEventError;

	        function UnmappedEventError(methodName, eventName) {

	            this.message = 'Bullet:: [' + methodName + '] Event string: "' + eventName + '" is not mapped to any callbacks\nPlease use the Bullet.on method to map this string to a callback.';

	            var error = new Error(this.message);
	            if (typeof error.stack !== 'undefined') this.stack = error.stack;
	        }
	        UnmappedEventError.prototype = new Error();
	        UnmappedEventError.prototype.name = UnmappedEventError.name;
	        UnmappedEventError.prototype.constructor = UnmappedEventError;

	        // ------------------------------------------------------------------------------------------
	        // -- Private variables
	        // ------------------------------------------------------------------------------------------
	        var _self = this;
	        var _mappings = {};
	        var _strictMode = false;
	        var _triggerAsync = true;

	        // Expose custom error type constructors (for testing), but use an underscore to imply privacy.
	        _self._errors = {
	            ParamCountError: ParamCountError,
	            ParamTypeError: ParamTypeError,
	            EventNameLengthError: EventNameLengthError,
	            UndeclaredEventError: UndeclaredEventError,
	            UnmappedEventError: UnmappedEventError
	        };

	        // ------------------------------------------------------------------------------------------
	        // -- Public variables
	        // ------------------------------------------------------------------------------------------
	        _self.events = {};

	        // ------------------------------------------------------------------------------------------
	        // -- Private methods
	        // ------------------------------------------------------------------------------------------
	        function _cloneCallbacks(callbacks) {
	            var clonedCallbacks = {};

	            for (var callbackName in callbacks) {

	                clonedCallbacks[callbackName] = {
	                    cb: callbacks[callbackName].cb,
	                    once: callbacks[callbackName].once
	                };
	            }

	            return clonedCallbacks;
	        }

	        // Expose _getMappings method (for testing), but use an underscore to imply privacy.
	        _self._getMappings = function () {

	            // Return a dictionary object that has no effect on app state to ensure '_mappings'
	            // stays private, even if the value returned from this method is modified.
	            var clonedMappings = {};

	            for (var mapping in _mappings) {
	                clonedMappings[mapping] = {
	                    callbacks: _cloneCallbacks(_mappings[mapping].callbacks),
	                    totalCallbacks: _mappings[mapping].totalCallbacks
	                };
	            }

	            return clonedMappings;
	        };

	        // ------------------------------------------------------------------------------------------
	        // -- Public methods
	        // ------------------------------------------------------------------------------------------
	        _self.on = function (eventName, fn, once) {
	            if (arguments.length < 2 || arguments.length > 3) {
	                throw new ParamCountError('on', 'Expected between 2 and 3 parameters', arguments.length);
	            }

	            if (typeof eventName !== 'string') {
	                throw new ParamTypeError('on', 'event name', eventName, 'string');
	            } else if (eventName.length === 0) {
	                throw new EventNameLengthError('on');
	            } else if (_strictMode && typeof _self.events[eventName] === 'undefined') {
	                throw new UndeclaredEventError('on', eventName);
	            }

	            if (typeof fn !== 'function') {
	                throw new ParamTypeError('on', 'callback', fn, 'function');
	            }

	            if (typeof once !== 'undefined' && typeof once !== 'boolean') {
	                throw new ParamTypeError('on', 'once', once, 'boolean');
	            }

	            var fnString = fn.toString();

	            // If the named event object already exists in the dictionary...
	            if (typeof _mappings[eventName] !== 'undefined') {
	                // Add a callback object to the named event object if one doesn't already exist.
	                if (typeof _mappings[eventName].callbacks[fnString] === 'undefined') {
	                    _mappings[eventName].callbacks[fnString] = {
	                        cb: fn,
	                        once: typeof once === 'boolean' ? once : false
	                    };

	                    _mappings[eventName].totalCallbacks++;
	                } else if (typeof once === 'boolean') {
	                    // The function already exists, so update it's 'once' value.
	                    _mappings[eventName].callbacks[fnString].once = once;
	                }
	            } else {
	                // Create a new event object in the dictionary with the specified name and callback.
	                _mappings[eventName] = {
	                    callbacks: {}
	                };

	                _mappings[eventName].callbacks[fnString] = { cb: fn, once: !!once };
	                _mappings[eventName].totalCallbacks = 1;
	            }
	        };

	        _self.once = function (eventName, fn) {
	            if (arguments.length !== 2) {
	                throw new ParamCountError('once', 'Expected 2 parameters', arguments.length);
	            } else if (typeof eventName !== 'string') {
	                throw new ParamTypeError('once', 'event name', eventName, 'string');
	            } else if (eventName.length === 0) {
	                throw new EventNameLengthError('once');
	            } else if (_strictMode && typeof _self.events[eventName] === 'undefined') {
	                throw new UndeclaredEventError('once', eventName);
	            }

	            if (typeof fn !== 'function') {
	                throw new ParamTypeError('once', 'callback', fn, 'function');
	            }

	            _self.on(eventName, fn, true);
	        };

	        _self.off = function (eventName, fn) {
	            if (arguments.length === 0) {
	                // Remove all mappings.
	                _mappings = {};
	                return;
	            } else if (typeof eventName !== 'string') {
	                throw new ParamTypeError('off', 'event name', eventName, 'string');
	            } else if (eventName.length === 0) {
	                throw new EventNameLengthError('off');
	            } else if (_strictMode && typeof _self.events[eventName] === 'undefined') {
	                throw new UndeclaredEventError('off', eventName);
	            }

	            if (typeof _mappings[eventName] === 'undefined') {
	                // There is no mapping to remove, so return silently.
	                return;
	            }

	            // Remove just the function, if passed as a parameter and in the dictionary.
	            if (typeof fn === 'function') {
	                var fnString = fn.toString(),
	                    fnToRemove = _mappings[eventName].callbacks[fnString];

	                if (typeof fnToRemove !== 'undefined') {
	                    // delete the callback object from the dictionary.
	                    delete _mappings[eventName].callbacks[fnString];

	                    _mappings[eventName].totalCallbacks--;

	                    if (_mappings[eventName].totalCallbacks === 0) {
	                        // There are no more functions in the dictionary that are
	                        // registered to this event, so delete the named event object.
	                        delete _mappings[eventName];
	                    }
	                }
	            } else if (typeof fn !== 'undefined') {
	                throw new ParamTypeError('off', 'callback', fn, 'function');
	            } else {
	                // No callback was passed, so delete all functions in the dictionary that
	                // are registered to this event by deleting the named event object.
	                delete _mappings[eventName];
	            }
	        };

	        // Replace a single mapped callback for the specified event name with a new callback.
	        _self.replaceCallback = function (eventName, oldFn, newFn, once) {

	            if (typeof eventName !== 'string') {
	                throw new ParamTypeError('replaceCallback', 'event name', eventName, 'string');
	            } else if (eventName.length === 0) {
	                throw new EventNameLengthError('replaceCallback');
	            } else if (typeof _mappings[eventName] === 'undefined') {
	                throw new UnmappedEventError('replaceCallback', eventName);
	            } else if (_strictMode && typeof _self.events[eventName] === 'undefined') {
	                throw new UndeclaredEventError('replaceCallback', eventName);
	            }

	            if (typeof oldFn !== 'function') {
	                throw new ParamTypeError('replaceCallback', 'callback', oldFn, 'function');
	            }

	            if (typeof newFn !== 'function') {
	                throw new ParamTypeError('replaceCallback', 'callback', newFn, 'function');
	            }

	            if (typeof once !== 'undefined' && typeof once !== 'boolean') {
	                throw new ParamTypeError('replaceCallback', 'once', once, 'boolean');
	            }

	            _self.off(eventName, oldFn);
	            _self.on(eventName, newFn, once);
	        };

	        // Replace all of the specified event name’s mapped callbacks with the specified callback.
	        _self.replaceAllCallbacks = function (eventName, newFn, once) {

	            if (typeof eventName !== 'string') {
	                throw new ParamTypeError('replace', 'event name', eventName, 'string');
	            } else if (eventName.length === 0) {
	                throw new EventNameLengthError('replace');
	            } else if (typeof _mappings[eventName] === 'undefined') {
	                throw new UnmappedEventError('replace', eventName);
	            } else if (_strictMode && typeof _self.events[eventName] === 'undefined') {
	                throw new UndeclaredEventError('replace', eventName);
	            }

	            if (typeof newFn !== 'function') {
	                throw new ParamTypeError('replace', 'callback', newFn, 'function');
	            }

	            if (typeof once !== 'undefined' && typeof once !== 'boolean') {
	                throw new ParamTypeError('replace', 'once', once, 'boolean');
	            }

	            _self.off(eventName);
	            _self.on(eventName, newFn, once);
	        };

	        _self.trigger = function (eventName, data) {
	            if (typeof eventName !== 'string') {
	                throw new ParamTypeError('trigger', 'event name', eventName, 'string');
	            } else if (eventName.length === 0) {
	                throw new EventNameLengthError('trigger');
	            } else if (_strictMode && typeof _self.events[eventName] === 'undefined') {
	                throw new UndeclaredEventError('trigger', eventName);
	            }

	            if (typeof _mappings[eventName] === 'undefined') {
	                if (_strictMode) throw new UnmappedEventError('trigger', eventName);

	                // Return silently if not in strict mode.
	                return;
	            }

	            function runCallback() {
	                for (var fnString in _mappings[eventName].callbacks) {
	                    var callbackObject = _mappings[eventName].callbacks[fnString];

	                    if (typeof callbackObject.cb === 'function') callbackObject.cb(data);
	                    if (typeof callbackObject.once === 'boolean' && callbackObject.once === true) _self.off(eventName, callbackObject.cb);
	                }
	            }

	            // Check whether or not this is a browser environment.
	            if (_triggerAsync && typeof window !== 'undefined') {
	                window.setTimeout(runCallback, 0);
	            } else {
	                runCallback();
	            }
	        };

	        _self.addEventName = function (eventName) {

	            if (typeof eventName !== 'string') {
	                throw new ParamTypeError('addEventName', 'event name', eventName, 'string');
	            } else if (eventName.length === 0) {
	                throw new EventNameLengthError('addEventName');
	            }

	            _self.events[eventName] = eventName;
	        };

	        _self.removeEventName = function (eventName) {

	            if (typeof eventName !== 'string') {
	                throw new ParamTypeError('removeEventName', 'event name', eventName, 'string');
	            } else if (eventName.length === 0) {
	                throw new EventNameLengthError('removeEventName');
	            }

	            if (_self.events[eventName]) delete _self.events[eventName];
	        };

	        _self.getStrictMode = function () {

	            // Return a boolean that doesn't directly point to the internal '_strictMode' property.
	            return _strictMode === true ? true : false;
	        };

	        _self.setStrictMode = function (useStrictMode) {

	            if (typeof useStrictMode !== 'boolean') throw new ParamTypeError('setStrictMode', 'strict mode', useStrictMode, 'boolean');

	            _strictMode = useStrictMode;
	        };

	        _self.getTriggerAsync = function () {

	            // Return a boolean that doesn't directly point to the internal '_triggerAsync' property.
	            return _triggerAsync === true ? true : false;
	        };

	        _self.setTriggerAsync = function (useAsync) {

	            if (typeof useAsync !== 'boolean') throw new ParamTypeError('setTriggerAsync', 'trigger async', useAsync, 'boolean');

	            _triggerAsync = useAsync;
	        };

	        // TODO : Create an 'addMultipleEventNames' method with an array of strings passed as a param.
	        // - include type checks for string while looping over the array.

	        // TODO : Create a 'replaceAllEventNames' method with an array of strings passed as a param.
	        // - include type checks for string while looping over the array.

	        // TODO : Create a 'removeAllEventNames' method. No params necessary.
	        // – Internally this could simply call 'replaceAllEventNames' and pass an empty array as a param.

	        // TODO : Create an 'onAny' method with an array of strings passed as the first param and a single callback as the second.
	        // - include type checks for string while looping over the array.

	        // TODO : Create an 'onMultiple' method with an array of flat objects passed as a param.
	        // - example of required param structure:
	        // [{eventName: 'someEvent', callback: someCallback, once: false}, {eventName: 'anotherEvent', callback: anotherCallback, once: true}]
	    }

	    // ------------------------------------------------------------------------------------------
	    // -- Module definition
	    // ------------------------------------------------------------------------------------------
	    // Check for AMD/Module support, otherwise define Bullet as a global variable.

	    if (true) {
	        // AMD. Register as an anonymous module.
	        !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	            return new Bullet();
	        }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (typeof module !== 'undefined' && module.exports) {
	        module.exports = new Bullet();
	    } else {
	        window.Bullet = new Bullet();
	    }
	})();

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(jQuery, m) {'use strict';

	var _dropdown = __webpack_require__(6);

	var _dropdown2 = _interopRequireDefault(_dropdown);

	var _popup = __webpack_require__(7);

	var _popup2 = _interopRequireDefault(_popup);

	var _form = __webpack_require__(8);

	var _form2 = _interopRequireDefault(_form);

	var _transition = __webpack_require__(9);

	var _transition2 = _interopRequireDefault(_transition);

	var _restful = __webpack_require__(10);

	var _restful2 = _interopRequireDefault(_restful);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	//require('dimmer');
	//require('modal');
	//require('visibility');
	//require('tab');
	//require('dropdown');

	m.dropdown = function (elem) {
	    jQuery(elem).dropdown();
	};
	m.checkbox = function (elem) {};

	window.ws = null; //default null xmpp connection
	m.scale = "medium"; //default scale to medium

	//m.addGlobalHeader('Content-Type', 'application/json');
	m.cookie = __webpack_require__(29);
	//for semantic ui colors
	m.seriesColors = ['blue', 'orange', 'teal', 'green', 'red', 'violet', 'purple', 'pink', 'brown', 'grey'];
	m.colors = ['red', 'blue', 'orange', 'teal', 'olive', 'pink', 'green', 'violet', 'yellow', 'purple', 'brown', 'grey'];

	var user = m.prop();

	var config = {
	    data: {
	        // only if the request contains data
	    },
	    headers: {
	        Authorization: 'Bearer AAAAA'
	    },
	    method: 'get',
	    params: {
	        page: 1
	    },
	    url: '/url'
	};

	var api = (0, _restful2.default)(("http://rightfit.lol/api"), (0, _restful.fetchBackend)(fetch));

	var usersCollection = api.all('users'); // /users
	var session = api.all('session'); // /session
	var mobileSession = mobilesSession.custom('mobile'); // /session/mobile
	var emailsSession = mobilesSession.custom('email'); // /session/email
	//session/mobile/confirm
	//


	// m.api = new jQuery.RestClient(API);

	// m.api.defaultHeaders({
	//     "Content-Type": "application/json; charset=UTF-8;"
	// })

	// m.api.add('users', 'users');
	// m.api.add('login', 'login');
	// m.api.add('emailLogin', 'login/email');
	// m.api.add('logout', 'users/logout');
	// m.api.add('ping');

	m.urls = function (theClass, theObject, action) {
	    var url = '';

	    if (action) {
	        url = api + '/' + theClass + '/' + theObject + '/' + action;
	    } else {
	        if (theObject) {
	            url = api + '/' + theClass + '/' + theObject;
	        } else {
	            url = api + '/' + theClass;
	        }
	    }

	    return url;
	};

	//start the routings
	m.route = __webpack_require__(30);

	// setTimeout(function(){
	//     jQuery(".ui").addClass(m.scale);
	// },5000)
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3), __webpack_require__(4)))

/***/ },
/* 3 */,
/* 4 */,
/* 5 */,
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(jQuery) {'use strict';/*!
	 * # Semantic UI - Dropdown
	 * http://github.com/semantic-org/semantic-ui/
	 *
	 *
	 * Released under the MIT license
	 * http://opensource.org/licenses/MIT
	 *
	 */;(function($,window,document,undefined){"use strict";window=typeof window!='undefined'&&window.Math==Math?window:typeof self!='undefined'&&self.Math==Math?self:Function('return this')();$.fn.dropdown=function(parameters){var $allModules=$(this),$document=$(document),moduleSelector=$allModules.selector||'',hasTouch='ontouchstart'in document.documentElement,time=new Date().getTime(),performance=[],query=arguments[0],methodInvoked=typeof query=='string',queryArguments=[].slice.call(arguments,1),returnedValue;$allModules.each(function(elementIndex){var settings=$.isPlainObject(parameters)?$.extend(true,{},$.fn.dropdown.settings,parameters):$.extend({},$.fn.dropdown.settings),className=settings.className,message=settings.message,fields=settings.fields,keys=settings.keys,metadata=settings.metadata,namespace=settings.namespace,_regExp=settings.regExp,selector=settings.selector,error=settings.error,templates=settings.templates,eventNamespace='.'+namespace,moduleNamespace='module-'+namespace,$module=$(this),$context=$(settings.context),$text=$module.find(selector.text),$search=$module.find(selector.search),$sizer=$module.find(selector.sizer),$input=$module.find(selector.input),$icon=$module.find(selector.icon),$combo=$module.prev().find(selector.text).length>0?$module.prev().find(selector.text):$module.prev(),$menu=$module.children(selector.menu),$item=$menu.find(selector.item),activated=false,itemActivated=false,internalChange=false,element=this,instance=$module.data(moduleNamespace),_initialLoad,pageLostFocus,willRefocus,elementNamespace,_id,_selectObserver,_menuObserver,module;module={initialize:function initialize(){module.debug('Initializing dropdown',settings);if(module.is.alreadySetup()){module.setup.reference();}else{module.setup.layout();module.refreshData();module.save.defaults();module.restore.selected();module.create.id();module.bind.events();module.observeChanges();module.instantiate();}},instantiate:function instantiate(){module.verbose('Storing instance of dropdown',module);instance=module;$module.data(moduleNamespace,module);},destroy:function destroy(){module.verbose('Destroying previous dropdown',$module);module.remove.tabbable();$module.off(eventNamespace).removeData(moduleNamespace);$menu.off(eventNamespace);$document.off(elementNamespace);module.disconnect.menuObserver();module.disconnect.selectObserver();},observeChanges:function observeChanges(){if('MutationObserver'in window){_selectObserver=new MutationObserver(module.event.select.mutation);_menuObserver=new MutationObserver(module.event.menu.mutation);module.debug('Setting up mutation observer',_selectObserver,_menuObserver);module.observe.select();module.observe.menu();}},disconnect:{menuObserver:function menuObserver(){if(_menuObserver){_menuObserver.disconnect();}},selectObserver:function selectObserver(){if(_selectObserver){_selectObserver.disconnect();}}},observe:{select:function select(){if(module.has.input()){_selectObserver.observe($input[0],{childList:true,subtree:true});}},menu:function menu(){if(module.has.menu()){_menuObserver.observe($menu[0],{childList:true,subtree:true});}}},create:{id:function id(){_id=(Math.random().toString(16)+'000000000').substr(2,8);elementNamespace='.'+_id;module.verbose('Creating unique id for element',_id);},userChoice:function userChoice(values){var $userChoices,$userChoice,isUserValue,html;values=values||module.get.userValues();if(!values){return false;}values=$.isArray(values)?values:[values];$.each(values,function(index,value){if(module.get.item(value)===false){html=settings.templates.addition(module.add.variables(message.addResult,value));$userChoice=$('<div />').html(html).attr('data-'+metadata.value,value).attr('data-'+metadata.text,value).addClass(className.addition).addClass(className.item);if(settings.hideAdditions){$userChoice.addClass(className.hidden);}$userChoices=$userChoices===undefined?$userChoice:$userChoices.add($userChoice);module.verbose('Creating user choices for value',value,$userChoice);}});return $userChoices;},userLabels:function userLabels(value){var userValues=module.get.userValues();if(userValues){module.debug('Adding user labels',userValues);$.each(userValues,function(index,value){module.verbose('Adding custom user value');module.add.label(value,value);});}},menu:function menu(){$menu=$('<div />').addClass(className.menu).appendTo($module);},sizer:function sizer(){$sizer=$('<span />').addClass(className.sizer).insertAfter($search);}},search:function search(query){query=query!==undefined?query:module.get.query();module.verbose('Searching for query',query);if(module.has.minCharacters(query)){module.filter(query);}else{module.hide();}},select:{firstUnfiltered:function firstUnfiltered(){module.verbose('Selecting first non-filtered element');module.remove.selectedItem();$item.not(selector.unselectable).not(selector.addition+selector.hidden).eq(0).addClass(className.selected);},nextAvailable:function nextAvailable($selected){$selected=$selected.eq(0);var $nextAvailable=$selected.nextAll(selector.item).not(selector.unselectable).eq(0),$prevAvailable=$selected.prevAll(selector.item).not(selector.unselectable).eq(0),hasNext=$nextAvailable.length>0;if(hasNext){module.verbose('Moving selection to',$nextAvailable);$nextAvailable.addClass(className.selected);}else{module.verbose('Moving selection to',$prevAvailable);$prevAvailable.addClass(className.selected);}}},setup:{api:function api(){var apiSettings={debug:settings.debug,urlData:{value:module.get.value(),query:module.get.query()},on:false};module.verbose('First request, initializing API');$module.api(apiSettings);},layout:function layout(){if($module.is('select')){module.setup.select();module.setup.returnedObject();}if(!module.has.menu()){module.create.menu();}if(module.is.search()&&!module.has.search()){module.verbose('Adding search input');$search=$('<input />').addClass(className.search).prop('autocomplete','off').insertBefore($text);}if(module.is.multiple()&&module.is.searchSelection()&&!module.has.sizer()){module.create.sizer();}if(settings.allowTab){module.set.tabbable();}},select:function select(){var selectValues=module.get.selectValues();module.debug('Dropdown initialized on a select',selectValues);if($module.is('select')){$input=$module;}// see if select is placed correctly already
	if($input.parent(selector.dropdown).length>0){module.debug('UI dropdown already exists. Creating dropdown menu only');$module=$input.closest(selector.dropdown);if(!module.has.menu()){module.create.menu();}$menu=$module.children(selector.menu);module.setup.menu(selectValues);}else{module.debug('Creating entire dropdown from select');$module=$('<div />').attr('class',$input.attr('class')).addClass(className.selection).addClass(className.dropdown).html(templates.dropdown(selectValues)).insertBefore($input);if($input.hasClass(className.multiple)&&$input.prop('multiple')===false){module.error(error.missingMultiple);$input.prop('multiple',true);}if($input.is('[multiple]')){module.set.multiple();}if($input.prop('disabled')){module.debug('Disabling dropdown');$module.addClass(className.disabled);}$input.removeAttr('class').detach().prependTo($module);}module.refresh();},menu:function menu(values){$menu.html(templates.menu(values,fields));$item=$menu.find(selector.item);},reference:function reference(){module.debug('Dropdown behavior was called on select, replacing with closest dropdown');// replace module reference
	$module=$module.parent(selector.dropdown);module.refresh();module.setup.returnedObject();// invoke method in context of current instance
	if(methodInvoked){instance=module;module.invoke(query);}},returnedObject:function returnedObject(){var $firstModules=$allModules.slice(0,elementIndex),$lastModules=$allModules.slice(elementIndex+1);// adjust all modules to use correct reference
	$allModules=$firstModules.add($module).add($lastModules);}},refresh:function refresh(){module.refreshSelectors();module.refreshData();},refreshItems:function refreshItems(){$item=$menu.find(selector.item);},refreshSelectors:function refreshSelectors(){module.verbose('Refreshing selector cache');$text=$module.find(selector.text);$search=$module.find(selector.search);$input=$module.find(selector.input);$icon=$module.find(selector.icon);$combo=$module.prev().find(selector.text).length>0?$module.prev().find(selector.text):$module.prev();$menu=$module.children(selector.menu);$item=$menu.find(selector.item);},refreshData:function refreshData(){module.verbose('Refreshing cached metadata');$item.removeData(metadata.text).removeData(metadata.value);},clearData:function clearData(){module.verbose('Clearing metadata');$item.removeData(metadata.text).removeData(metadata.value);$module.removeData(metadata.defaultText).removeData(metadata.defaultValue).removeData(metadata.placeholderText);},toggle:function toggle(){module.verbose('Toggling menu visibility');if(!module.is.active()){module.show();}else{module.hide();}},show:function show(callback){callback=$.isFunction(callback)?callback:function(){};if(module.can.show()&&!module.is.active()){module.debug('Showing dropdown');if(module.has.message()&&!(module.has.maxSelections()||module.has.allResultsFiltered())){module.remove.message();}if(module.is.allFiltered()){return true;}if(settings.onShow.call(element)!==false){module.animate.show(function(){if(module.can.click()){module.bind.intent();}if(module.has.menuSearch()){module.focusSearch();}module.set.visible();callback.call(element);});}}},hide:function hide(callback){callback=$.isFunction(callback)?callback:function(){};if(module.is.active()){module.debug('Hiding dropdown');if(settings.onHide.call(element)!==false){module.animate.hide(function(){module.remove.visible();callback.call(element);});}}},hideOthers:function hideOthers(){module.verbose('Finding other dropdowns to hide');$allModules.not($module).has(selector.menu+'.'+className.visible).dropdown('hide');},hideMenu:function hideMenu(){module.verbose('Hiding menu  instantaneously');module.remove.active();module.remove.visible();$menu.transition('hide');},hideSubMenus:function hideSubMenus(){var $subMenus=$menu.children(selector.item).find(selector.menu);module.verbose('Hiding sub menus',$subMenus);$subMenus.transition('hide');},bind:{events:function events(){if(hasTouch){module.bind.touchEvents();}module.bind.keyboardEvents();module.bind.inputEvents();module.bind.mouseEvents();},touchEvents:function touchEvents(){module.debug('Touch device detected binding additional touch events');if(module.is.searchSelection()){// do nothing special yet
	}else if(module.is.single()){$module.on('touchstart'+eventNamespace,module.event.test.toggle);}$menu.on('touchstart'+eventNamespace,selector.item,module.event.item.mouseenter);},keyboardEvents:function keyboardEvents(){module.verbose('Binding keyboard events');$module.on('keydown'+eventNamespace,module.event.keydown);if(module.has.search()){$module.on(module.get.inputEvent()+eventNamespace,selector.search,module.event.input);}if(module.is.multiple()){$document.on('keydown'+elementNamespace,module.event.document.keydown);}},inputEvents:function inputEvents(){module.verbose('Binding input change events');$module.on('change'+eventNamespace,selector.input,module.event.change);},mouseEvents:function mouseEvents(){module.verbose('Binding mouse events');if(module.is.multiple()){$module.on('click'+eventNamespace,selector.label,module.event.label.click).on('click'+eventNamespace,selector.remove,module.event.remove.click);}if(module.is.searchSelection()){$module.on('mousedown'+eventNamespace,module.event.mousedown).on('mouseup'+eventNamespace,module.event.mouseup).on('mousedown'+eventNamespace,selector.menu,module.event.menu.mousedown).on('mouseup'+eventNamespace,selector.menu,module.event.menu.mouseup).on('click'+eventNamespace,selector.icon,module.event.icon.click).on('focus'+eventNamespace,selector.search,module.event.search.focus).on('click'+eventNamespace,selector.search,module.event.search.focus).on('blur'+eventNamespace,selector.search,module.event.search.blur).on('click'+eventNamespace,selector.text,module.event.text.focus);if(module.is.multiple()){$module.on('click'+eventNamespace,module.event.click);}}else{if(settings.on=='click'){$module.on('click'+eventNamespace,selector.icon,module.event.icon.click).on('click'+eventNamespace,module.event.test.toggle);}else if(settings.on=='hover'){$module.on('mouseenter'+eventNamespace,module.delay.show).on('mouseleave'+eventNamespace,module.delay.hide);}else{$module.on(settings.on+eventNamespace,module.toggle);}$module.on('mousedown'+eventNamespace,module.event.mousedown).on('mouseup'+eventNamespace,module.event.mouseup).on('focus'+eventNamespace,module.event.focus).on('blur'+eventNamespace,module.event.blur);}$menu.on('mouseenter'+eventNamespace,selector.item,module.event.item.mouseenter).on('mouseleave'+eventNamespace,selector.item,module.event.item.mouseleave).on('click'+eventNamespace,selector.item,module.event.item.click);},intent:function intent(){module.verbose('Binding hide intent event to document');if(hasTouch){$document.on('touchstart'+elementNamespace,module.event.test.touch).on('touchmove'+elementNamespace,module.event.test.touch);}$document.on('click'+elementNamespace,module.event.test.hide);}},unbind:{intent:function intent(){module.verbose('Removing hide intent event from document');if(hasTouch){$document.off('touchstart'+elementNamespace).off('touchmove'+elementNamespace);}$document.off('click'+elementNamespace);}},filter:function filter(query){var searchTerm=query!==undefined?query:module.get.query(),afterFiltered=function afterFiltered(){if(module.is.multiple()){module.filterActive();}module.select.firstUnfiltered();if(module.has.allResultsFiltered()){if(settings.onNoResults.call(element,searchTerm)){if(settings.allowAdditions){if(settings.hideAdditions){module.verbose('User addition with no menu, setting empty style');module.set.empty();module.hideMenu();}}else{module.verbose('All items filtered, showing message',searchTerm);module.add.message(message.noResults);}}else{module.verbose('All items filtered, hiding dropdown',searchTerm);module.hideMenu();}}else{module.remove.empty();module.remove.message();}if(settings.allowAdditions){module.add.userSuggestion(query);}if(module.is.searchSelection()&&module.can.show()&&module.is.focusedOnSearch()){module.show();}};if(settings.useLabels&&module.has.maxSelections()){return;}if(settings.apiSettings){if(module.can.useAPI()){module.queryRemote(searchTerm,function(){afterFiltered();});}else{module.error(error.noAPI);}}else{module.filterItems(searchTerm);afterFiltered();}},queryRemote:function queryRemote(query,callback){var apiSettings={errorDuration:false,cache:'local',throttle:settings.throttle,urlData:{query:query},onError:function onError(){module.add.message(message.serverError);callback();},onFailure:function onFailure(){module.add.message(message.serverError);callback();},onSuccess:function onSuccess(response){module.remove.message();module.setup.menu({values:response[fields.remoteValues]});callback();}};if(!$module.api('get request')){module.setup.api();}apiSettings=$.extend(true,{},apiSettings,settings.apiSettings);$module.api('setting',apiSettings).api('query');},filterItems:function filterItems(query){var searchTerm=query!==undefined?query:module.get.query(),results=null,escapedTerm=module.escape.regExp(searchTerm),beginsWithRegExp=new RegExp('^'+escapedTerm,'igm');// avoid loop if we're matching nothing
	if(module.has.query()){results=[];module.verbose('Searching for matching values',searchTerm);$item.each(function(){var $choice=$(this),text,value;if(settings.match=='both'||settings.match=='text'){text=String(module.get.choiceText($choice,false));if(text.search(beginsWithRegExp)!==-1){results.push(this);return true;}else if(settings.fullTextSearch==='exact'&&module.exactSearch(searchTerm,text)){results.push(this);return true;}else if(settings.fullTextSearch===true&&module.fuzzySearch(searchTerm,text)){results.push(this);return true;}}if(settings.match=='both'||settings.match=='value'){value=String(module.get.choiceValue($choice,text));if(value.search(beginsWithRegExp)!==-1){results.push(this);return true;}else if(settings.fullTextSearch&&module.fuzzySearch(searchTerm,value)){results.push(this);return true;}}});}module.debug('Showing only matched items',searchTerm);module.remove.filteredItem();if(results){$item.not(results).addClass(className.filtered);}},fuzzySearch:function fuzzySearch(query,term){var termLength=term.length,queryLength=query.length;query=query.toLowerCase();term=term.toLowerCase();if(queryLength>termLength){return false;}if(queryLength===termLength){return query===term;}search:for(var characterIndex=0,nextCharacterIndex=0;characterIndex<queryLength;characterIndex++){var queryCharacter=query.charCodeAt(characterIndex);while(nextCharacterIndex<termLength){if(term.charCodeAt(nextCharacterIndex++)===queryCharacter){continue search;}}return false;}return true;},exactSearch:function exactSearch(query,term){query=query.toLowerCase();term=term.toLowerCase();if(term.indexOf(query)>-1){return true;}return false;},filterActive:function filterActive(){if(settings.useLabels){$item.filter('.'+className.active).addClass(className.filtered);}},focusSearch:function focusSearch(skipHandler){if(module.has.search()&&!module.is.focusedOnSearch()){if(skipHandler){$module.off('focus'+eventNamespace,selector.search);$search.focus();$module.on('focus'+eventNamespace,selector.search,module.event.search.focus);}else{$search.focus();}}},forceSelection:function forceSelection(){var $currentlySelected=$item.not(className.filtered).filter('.'+className.selected).eq(0),$activeItem=$item.not(className.filtered).filter('.'+className.active).eq(0),$selectedItem=$currentlySelected.length>0?$currentlySelected:$activeItem,hasSelected=$selectedItem.length>0;if(hasSelected){module.debug('Forcing partial selection to selected item',$selectedItem);module.event.item.click.call($selectedItem,{},true);return;}else{if(settings.allowAdditions){module.set.selected(module.get.query());module.remove.searchTerm();}else{module.remove.searchTerm();}}},event:{change:function change(){if(!internalChange){module.debug('Input changed, updating selection');module.set.selected();}},focus:function focus(){if(settings.showOnFocus&&!activated&&module.is.hidden()&&!pageLostFocus){module.show();}},blur:function blur(event){pageLostFocus=document.activeElement===this;if(!activated&&!pageLostFocus){module.remove.activeLabel();module.hide();}},mousedown:function mousedown(){if(module.is.searchSelection()){// prevent menu hiding on immediate re-focus
	willRefocus=true;}else{// prevents focus callback from occurring on mousedown
	activated=true;}},mouseup:function mouseup(){if(module.is.searchSelection()){// prevent menu hiding on immediate re-focus
	willRefocus=false;}else{activated=false;}},click:function click(event){var $target=$(event.target);// focus search
	if($target.is($module)){if(!module.is.focusedOnSearch()){module.focusSearch();}else{module.show();}}},search:{focus:function focus(){activated=true;if(module.is.multiple()){module.remove.activeLabel();}if(settings.showOnFocus){module.search();}},blur:function blur(event){pageLostFocus=document.activeElement===this;if(!willRefocus){if(!itemActivated&&!pageLostFocus){if(settings.forceSelection){module.forceSelection();}module.hide();}}willRefocus=false;}},icon:{click:function click(event){module.toggle();}},text:{focus:function focus(event){activated=true;module.focusSearch();}},input:function input(event){if(module.is.multiple()||module.is.searchSelection()){module.set.filtered();}clearTimeout(module.timer);module.timer=setTimeout(module.search,settings.delay.search);},label:{click:function click(event){var $label=$(this),$labels=$module.find(selector.label),$activeLabels=$labels.filter('.'+className.active),$nextActive=$label.nextAll('.'+className.active),$prevActive=$label.prevAll('.'+className.active),$range=$nextActive.length>0?$label.nextUntil($nextActive).add($activeLabels).add($label):$label.prevUntil($prevActive).add($activeLabels).add($label);if(event.shiftKey){$activeLabels.removeClass(className.active);$range.addClass(className.active);}else if(event.ctrlKey){$label.toggleClass(className.active);}else{$activeLabels.removeClass(className.active);$label.addClass(className.active);}settings.onLabelSelect.apply(this,$labels.filter('.'+className.active));}},remove:{click:function click(){var $label=$(this).parent();if($label.hasClass(className.active)){// remove all selected labels
	module.remove.activeLabels();}else{// remove this label only
	module.remove.activeLabels($label);}}},test:{toggle:function toggle(event){var toggleBehavior=module.is.multiple()?module.show:module.toggle;if(module.is.bubbledLabelClick(event)||module.is.bubbledIconClick(event)){return;}if(module.determine.eventOnElement(event,toggleBehavior)){event.preventDefault();}},touch:function touch(event){module.determine.eventOnElement(event,function(){if(event.type=='touchstart'){module.timer=setTimeout(function(){module.hide();},settings.delay.touch);}else if(event.type=='touchmove'){clearTimeout(module.timer);}});event.stopPropagation();},hide:function hide(event){module.determine.eventInModule(event,module.hide);}},select:{mutation:function mutation(mutations){module.debug('<select> modified, recreating menu');module.setup.select();}},menu:{mutation:function mutation(mutations){var mutation=mutations[0],$addedNode=mutation.addedNodes?$(mutation.addedNodes[0]):$(false),$removedNode=mutation.removedNodes?$(mutation.removedNodes[0]):$(false),$changedNodes=$addedNode.add($removedNode),isUserAddition=$changedNodes.is(selector.addition)||$changedNodes.closest(selector.addition).length>0,isMessage=$changedNodes.is(selector.message)||$changedNodes.closest(selector.message).length>0;if(isUserAddition||isMessage){module.debug('Updating item selector cache');module.refreshItems();}else{module.debug('Menu modified, updating selector cache');module.refresh();}},mousedown:function mousedown(){itemActivated=true;},mouseup:function mouseup(){itemActivated=false;}},item:{mouseenter:function mouseenter(event){var $target=$(event.target),$item=$(this),$subMenu=$item.children(selector.menu),$otherMenus=$item.siblings(selector.item).children(selector.menu),hasSubMenu=$subMenu.length>0,isBubbledEvent=$subMenu.find($target).length>0;if(!isBubbledEvent&&hasSubMenu){clearTimeout(module.itemTimer);module.itemTimer=setTimeout(function(){module.verbose('Showing sub-menu',$subMenu);$.each($otherMenus,function(){module.animate.hide(false,$(this));});module.animate.show(false,$subMenu);},settings.delay.show);event.preventDefault();}},mouseleave:function mouseleave(event){var $subMenu=$(this).children(selector.menu);if($subMenu.length>0){clearTimeout(module.itemTimer);module.itemTimer=setTimeout(function(){module.verbose('Hiding sub-menu',$subMenu);module.animate.hide(false,$subMenu);},settings.delay.hide);}},click:function click(event,skipRefocus){var $choice=$(this),$target=event?$(event.target):$(''),$subMenu=$choice.find(selector.menu),text=module.get.choiceText($choice),value=module.get.choiceValue($choice,text),hasSubMenu=$subMenu.length>0,isBubbledEvent=$subMenu.find($target).length>0;if(!isBubbledEvent&&(!hasSubMenu||settings.allowCategorySelection)){if(module.is.searchSelection()){if(settings.allowAdditions){module.remove.userAddition();}module.remove.searchTerm();if(!module.is.focusedOnSearch()&&!(skipRefocus==true)){module.focusSearch(true);}}if(!settings.useLabels){module.remove.filteredItem();module.set.scrollPosition($choice);}module.determine.selectAction.call(this,text,value);}}},document:{// label selection should occur even when element has no focus
	keydown:function keydown(event){var pressedKey=event.which,isShortcutKey=module.is.inObject(pressedKey,keys);if(isShortcutKey){var $label=$module.find(selector.label),$activeLabel=$label.filter('.'+className.active),activeValue=$activeLabel.data(metadata.value),labelIndex=$label.index($activeLabel),labelCount=$label.length,hasActiveLabel=$activeLabel.length>0,hasMultipleActive=$activeLabel.length>1,isFirstLabel=labelIndex===0,isLastLabel=labelIndex+1==labelCount,isSearch=module.is.searchSelection(),isFocusedOnSearch=module.is.focusedOnSearch(),isFocused=module.is.focused(),caretAtStart=isFocusedOnSearch&&module.get.caretPosition()===0,$nextLabel;if(isSearch&&!hasActiveLabel&&!isFocusedOnSearch){return;}if(pressedKey==keys.leftArrow){// activate previous label
	if((isFocused||caretAtStart)&&!hasActiveLabel){module.verbose('Selecting previous label');$label.last().addClass(className.active);}else if(hasActiveLabel){if(!event.shiftKey){module.verbose('Selecting previous label');$label.removeClass(className.active);}else{module.verbose('Adding previous label to selection');}if(isFirstLabel&&!hasMultipleActive){$activeLabel.addClass(className.active);}else{$activeLabel.prev(selector.siblingLabel).addClass(className.active).end();}event.preventDefault();}}else if(pressedKey==keys.rightArrow){// activate first label
	if(isFocused&&!hasActiveLabel){$label.first().addClass(className.active);}// activate next label
	if(hasActiveLabel){if(!event.shiftKey){module.verbose('Selecting next label');$label.removeClass(className.active);}else{module.verbose('Adding next label to selection');}if(isLastLabel){if(isSearch){if(!isFocusedOnSearch){module.focusSearch();}else{$label.removeClass(className.active);}}else if(hasMultipleActive){$activeLabel.next(selector.siblingLabel).addClass(className.active);}else{$activeLabel.addClass(className.active);}}else{$activeLabel.next(selector.siblingLabel).addClass(className.active);}event.preventDefault();}}else if(pressedKey==keys.deleteKey||pressedKey==keys.backspace){if(hasActiveLabel){module.verbose('Removing active labels');if(isLastLabel){if(isSearch&&!isFocusedOnSearch){module.focusSearch();}}$activeLabel.last().next(selector.siblingLabel).addClass(className.active);module.remove.activeLabels($activeLabel);event.preventDefault();}else if(caretAtStart&&!hasActiveLabel&&pressedKey==keys.backspace){module.verbose('Removing last label on input backspace');$activeLabel=$label.last().addClass(className.active);module.remove.activeLabels($activeLabel);}}else{$activeLabel.removeClass(className.active);}}}},keydown:function keydown(event){var pressedKey=event.which,isShortcutKey=module.is.inObject(pressedKey,keys);if(isShortcutKey){var $currentlySelected=$item.not(selector.unselectable).filter('.'+className.selected).eq(0),$activeItem=$menu.children('.'+className.active).eq(0),$selectedItem=$currentlySelected.length>0?$currentlySelected:$activeItem,$visibleItems=$selectedItem.length>0?$selectedItem.siblings(':not(.'+className.filtered+')').addBack():$menu.children(':not(.'+className.filtered+')'),$subMenu=$selectedItem.children(selector.menu),$parentMenu=$selectedItem.closest(selector.menu),inVisibleMenu=$parentMenu.hasClass(className.visible)||$parentMenu.hasClass(className.animating)||$parentMenu.parent(selector.menu).length>0,hasSubMenu=$subMenu.length>0,hasSelectedItem=$selectedItem.length>0,selectedIsSelectable=$selectedItem.not(selector.unselectable).length>0,delimiterPressed=pressedKey==keys.delimiter&&settings.allowAdditions&&module.is.multiple(),isAdditionWithoutMenu=settings.allowAdditions&&settings.hideAdditions&&(pressedKey==keys.enter||delimiterPressed)&&selectedIsSelectable,$nextItem,isSubMenuItem,newIndex;// allow selection with menu closed
	if(isAdditionWithoutMenu){module.verbose('Selecting item from keyboard shortcut',$selectedItem);module.event.item.click.call($selectedItem,event);if(module.is.searchSelection()){module.remove.searchTerm();}}// visible menu keyboard shortcuts
	if(module.is.visible()){// enter (select or open sub-menu)
	if(pressedKey==keys.enter||delimiterPressed){if(pressedKey==keys.enter&&hasSelectedItem&&hasSubMenu&&!settings.allowCategorySelection){module.verbose('Pressed enter on unselectable category, opening sub menu');pressedKey=keys.rightArrow;}else if(selectedIsSelectable){module.verbose('Selecting item from keyboard shortcut',$selectedItem);module.event.item.click.call($selectedItem,event);if(module.is.searchSelection()){module.remove.searchTerm();}}event.preventDefault();}// sub-menu actions
	if(hasSelectedItem){if(pressedKey==keys.leftArrow){isSubMenuItem=$parentMenu[0]!==$menu[0];if(isSubMenuItem){module.verbose('Left key pressed, closing sub-menu');module.animate.hide(false,$parentMenu);$selectedItem.removeClass(className.selected);$parentMenu.closest(selector.item).addClass(className.selected);event.preventDefault();}}// right arrow (show sub-menu)
	if(pressedKey==keys.rightArrow){if(hasSubMenu){module.verbose('Right key pressed, opening sub-menu');module.animate.show(false,$subMenu);$selectedItem.removeClass(className.selected);$subMenu.find(selector.item).eq(0).addClass(className.selected);event.preventDefault();}}}// up arrow (traverse menu up)
	if(pressedKey==keys.upArrow){$nextItem=hasSelectedItem&&inVisibleMenu?$selectedItem.prevAll(selector.item+':not('+selector.unselectable+')').eq(0):$item.eq(0);if($visibleItems.index($nextItem)<0){module.verbose('Up key pressed but reached top of current menu');event.preventDefault();return;}else{module.verbose('Up key pressed, changing active item');$selectedItem.removeClass(className.selected);$nextItem.addClass(className.selected);module.set.scrollPosition($nextItem);if(settings.selectOnKeydown&&module.is.single()){module.set.selectedItem($nextItem);}}event.preventDefault();}// down arrow (traverse menu down)
	if(pressedKey==keys.downArrow){$nextItem=hasSelectedItem&&inVisibleMenu?$nextItem=$selectedItem.nextAll(selector.item+':not('+selector.unselectable+')').eq(0):$item.eq(0);if($nextItem.length===0){module.verbose('Down key pressed but reached bottom of current menu');event.preventDefault();return;}else{module.verbose('Down key pressed, changing active item');$item.removeClass(className.selected);$nextItem.addClass(className.selected);module.set.scrollPosition($nextItem);if(settings.selectOnKeydown&&module.is.single()){module.set.selectedItem($nextItem);}}event.preventDefault();}// page down (show next page)
	if(pressedKey==keys.pageUp){module.scrollPage('up');event.preventDefault();}if(pressedKey==keys.pageDown){module.scrollPage('down');event.preventDefault();}// escape (close menu)
	if(pressedKey==keys.escape){module.verbose('Escape key pressed, closing dropdown');module.hide();}}else{// delimiter key
	if(delimiterPressed){event.preventDefault();}// down arrow (open menu)
	if(pressedKey==keys.downArrow&&!module.is.visible()){module.verbose('Down key pressed, showing dropdown');module.select.firstUnfiltered();module.show();event.preventDefault();}}}else{if(!module.has.search()){module.set.selectedLetter(String.fromCharCode(pressedKey));}}}},trigger:{change:function change(){var events=document.createEvent('HTMLEvents'),inputElement=$input[0];if(inputElement){module.verbose('Triggering native change event');events.initEvent('change',true,false);inputElement.dispatchEvent(events);}}},determine:{selectAction:function selectAction(text,value){module.verbose('Determining action',settings.action);if($.isFunction(module.action[settings.action])){module.verbose('Triggering preset action',settings.action,text,value);module.action[settings.action].call(element,text,value,this);}else if($.isFunction(settings.action)){module.verbose('Triggering user action',settings.action,text,value);settings.action.call(element,text,value,this);}else{module.error(error.action,settings.action);}},eventInModule:function eventInModule(event,callback){var $target=$(event.target),inDocument=$target.closest(document.documentElement).length>0,inModule=$target.closest($module).length>0;callback=$.isFunction(callback)?callback:function(){};if(inDocument&&!inModule){module.verbose('Triggering event',callback);callback();return true;}else{module.verbose('Event occurred in dropdown, canceling callback');return false;}},eventOnElement:function eventOnElement(event,callback){var $target=$(event.target),$label=$target.closest(selector.siblingLabel),inVisibleDOM=document.body.contains(event.target),notOnLabel=$module.find($label).length===0,notInMenu=$target.closest($menu).length===0;callback=$.isFunction(callback)?callback:function(){};if(inVisibleDOM&&notOnLabel&&notInMenu){module.verbose('Triggering event',callback);callback();return true;}else{module.verbose('Event occurred in dropdown menu, canceling callback');return false;}}},action:{nothing:function nothing(){},activate:function activate(text,value,element){value=value!==undefined?value:text;if(module.can.activate($(element))){module.set.selected(value,$(element));if(module.is.multiple()&&!module.is.allFiltered()){return;}else{module.hideAndClear();}}},select:function select(text,value,element){value=value!==undefined?value:text;if(module.can.activate($(element))){module.set.value(value,$(element));if(module.is.multiple()&&!module.is.allFiltered()){return;}else{module.hideAndClear();}}},combo:function combo(text,value,element){value=value!==undefined?value:text;module.set.selected(value,$(element));module.hideAndClear();},hide:function hide(text,value,element){module.set.value(value,text);module.hideAndClear();}},get:{id:function id(){return _id;},defaultText:function defaultText(){return $module.data(metadata.defaultText);},defaultValue:function defaultValue(){return $module.data(metadata.defaultValue);},placeholderText:function placeholderText(){return $module.data(metadata.placeholderText)||'';},text:function text(){return $text.text();},query:function query(){return $.trim($search.val());},searchWidth:function searchWidth(value){value=value!==undefined?value:$search.val();$sizer.text(value);// prevent rounding issues
	return Math.ceil($sizer.width()+1);},selectionCount:function selectionCount(){var values=module.get.values(),count;count=module.is.multiple()?$.isArray(values)?values.length:0:module.get.value()!==''?1:0;return count;},transition:function transition($subMenu){return settings.transition=='auto'?module.is.upward($subMenu)?'slide up':'slide down':settings.transition;},userValues:function userValues(){var values=module.get.values();if(!values){return false;}values=$.isArray(values)?values:[values];return $.grep(values,function(value){return module.get.item(value)===false;});},uniqueArray:function uniqueArray(array){return $.grep(array,function(value,index){return $.inArray(value,array)===index;});},caretPosition:function caretPosition(){var input=$search.get(0),range,rangeLength;if('selectionStart'in input){return input.selectionStart;}else if(document.selection){input.focus();range=document.selection.createRange();rangeLength=range.text.length;range.moveStart('character',-input.value.length);return range.text.length-rangeLength;}},value:function value(){var value=$input.length>0?$input.val():$module.data(metadata.value),isEmptyMultiselect=$.isArray(value)&&value.length===1&&value[0]==='';// prevents placeholder element from being selected when multiple
	return value===undefined||isEmptyMultiselect?'':value;},values:function values(){var value=module.get.value();if(value===''){return'';}return!module.has.selectInput()&&module.is.multiple()?typeof value=='string'?// delimited string
	value.split(settings.delimiter):'':value;},remoteValues:function remoteValues(){var values=module.get.values(),remoteValues=false;if(values){if(typeof values=='string'){values=[values];}$.each(values,function(index,value){var name=module.read.remoteData(value);module.verbose('Restoring value from session data',name,value);if(name){if(!remoteValues){remoteValues={};}remoteValues[value]=name;}});}return remoteValues;},choiceText:function choiceText($choice,preserveHTML){preserveHTML=preserveHTML!==undefined?preserveHTML:settings.preserveHTML;if($choice){if($choice.find(selector.menu).length>0){module.verbose('Retrieving text of element with sub-menu');$choice=$choice.clone();$choice.find(selector.menu).remove();$choice.find(selector.menuIcon).remove();}return $choice.data(metadata.text)!==undefined?$choice.data(metadata.text):preserveHTML?$.trim($choice.html()):$.trim($choice.text());}},choiceValue:function choiceValue($choice,choiceText){choiceText=choiceText||module.get.choiceText($choice);if(!$choice){return false;}return $choice.data(metadata.value)!==undefined?String($choice.data(metadata.value)):typeof choiceText==='string'?$.trim(choiceText.toLowerCase()):String(choiceText);},inputEvent:function inputEvent(){var input=$search[0];if(input){return input.oninput!==undefined?'input':input.onpropertychange!==undefined?'propertychange':'keyup';}return false;},selectValues:function selectValues(){var select={};select.values=[];$module.find('option').each(function(){var $option=$(this),name=$option.html(),disabled=$option.attr('disabled'),value=$option.attr('value')!==undefined?$option.attr('value'):name;if(settings.placeholder==='auto'&&value===''){select.placeholder=name;}else{select.values.push({name:name,value:value,disabled:disabled});}});if(settings.placeholder&&settings.placeholder!=='auto'){module.debug('Setting placeholder value to',settings.placeholder);select.placeholder=settings.placeholder;}if(settings.sortSelect){select.values.sort(function(a,b){return a.name>b.name?1:-1;});module.debug('Retrieved and sorted values from select',select);}else{module.debug('Retrieved values from select',select);}return select;},activeItem:function activeItem(){return $item.filter('.'+className.active);},selectedItem:function selectedItem(){var $selectedItem=$item.not(selector.unselectable).filter('.'+className.selected);return $selectedItem.length>0?$selectedItem:$item.eq(0);},itemWithAdditions:function itemWithAdditions(value){var $items=module.get.item(value),$userItems=module.create.userChoice(value),hasUserItems=$userItems&&$userItems.length>0;if(hasUserItems){$items=$items.length>0?$items.add($userItems):$userItems;}return $items;},item:function item(value,strict){var $selectedItem=false,shouldSearch,isMultiple;value=value!==undefined?value:module.get.values()!==undefined?module.get.values():module.get.text();shouldSearch=isMultiple?value.length>0:value!==undefined&&value!==null;isMultiple=module.is.multiple()&&$.isArray(value);strict=value===''||value===0?true:strict||false;if(shouldSearch){$item.each(function(){var $choice=$(this),optionText=module.get.choiceText($choice),optionValue=module.get.choiceValue($choice,optionText);// safe early exit
	if(optionValue===null||optionValue===undefined){return;}if(isMultiple){if($.inArray(String(optionValue),value)!==-1||$.inArray(optionText,value)!==-1){$selectedItem=$selectedItem?$selectedItem.add($choice):$choice;}}else if(strict){module.verbose('Ambiguous dropdown value using strict type check',$choice,value);if(optionValue===value||optionText===value){$selectedItem=$choice;return true;}}else{if(String(optionValue)==String(value)||optionText==value){module.verbose('Found select item by value',optionValue,value);$selectedItem=$choice;return true;}}});}return $selectedItem;}},check:{maxSelections:function maxSelections(selectionCount){if(settings.maxSelections){selectionCount=selectionCount!==undefined?selectionCount:module.get.selectionCount();if(selectionCount>=settings.maxSelections){module.debug('Maximum selection count reached');if(settings.useLabels){$item.addClass(className.filtered);module.add.message(message.maxSelections);}return true;}else{module.verbose('No longer at maximum selection count');module.remove.message();module.remove.filteredItem();if(module.is.searchSelection()){module.filterItems();}return false;}}return true;}},restore:{defaults:function defaults(){module.clear();module.restore.defaultText();module.restore.defaultValue();},defaultText:function defaultText(){var defaultText=module.get.defaultText(),placeholderText=module.get.placeholderText;if(defaultText===placeholderText){module.debug('Restoring default placeholder text',defaultText);module.set.placeholderText(defaultText);}else{module.debug('Restoring default text',defaultText);module.set.text(defaultText);}},placeholderText:function placeholderText(){module.set.placeholderText();},defaultValue:function defaultValue(){var defaultValue=module.get.defaultValue();if(defaultValue!==undefined){module.debug('Restoring default value',defaultValue);if(defaultValue!==''){module.set.value(defaultValue);module.set.selected();}else{module.remove.activeItem();module.remove.selectedItem();}}},labels:function labels(){if(settings.allowAdditions){if(!settings.useLabels){module.error(error.labels);settings.useLabels=true;}module.debug('Restoring selected values');module.create.userLabels();}module.check.maxSelections();},selected:function selected(){module.restore.values();if(module.is.multiple()){module.debug('Restoring previously selected values and labels');module.restore.labels();}else{module.debug('Restoring previously selected values');}},values:function values(){// prevents callbacks from occurring on initial load
	module.set.initialLoad();if(settings.apiSettings&&settings.saveRemoteData&&module.get.remoteValues()){module.restore.remoteValues();}else{module.set.selected();}module.remove.initialLoad();},remoteValues:function remoteValues(){var values=module.get.remoteValues();module.debug('Recreating selected from session data',values);if(values){if(module.is.single()){$.each(values,function(value,name){module.set.text(name);});}else{$.each(values,function(value,name){module.add.label(value,name);});}}}},read:{remoteData:function remoteData(value){var name;if(window.Storage===undefined){module.error(error.noStorage);return;}name=sessionStorage.getItem(value);return name!==undefined?name:false;}},save:{defaults:function defaults(){module.save.defaultText();module.save.placeholderText();module.save.defaultValue();},defaultValue:function defaultValue(){var value=module.get.value();module.verbose('Saving default value as',value);$module.data(metadata.defaultValue,value);},defaultText:function defaultText(){var text=module.get.text();module.verbose('Saving default text as',text);$module.data(metadata.defaultText,text);},placeholderText:function placeholderText(){var text;if(settings.placeholder!==false&&$text.hasClass(className.placeholder)){text=module.get.text();module.verbose('Saving placeholder text as',text);$module.data(metadata.placeholderText,text);}},remoteData:function remoteData(name,value){if(window.Storage===undefined){module.error(error.noStorage);return;}module.verbose('Saving remote data to session storage',value,name);sessionStorage.setItem(value,name);}},clear:function clear(){if(module.is.multiple()&&settings.useLabels){module.remove.labels();}else{module.remove.activeItem();module.remove.selectedItem();}module.set.placeholderText();module.clearValue();},clearValue:function clearValue(){module.set.value('');},scrollPage:function scrollPage(direction,$selectedItem){var $currentItem=$selectedItem||module.get.selectedItem(),$menu=$currentItem.closest(selector.menu),menuHeight=$menu.outerHeight(),currentScroll=$menu.scrollTop(),itemHeight=$item.eq(0).outerHeight(),itemsPerPage=Math.floor(menuHeight/itemHeight),maxScroll=$menu.prop('scrollHeight'),newScroll=direction=='up'?currentScroll-itemHeight*itemsPerPage:currentScroll+itemHeight*itemsPerPage,$selectableItem=$item.not(selector.unselectable),isWithinRange,$nextSelectedItem,elementIndex;elementIndex=direction=='up'?$selectableItem.index($currentItem)-itemsPerPage:$selectableItem.index($currentItem)+itemsPerPage;isWithinRange=direction=='up'?elementIndex>=0:elementIndex<$selectableItem.length;$nextSelectedItem=isWithinRange?$selectableItem.eq(elementIndex):direction=='up'?$selectableItem.first():$selectableItem.last();if($nextSelectedItem.length>0){module.debug('Scrolling page',direction,$nextSelectedItem);$currentItem.removeClass(className.selected);$nextSelectedItem.addClass(className.selected);if(settings.selectOnKeydown&&module.is.single()){module.set.selectedItem($nextSelectedItem);}$menu.scrollTop(newScroll);}},set:{filtered:function filtered(){var isMultiple=module.is.multiple(),isSearch=module.is.searchSelection(),isSearchMultiple=isMultiple&&isSearch,searchValue=isSearch?module.get.query():'',hasSearchValue=typeof searchValue==='string'&&searchValue.length>0,searchWidth=module.get.searchWidth(),valueIsSet=searchValue!=='';if(isMultiple&&hasSearchValue){module.verbose('Adjusting input width',searchWidth,settings.glyphWidth);$search.css('width',searchWidth);}if(hasSearchValue||isSearchMultiple&&valueIsSet){module.verbose('Hiding placeholder text');$text.addClass(className.filtered);}else if(!isMultiple||isSearchMultiple&&!valueIsSet){module.verbose('Showing placeholder text');$text.removeClass(className.filtered);}},empty:function empty(){$module.addClass(className.empty);},loading:function loading(){$module.addClass(className.loading);},placeholderText:function placeholderText(text){text=text||module.get.placeholderText();module.debug('Setting placeholder text',text);module.set.text(text);$text.addClass(className.placeholder);},tabbable:function tabbable(){if(module.has.search()){module.debug('Added tabindex to searchable dropdown');$search.val('').attr('tabindex',0);$menu.attr('tabindex',-1);}else{module.debug('Added tabindex to dropdown');if($module.attr('tabindex')===undefined){$module.attr('tabindex',0);$menu.attr('tabindex',-1);}}},initialLoad:function initialLoad(){module.verbose('Setting initial load');_initialLoad=true;},activeItem:function activeItem($item){if(settings.allowAdditions&&$item.filter(selector.addition).length>0){$item.addClass(className.filtered);}else{$item.addClass(className.active);}},partialSearch:function partialSearch(text){var length=module.get.query().length;$search.val(text.substr(0,length));},scrollPosition:function scrollPosition($item,forceScroll){var edgeTolerance=5,$menu,hasActive,offset,itemHeight,itemOffset,menuOffset,menuScroll,menuHeight,abovePage,belowPage;$item=$item||module.get.selectedItem();$menu=$item.closest(selector.menu);hasActive=$item&&$item.length>0;forceScroll=forceScroll!==undefined?forceScroll:false;if($item&&$menu.length>0&&hasActive){itemOffset=$item.position().top;$menu.addClass(className.loading);menuScroll=$menu.scrollTop();menuOffset=$menu.offset().top;itemOffset=$item.offset().top;offset=menuScroll-menuOffset+itemOffset;if(!forceScroll){menuHeight=$menu.height();belowPage=menuScroll+menuHeight<offset+edgeTolerance;abovePage=offset-edgeTolerance<menuScroll;}module.debug('Scrolling to active item',offset);if(forceScroll||abovePage||belowPage){$menu.scrollTop(offset);}$menu.removeClass(className.loading);}},text:function text(_text){if(settings.action!=='select'){if(settings.action=='combo'){module.debug('Changing combo button text',_text,$combo);if(settings.preserveHTML){$combo.html(_text);}else{$combo.text(_text);}}else{if(_text!==module.get.placeholderText()){$text.removeClass(className.placeholder);}module.debug('Changing text',_text,$text);$text.removeClass(className.filtered);if(settings.preserveHTML){$text.html(_text);}else{$text.text(_text);}}}},selectedItem:function selectedItem($item){var value=module.get.choiceValue($item),text=module.get.choiceText($item,false);module.debug('Setting user selection to item',$item);module.remove.activeItem();module.set.partialSearch(text);module.set.activeItem($item);module.set.selected(value,$item);module.set.text(text);},selectedLetter:function selectedLetter(letter){var $selectedItem=$item.filter('.'+className.selected),alreadySelectedLetter=$selectedItem.length>0&&module.has.firstLetter($selectedItem,letter),$nextValue=false,$nextItem;// check next of same letter
	if(alreadySelectedLetter){$nextItem=$selectedItem.nextAll($item).eq(0);if(module.has.firstLetter($nextItem,letter)){$nextValue=$nextItem;}}// check all values
	if(!$nextValue){$item.each(function(){if(module.has.firstLetter($(this),letter)){$nextValue=$(this);return false;}});}// set next value
	if($nextValue){module.verbose('Scrolling to next value with letter',letter);module.set.scrollPosition($nextValue);$selectedItem.removeClass(className.selected);$nextValue.addClass(className.selected);if(settings.selectOnKeydown&&module.is.single()){module.set.selectedItem($nextValue);}}},direction:function direction($menu){if(settings.direction=='auto'){if(module.is.onScreen($menu)){module.remove.upward($menu);}else{module.set.upward($menu);}}else if(settings.direction=='upward'){module.set.upward($menu);}},upward:function upward($menu){var $element=$menu||$module;$element.addClass(className.upward);},value:function value(_value,text,$selected){var escapedValue=module.escape.value(_value),hasInput=$input.length>0,isAddition=!module.has.value(_value),currentValue=module.get.values(),stringValue=_value!==undefined?String(_value):_value,newValue;if(hasInput){if(!settings.allowReselection&&stringValue==currentValue){module.verbose('Skipping value update already same value',_value,currentValue);if(!module.is.initialLoad()){return;}}if(module.is.single()&&module.has.selectInput()&&module.can.extendSelect()){module.debug('Adding user option',_value);module.add.optionValue(_value);}module.debug('Updating input value',escapedValue,currentValue);internalChange=true;$input.val(escapedValue);if(settings.fireOnInit===false&&module.is.initialLoad()){module.debug('Input native change event ignored on initial load');}else{module.trigger.change();}internalChange=false;}else{module.verbose('Storing value in metadata',escapedValue,$input);if(escapedValue!==currentValue){$module.data(metadata.value,stringValue);}}if(settings.fireOnInit===false&&module.is.initialLoad()){module.verbose('No callback on initial load',settings.onChange);}else{settings.onChange.call(element,_value,text,$selected);}},active:function active(){$module.addClass(className.active);},multiple:function multiple(){$module.addClass(className.multiple);},visible:function visible(){$module.addClass(className.visible);},exactly:function exactly(value,$selectedItem){module.debug('Setting selected to exact values');module.clear();module.set.selected(value,$selectedItem);},selected:function selected(value,$selectedItem){var isMultiple=module.is.multiple(),$userSelectedItem;$selectedItem=settings.allowAdditions?$selectedItem||module.get.itemWithAdditions(value):$selectedItem||module.get.item(value);if(!$selectedItem){return;}module.debug('Setting selected menu item to',$selectedItem);if(module.is.multiple()){module.remove.searchWidth();}if(module.is.single()){module.remove.activeItem();module.remove.selectedItem();}else if(settings.useLabels){module.remove.selectedItem();}// select each item
	$selectedItem.each(function(){var $selected=$(this),selectedText=module.get.choiceText($selected),selectedValue=module.get.choiceValue($selected,selectedText),isFiltered=$selected.hasClass(className.filtered),isActive=$selected.hasClass(className.active),isUserValue=$selected.hasClass(className.addition),shouldAnimate=isMultiple&&$selectedItem.length==1;if(isMultiple){if(!isActive||isUserValue){if(settings.apiSettings&&settings.saveRemoteData){module.save.remoteData(selectedText,selectedValue);}if(settings.useLabels){module.add.value(selectedValue,selectedText,$selected);module.add.label(selectedValue,selectedText,shouldAnimate);module.set.activeItem($selected);module.filterActive();module.select.nextAvailable($selectedItem);}else{module.add.value(selectedValue,selectedText,$selected);module.set.text(module.add.variables(message.count));module.set.activeItem($selected);}}else if(!isFiltered){module.debug('Selected active value, removing label');module.remove.selected(selectedValue);}}else{if(settings.apiSettings&&settings.saveRemoteData){module.save.remoteData(selectedText,selectedValue);}module.set.text(selectedText);module.set.value(selectedValue,selectedText,$selected);$selected.addClass(className.active).addClass(className.selected);}});}},add:{label:function label(value,text,shouldAnimate){var $next=module.is.searchSelection()?$search:$text,escapedValue=module.escape.value(value),$label;$label=$('<a />').addClass(className.label).attr('data-value',escapedValue).html(templates.label(escapedValue,text));$label=settings.onLabelCreate.call($label,escapedValue,text);if(module.has.label(value)){module.debug('Label already exists, skipping',escapedValue);return;}if(settings.label.variation){$label.addClass(settings.label.variation);}if(shouldAnimate===true){module.debug('Animating in label',$label);$label.addClass(className.hidden).insertBefore($next).transition(settings.label.transition,settings.label.duration);}else{module.debug('Adding selection label',$label);$label.insertBefore($next);}},message:function message(_message){var $message=$menu.children(selector.message),html=settings.templates.message(module.add.variables(_message));if($message.length>0){$message.html(html);}else{$message=$('<div/>').html(html).addClass(className.message).appendTo($menu);}},optionValue:function optionValue(value){var escapedValue=module.escape.value(value),$option=$input.find('option[value="'+escapedValue+'"]'),hasOption=$option.length>0;if(hasOption){return;}// temporarily disconnect observer
	module.disconnect.selectObserver();if(module.is.single()){module.verbose('Removing previous user addition');$input.find('option.'+className.addition).remove();}$('<option/>').prop('value',escapedValue).addClass(className.addition).html(value).appendTo($input);module.verbose('Adding user addition as an <option>',value);module.observe.select();},userSuggestion:function userSuggestion(value){var $addition=$menu.children(selector.addition),$existingItem=module.get.item(value),alreadyHasValue=$existingItem&&$existingItem.not(selector.addition).length,hasUserSuggestion=$addition.length>0,html;if(settings.useLabels&&module.has.maxSelections()){return;}if(value===''||alreadyHasValue){$addition.remove();return;}if(hasUserSuggestion){$addition.data(metadata.value,value).data(metadata.text,value).attr('data-'+metadata.value,value).attr('data-'+metadata.text,value).removeClass(className.filtered);if(!settings.hideAdditions){html=settings.templates.addition(module.add.variables(message.addResult,value));$addition.html(html);}module.verbose('Replacing user suggestion with new value',$addition);}else{$addition=module.create.userChoice(value);$addition.prependTo($menu);module.verbose('Adding item choice to menu corresponding with user choice addition',$addition);}if(!settings.hideAdditions||module.is.allFiltered()){$addition.addClass(className.selected).siblings().removeClass(className.selected);}module.refreshItems();},variables:function variables(message,term){var hasCount=message.search('{count}')!==-1,hasMaxCount=message.search('{maxCount}')!==-1,hasTerm=message.search('{term}')!==-1,values,count,query;module.verbose('Adding templated variables to message',message);if(hasCount){count=module.get.selectionCount();message=message.replace('{count}',count);}if(hasMaxCount){count=module.get.selectionCount();message=message.replace('{maxCount}',settings.maxSelections);}if(hasTerm){query=term||module.get.query();message=message.replace('{term}',query);}return message;},value:function value(addedValue,addedText,$selectedItem){var currentValue=module.get.values(),newValue;if(addedValue===''){module.debug('Cannot select blank values from multiselect');return;}// extend current array
	if($.isArray(currentValue)){newValue=currentValue.concat([addedValue]);newValue=module.get.uniqueArray(newValue);}else{newValue=[addedValue];}// add values
	if(module.has.selectInput()){if(module.can.extendSelect()){module.debug('Adding value to select',addedValue,newValue,$input);module.add.optionValue(addedValue);}}else{newValue=newValue.join(settings.delimiter);module.debug('Setting hidden input to delimited value',newValue,$input);}if(settings.fireOnInit===false&&module.is.initialLoad()){module.verbose('Skipping onadd callback on initial load',settings.onAdd);}else{settings.onAdd.call(element,addedValue,addedText,$selectedItem);}module.set.value(newValue,addedValue,addedText,$selectedItem);module.check.maxSelections();}},remove:{active:function active(){$module.removeClass(className.active);},activeLabel:function activeLabel(){$module.find(selector.label).removeClass(className.active);},empty:function empty(){$module.removeClass(className.empty);},loading:function loading(){$module.removeClass(className.loading);},initialLoad:function initialLoad(){_initialLoad=false;},upward:function upward($menu){var $element=$menu||$module;$element.removeClass(className.upward);},visible:function visible(){$module.removeClass(className.visible);},activeItem:function activeItem(){$item.removeClass(className.active);},filteredItem:function filteredItem(){if(settings.useLabels&&module.has.maxSelections()){return;}if(settings.useLabels&&module.is.multiple()){$item.not('.'+className.active).removeClass(className.filtered);}else{$item.removeClass(className.filtered);}module.remove.empty();},optionValue:function optionValue(value){var escapedValue=module.escape.value(value),$option=$input.find('option[value="'+escapedValue+'"]'),hasOption=$option.length>0;if(!hasOption||!$option.hasClass(className.addition)){return;}// temporarily disconnect observer
	if(_selectObserver){_selectObserver.disconnect();module.verbose('Temporarily disconnecting mutation observer');}$option.remove();module.verbose('Removing user addition as an <option>',escapedValue);if(_selectObserver){_selectObserver.observe($input[0],{childList:true,subtree:true});}},message:function message(){$menu.children(selector.message).remove();},searchWidth:function searchWidth(){$search.css('width','');},searchTerm:function searchTerm(){module.verbose('Cleared search term');$search.val('');module.set.filtered();},userAddition:function userAddition(){$item.filter(selector.addition).remove();},selected:function selected(value,$selectedItem){$selectedItem=settings.allowAdditions?$selectedItem||module.get.itemWithAdditions(value):$selectedItem||module.get.item(value);if(!$selectedItem){return false;}$selectedItem.each(function(){var $selected=$(this),selectedText=module.get.choiceText($selected),selectedValue=module.get.choiceValue($selected,selectedText);if(module.is.multiple()){if(settings.useLabels){module.remove.value(selectedValue,selectedText,$selected);module.remove.label(selectedValue);}else{module.remove.value(selectedValue,selectedText,$selected);if(module.get.selectionCount()===0){module.set.placeholderText();}else{module.set.text(module.add.variables(message.count));}}}else{module.remove.value(selectedValue,selectedText,$selected);}$selected.removeClass(className.filtered).removeClass(className.active);if(settings.useLabels){$selected.removeClass(className.selected);}});},selectedItem:function selectedItem(){$item.removeClass(className.selected);},value:function value(removedValue,removedText,$removedItem){var values=module.get.values(),newValue;if(module.has.selectInput()){module.verbose('Input is <select> removing selected option',removedValue);newValue=module.remove.arrayValue(removedValue,values);module.remove.optionValue(removedValue);}else{module.verbose('Removing from delimited values',removedValue);newValue=module.remove.arrayValue(removedValue,values);newValue=newValue.join(settings.delimiter);}if(settings.fireOnInit===false&&module.is.initialLoad()){module.verbose('No callback on initial load',settings.onRemove);}else{settings.onRemove.call(element,removedValue,removedText,$removedItem);}module.set.value(newValue,removedText,$removedItem);module.check.maxSelections();},arrayValue:function arrayValue(removedValue,values){if(!$.isArray(values)){values=[values];}values=$.grep(values,function(value){return removedValue!=value;});module.verbose('Removed value from delimited string',removedValue,values);return values;},label:function label(value,shouldAnimate){var $labels=$module.find(selector.label),$removedLabel=$labels.filter('[data-value="'+value+'"]');module.verbose('Removing label',$removedLabel);$removedLabel.remove();},activeLabels:function activeLabels($activeLabels){$activeLabels=$activeLabels||$module.find(selector.label).filter('.'+className.active);module.verbose('Removing active label selections',$activeLabels);module.remove.labels($activeLabels);},labels:function labels($labels){$labels=$labels||$module.find(selector.label);module.verbose('Removing labels',$labels);$labels.each(function(){var $label=$(this),value=$label.data(metadata.value),stringValue=value!==undefined?String(value):value,isUserValue=module.is.userValue(stringValue);if(settings.onLabelRemove.call($label,value)===false){module.debug('Label remove callback cancelled removal');return;}module.remove.message();if(isUserValue){module.remove.value(stringValue);module.remove.label(stringValue);}else{// selected will also remove label
	module.remove.selected(stringValue);}});},tabbable:function tabbable(){if(module.has.search()){module.debug('Searchable dropdown initialized');$search.removeAttr('tabindex');$menu.removeAttr('tabindex');}else{module.debug('Simple selection dropdown initialized');$module.removeAttr('tabindex');$menu.removeAttr('tabindex');}}},has:{menuSearch:function menuSearch(){return module.has.search()&&$search.closest($menu).length>0;},search:function search(){return $search.length>0;},sizer:function sizer(){return $sizer.length>0;},selectInput:function selectInput(){return $input.is('select');},minCharacters:function minCharacters(searchTerm){if(settings.minCharacters){searchTerm=searchTerm!==undefined?String(searchTerm):String(module.get.query());return searchTerm.length>=settings.minCharacters;}return true;},firstLetter:function firstLetter($item,letter){var text,firstLetter;if(!$item||$item.length===0||typeof letter!=='string'){return false;}text=module.get.choiceText($item,false);letter=letter.toLowerCase();firstLetter=String(text).charAt(0).toLowerCase();return letter==firstLetter;},input:function input(){return $input.length>0;},items:function items(){return $item.length>0;},menu:function menu(){return $menu.length>0;},message:function message(){return $menu.children(selector.message).length!==0;},label:function label(value){var escapedValue=module.escape.value(value),$labels=$module.find(selector.label);return $labels.filter('[data-value="'+escapedValue+'"]').length>0;},maxSelections:function maxSelections(){return settings.maxSelections&&module.get.selectionCount()>=settings.maxSelections;},allResultsFiltered:function allResultsFiltered(){var $normalResults=$item.not(selector.addition);return $normalResults.filter(selector.unselectable).length===$normalResults.length;},userSuggestion:function userSuggestion(){return $menu.children(selector.addition).length>0;},query:function query(){return module.get.query()!=='';},value:function value(_value2){var values=module.get.values(),hasValue=$.isArray(values)?values&&$.inArray(_value2,values)!==-1:values==_value2;return hasValue?true:false;}},is:{active:function active(){return $module.hasClass(className.active);},bubbledLabelClick:function bubbledLabelClick(event){return $(event.target).is('select, input')&&$module.closest('label').length>0;},bubbledIconClick:function bubbledIconClick(event){return $(event.target).closest($icon).length>0;},alreadySetup:function alreadySetup(){return $module.is('select')&&$module.parent(selector.dropdown).length>0&&$module.prev().length===0;},animating:function animating($subMenu){return $subMenu?$subMenu.transition&&$subMenu.transition('is animating'):$menu.transition&&$menu.transition('is animating');},disabled:function disabled(){return $module.hasClass(className.disabled);},focused:function focused(){return document.activeElement===$module[0];},focusedOnSearch:function focusedOnSearch(){return document.activeElement===$search[0];},allFiltered:function allFiltered(){return(module.is.multiple()||module.has.search())&&!(settings.hideAdditions==false&&module.has.userSuggestion())&&!module.has.message()&&module.has.allResultsFiltered();},hidden:function hidden($subMenu){return!module.is.visible($subMenu);},initialLoad:function initialLoad(){return _initialLoad;},onScreen:function onScreen($subMenu){var $currentMenu=$subMenu||$menu,canOpenDownward=true,onScreen={},calculations;$currentMenu.addClass(className.loading);calculations={context:{scrollTop:$context.scrollTop(),height:$context.outerHeight()},menu:{offset:$currentMenu.offset(),height:$currentMenu.outerHeight()}};onScreen={above:calculations.context.scrollTop<=calculations.menu.offset.top-calculations.menu.height,below:calculations.context.scrollTop+calculations.context.height>=calculations.menu.offset.top+calculations.menu.height};if(onScreen.below){module.verbose('Dropdown can fit in context downward',onScreen);canOpenDownward=true;}else if(!onScreen.below&&!onScreen.above){module.verbose('Dropdown cannot fit in either direction, favoring downward',onScreen);canOpenDownward=true;}else{module.verbose('Dropdown cannot fit below, opening upward',onScreen);canOpenDownward=false;}$currentMenu.removeClass(className.loading);return canOpenDownward;},inObject:function inObject(needle,object){var found=false;$.each(object,function(index,property){if(property==needle){found=true;return true;}});return found;},multiple:function multiple(){return $module.hasClass(className.multiple);},single:function single(){return!module.is.multiple();},selectMutation:function selectMutation(mutations){var selectChanged=false;$.each(mutations,function(index,mutation){if(mutation.target&&$(mutation.target).is('select')){selectChanged=true;return true;}});return selectChanged;},search:function search(){return $module.hasClass(className.search);},searchSelection:function searchSelection(){return module.has.search()&&$search.parent(selector.dropdown).length===1;},selection:function selection(){return $module.hasClass(className.selection);},userValue:function userValue(value){return $.inArray(value,module.get.userValues())!==-1;},upward:function upward($menu){var $element=$menu||$module;return $element.hasClass(className.upward);},visible:function visible($subMenu){return $subMenu?$subMenu.hasClass(className.visible):$menu.hasClass(className.visible);}},can:{activate:function activate($item){if(settings.useLabels){return true;}if(!module.has.maxSelections()){return true;}if(module.has.maxSelections()&&$item.hasClass(className.active)){return true;}return false;},click:function click(){return hasTouch||settings.on=='click';},extendSelect:function extendSelect(){return settings.allowAdditions||settings.apiSettings;},show:function show(){return!module.is.disabled()&&(module.has.items()||module.has.message());},useAPI:function useAPI(){return $.fn.api!==undefined;}},animate:{show:function show(callback,$subMenu){var $currentMenu=$subMenu||$menu,start=$subMenu?function(){}:function(){module.hideSubMenus();module.hideOthers();module.set.active();},transition;callback=$.isFunction(callback)?callback:function(){};module.verbose('Doing menu show animation',$currentMenu);module.set.direction($subMenu);transition=module.get.transition($subMenu);if(module.is.selection()){module.set.scrollPosition(module.get.selectedItem(),true);}if(module.is.hidden($currentMenu)||module.is.animating($currentMenu)){if(transition=='none'){start();$currentMenu.transition('show');callback.call(element);}else if($.fn.transition!==undefined&&$module.transition('is supported')){$currentMenu.transition({animation:transition+' in',debug:settings.debug,verbose:settings.verbose,duration:settings.duration,queue:true,onStart:start,onComplete:function onComplete(){callback.call(element);}});}else{module.error(error.noTransition,transition);}}},hide:function hide(callback,$subMenu){var $currentMenu=$subMenu||$menu,duration=$subMenu?settings.duration*0.9:settings.duration,start=$subMenu?function(){}:function(){if(module.can.click()){module.unbind.intent();}module.remove.active();},transition=module.get.transition($subMenu);callback=$.isFunction(callback)?callback:function(){};if(module.is.visible($currentMenu)||module.is.animating($currentMenu)){module.verbose('Doing menu hide animation',$currentMenu);if(transition=='none'){start();$currentMenu.transition('hide');callback.call(element);}else if($.fn.transition!==undefined&&$module.transition('is supported')){$currentMenu.transition({animation:transition+' out',duration:settings.duration,debug:settings.debug,verbose:settings.verbose,queue:true,onStart:start,onComplete:function onComplete(){if(settings.direction=='auto'){module.remove.upward($subMenu);}callback.call(element);}});}else{module.error(error.transition);}}}},hideAndClear:function hideAndClear(){module.remove.searchTerm();if(module.has.maxSelections()){return;}if(module.has.search()){module.hide(function(){module.remove.filteredItem();});}else{module.hide();}},delay:{show:function show(){module.verbose('Delaying show event to ensure user intent');clearTimeout(module.timer);module.timer=setTimeout(module.show,settings.delay.show);},hide:function hide(){module.verbose('Delaying hide event to ensure user intent');clearTimeout(module.timer);module.timer=setTimeout(module.hide,settings.delay.hide);}},escape:{value:function value(_value3){var multipleValues=$.isArray(_value3),stringValue=typeof _value3==='string',isUnparsable=!stringValue&&!multipleValues,hasQuotes=stringValue&&_value3.search(_regExp.quote)!==-1,values=[];if(!module.has.selectInput()||isUnparsable||!hasQuotes){return _value3;}module.debug('Encoding quote values for use in select',_value3);if(multipleValues){$.each(_value3,function(index,value){values.push(value.replace(_regExp.quote,'&quot;'));});return values;}return _value3.replace(_regExp.quote,'&quot;');},regExp:function regExp(text){text=String(text);return text.replace(_regExp.escape,'\\$&');}},setting:function setting(name,value){module.debug('Changing setting',name,value);if($.isPlainObject(name)){$.extend(true,settings,name);}else if(value!==undefined){if($.isPlainObject(settings[name])){$.extend(true,settings[name],value);}else{settings[name]=value;}}else{return settings[name];}},internal:function internal(name,value){if($.isPlainObject(name)){$.extend(true,module,name);}else if(value!==undefined){module[name]=value;}else{return module[name];}},debug:function debug(){if(!settings.silent&&settings.debug){if(settings.performance){module.performance.log(arguments);}else{module.debug=Function.prototype.bind.call(console.info,console,settings.name+':');module.debug.apply(console,arguments);}}},verbose:function verbose(){if(!settings.silent&&settings.verbose&&settings.debug){if(settings.performance){module.performance.log(arguments);}else{module.verbose=Function.prototype.bind.call(console.info,console,settings.name+':');module.verbose.apply(console,arguments);}}},error:function error(){if(!settings.silent){module.error=Function.prototype.bind.call(console.error,console,settings.name+':');module.error.apply(console,arguments);}},performance:{log:function log(message){var currentTime,executionTime,previousTime;if(settings.performance){currentTime=new Date().getTime();previousTime=time||currentTime;executionTime=currentTime-previousTime;time=currentTime;performance.push({'Name':message[0],'Arguments':[].slice.call(message,1)||'','Element':element,'Execution Time':executionTime});}clearTimeout(module.performance.timer);module.performance.timer=setTimeout(module.performance.display,500);},display:function display(){var title=settings.name+':',totalTime=0;time=false;clearTimeout(module.performance.timer);$.each(performance,function(index,data){totalTime+=data['Execution Time'];});title+=' '+totalTime+'ms';if(moduleSelector){title+=' \''+moduleSelector+'\'';}if((console.group!==undefined||console.table!==undefined)&&performance.length>0){console.groupCollapsed(title);if(console.table){console.table(performance);}else{$.each(performance,function(index,data){console.log(data['Name']+': '+data['Execution Time']+'ms');});}console.groupEnd();}performance=[];}},invoke:function invoke(query,passedArguments,context){var object=instance,maxDepth,found,response;passedArguments=passedArguments||queryArguments;context=element||context;if(typeof query=='string'&&object!==undefined){query=query.split(/[\. ]/);maxDepth=query.length-1;$.each(query,function(depth,value){var camelCaseValue=depth!=maxDepth?value+query[depth+1].charAt(0).toUpperCase()+query[depth+1].slice(1):query;if($.isPlainObject(object[camelCaseValue])&&depth!=maxDepth){object=object[camelCaseValue];}else if(object[camelCaseValue]!==undefined){found=object[camelCaseValue];return false;}else if($.isPlainObject(object[value])&&depth!=maxDepth){object=object[value];}else if(object[value]!==undefined){found=object[value];return false;}else{module.error(error.method,query);return false;}});}if($.isFunction(found)){response=found.apply(context,passedArguments);}else if(found!==undefined){response=found;}if($.isArray(returnedValue)){returnedValue.push(response);}else if(returnedValue!==undefined){returnedValue=[returnedValue,response];}else if(response!==undefined){returnedValue=response;}return found;}};if(methodInvoked){if(instance===undefined){module.initialize();}module.invoke(query);}else{if(instance!==undefined){instance.invoke('destroy');}module.initialize();}});return returnedValue!==undefined?returnedValue:$allModules;};$.fn.dropdown.settings={silent:false,debug:false,verbose:false,performance:true,on:'click',// what event should show menu action on item selection
	action:'activate',// action on item selection (nothing, activate, select, combo, hide, function(){})
	apiSettings:false,selectOnKeydown:true,// Whether selection should occur automatically when keyboard shortcuts used
	minCharacters:0,// Minimum characters required to trigger API call
	saveRemoteData:true,// Whether remote name/value pairs should be stored in sessionStorage to allow remote data to be restored on page refresh
	throttle:200,// How long to wait after last user input to search remotely
	context:window,// Context to use when determining if on screen
	direction:'auto',// Whether dropdown should always open in one direction
	keepOnScreen:true,// Whether dropdown should check whether it is on screen before showing
	match:'both',// what to match against with search selection (both, text, or label)
	fullTextSearch:false,// search anywhere in value (set to 'exact' to require exact matches)
	placeholder:'auto',// whether to convert blank <select> values to placeholder text
	preserveHTML:true,// preserve html when selecting value
	sortSelect:false,// sort selection on init
	forceSelection:true,// force a choice on blur with search selection
	allowAdditions:false,// whether multiple select should allow user added values
	hideAdditions:true,// whether or not to hide special message prompting a user they can enter a value
	maxSelections:false,// When set to a number limits the number of selections to this count
	useLabels:true,// whether multiple select should filter currently active selections from choices
	delimiter:',',// when multiselect uses normal <input> the values will be delimited with this character
	showOnFocus:true,// show menu on focus
	allowReselection:false,// whether current value should trigger callbacks when reselected
	allowTab:true,// add tabindex to element
	allowCategorySelection:false,// allow elements with sub-menus to be selected
	fireOnInit:false,// Whether callbacks should fire when initializing dropdown values
	transition:'auto',// auto transition will slide down or up based on direction
	duration:200,// duration of transition
	glyphWidth:1.037,// widest glyph width in em (W is 1.037 em) used to calculate multiselect input width
	// label settings on multi-select
	label:{transition:'scale',duration:200,variation:false},// delay before event
	delay:{hide:300,show:200,search:20,touch:50},/* Callbacks */onChange:function onChange(value,text,$selected){},onAdd:function onAdd(value,text,$selected){},onRemove:function onRemove(value,text,$selected){},onLabelSelect:function onLabelSelect($selectedLabels){},onLabelCreate:function onLabelCreate(value,text){return $(this);},onLabelRemove:function onLabelRemove(value){return true;},onNoResults:function onNoResults(searchTerm){return true;},onShow:function onShow(){},onHide:function onHide(){},/* Component */name:'Dropdown',namespace:'dropdown',message:{addResult:'Add <b>{term}</b>',count:'{count} selected',maxSelections:'Max {maxCount} selections',noResults:'No results found.',serverError:'There was an error contacting the server'},error:{action:'You called a dropdown action that was not defined',alreadySetup:'Once a select has been initialized behaviors must be called on the created ui dropdown',labels:'Allowing user additions currently requires the use of labels.',missingMultiple:'<select> requires multiple property to be set to correctly preserve multiple values',method:'The method you called is not defined.',noAPI:'The API module is required to load resources remotely',noStorage:'Saving remote data requires session storage',noTransition:'This module requires ui transitions <https://github.com/Semantic-Org/UI-Transition>'},regExp:{escape:/[-[\]{}()*+?.,\\^$|#\s]/g,quote:/"/g},metadata:{defaultText:'defaultText',defaultValue:'defaultValue',placeholderText:'placeholder',text:'text',value:'value'},// property names for remote query
	fields:{remoteValues:'results',// grouping for api results
	values:'values',// grouping for all dropdown values
	disabled:'disabled',// whether value should be disabled
	name:'name',// displayed dropdown text
	value:'value',// actual dropdown value
	text:'text'// displayed text when selected
	},keys:{backspace:8,delimiter:188,// comma
	deleteKey:46,enter:13,escape:27,pageUp:33,pageDown:34,leftArrow:37,upArrow:38,rightArrow:39,downArrow:40},selector:{addition:'.addition',dropdown:'.ui.dropdown',hidden:'.hidden',icon:'> .dropdown.icon',input:'> input[type="hidden"], > select',item:'.item',label:'> .label',remove:'> .label > .delete.icon',siblingLabel:'.label',menu:'.menu',message:'.message',menuIcon:'.dropdown.icon',search:'input.search, .menu > .search > input, .menu input.search',sizer:'> input.sizer',text:'> .text:not(.icon)',unselectable:'.disabled, .filtered'},className:{active:'active',addition:'addition',animating:'animating',disabled:'disabled',empty:'empty',dropdown:'ui dropdown',filtered:'filtered',hidden:'hidden transition',item:'item',label:'ui label',loading:'loading',menu:'menu',message:'message',multiple:'multiple',placeholder:'default',sizer:'sizer',search:'search',selected:'selected',selection:'selection',upward:'upward',visible:'visible'}};/* Templates */$.fn.dropdown.settings.templates={// generates dropdown from select values
	dropdown:function dropdown(select){var placeholder=select.placeholder||false,values=select.values||{},html='';html+='<i class="dropdown icon"></i>';if(select.placeholder){html+='<div class="default text">'+placeholder+'</div>';}else{html+='<div class="text"></div>';}html+='<div class="menu">';$.each(select.values,function(index,option){html+=option.disabled?'<div class="disabled item" data-value="'+option.value+'">'+option.name+'</div>':'<div class="item" data-value="'+option.value+'">'+option.name+'</div>';});html+='</div>';return html;},// generates just menu from select
	menu:function menu(response,fields){var values=response[fields.values]||{},html='';$.each(values,function(index,option){var maybeText=option[fields.text]?'data-text="'+option[fields.text]+'"':'',maybeDisabled=option[fields.disabled]?'disabled ':'';html+='<div class="'+maybeDisabled+'item" data-value="'+option[fields.value]+'"'+maybeText+'>';html+=option[fields.name];html+='</div>';});return html;},// generates label for multiselect
	label:function label(value,text){return text+'<i class="delete icon"></i>';},// generates messages like "No results"
	message:function message(_message2){return _message2;},// generates user addition to selection menu
	addition:function addition(choice){return choice;}};})(jQuery,window,document);
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(jQuery) {'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	/*!
	 * # Semantic UI - Popup
	 * http://github.com/semantic-org/semantic-ui/
	 *
	 *
	 * Released under the MIT license
	 * http://opensource.org/licenses/MIT
	 *
	 */

	;(function ($, window, document, undefined) {

	  "use strict";

	  window = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();

	  $.fn.popup = function (parameters) {
	    var $allModules = $(this),
	        $document = $(document),
	        $window = $(window),
	        $body = $('body'),
	        moduleSelector = $allModules.selector || '',
	        hasTouch = true,
	        time = new Date().getTime(),
	        performance = [],
	        query = arguments[0],
	        methodInvoked = typeof query == 'string',
	        queryArguments = [].slice.call(arguments, 1),
	        returnedValue;
	    $allModules.each(function () {
	      var settings = $.isPlainObject(parameters) ? $.extend(true, {}, $.fn.popup.settings, parameters) : $.extend({}, $.fn.popup.settings),
	          selector = settings.selector,
	          className = settings.className,
	          error = settings.error,
	          metadata = settings.metadata,
	          namespace = settings.namespace,
	          eventNamespace = '.' + settings.namespace,
	          moduleNamespace = 'module-' + namespace,
	          $module = $(this),
	          $context = $(settings.context),
	          $scrollContext = $(settings.scrollContext),
	          $boundary = $(settings.boundary),
	          $target = settings.target ? $(settings.target) : $module,
	          $popup,
	          $offsetParent,
	          searchDepth = 0,
	          triedPositions = false,
	          openedWithTouch = false,
	          element = this,
	          instance = $module.data(moduleNamespace),
	          documentObserver,
	          elementNamespace,
	          _id,
	          module;

	      module = {

	        // binds events
	        initialize: function initialize() {
	          module.debug('Initializing', $module);
	          module.createID();
	          module.bind.events();
	          if (!module.exists() && settings.preserve) {
	            module.create();
	          }
	          if (settings.observeChanges) {
	            module.observeChanges();
	          }
	          module.instantiate();
	        },

	        instantiate: function instantiate() {
	          module.verbose('Storing instance', module);
	          instance = module;
	          $module.data(moduleNamespace, instance);
	        },

	        observeChanges: function observeChanges() {
	          if ('MutationObserver' in window) {
	            documentObserver = new MutationObserver(module.event.documentChanged);
	            documentObserver.observe(document, {
	              childList: true,
	              subtree: true
	            });
	            module.debug('Setting up mutation observer', documentObserver);
	          }
	        },

	        refresh: function refresh() {
	          if (settings.popup) {
	            $popup = $(settings.popup).eq(0);
	          } else {
	            if (settings.inline) {
	              $popup = $target.nextAll(selector.popup).eq(0);
	              settings.popup = $popup;
	            }
	          }
	          if (settings.popup) {
	            $popup.addClass(className.loading);
	            $offsetParent = module.get.offsetParent();
	            $popup.removeClass(className.loading);
	            if (settings.movePopup && module.has.popup() && module.get.offsetParent($popup)[0] !== $offsetParent[0]) {
	              module.debug('Moving popup to the same offset parent as activating element');
	              $popup.detach().appendTo($offsetParent);
	            }
	          } else {
	            $offsetParent = settings.inline ? module.get.offsetParent($target) : module.has.popup() ? module.get.offsetParent($popup) : $body;
	          }
	          if ($offsetParent.is('html') && $offsetParent[0] !== $body[0]) {
	            module.debug('Setting page as offset parent');
	            $offsetParent = $body;
	          }
	          if (module.get.variation()) {
	            module.set.variation();
	          }
	        },

	        reposition: function reposition() {
	          module.refresh();
	          module.set.position();
	        },

	        destroy: function destroy() {
	          module.debug('Destroying previous module');
	          if (documentObserver) {
	            documentObserver.disconnect();
	          }
	          // remove element only if was created dynamically
	          if ($popup && !settings.preserve) {
	            module.removePopup();
	          }
	          // clear all timeouts
	          clearTimeout(module.hideTimer);
	          clearTimeout(module.showTimer);
	          // remove events
	          module.unbind.close();
	          module.unbind.events();
	          $module.removeData(moduleNamespace);
	        },

	        event: {
	          start: function start(event) {
	            var delay = $.isPlainObject(settings.delay) ? settings.delay.show : settings.delay;
	            clearTimeout(module.hideTimer);
	            if (!openedWithTouch) {
	              module.showTimer = setTimeout(module.show, delay);
	            }
	          },
	          end: function end() {
	            var delay = $.isPlainObject(settings.delay) ? settings.delay.hide : settings.delay;
	            clearTimeout(module.showTimer);
	            module.hideTimer = setTimeout(module.hide, delay);
	          },
	          touchstart: function touchstart(event) {
	            openedWithTouch = true;
	            module.show();
	          },
	          resize: function resize() {
	            if (module.is.visible()) {
	              module.set.position();
	            }
	          },
	          documentChanged: function documentChanged(mutations) {
	            [].forEach.call(mutations, function (mutation) {
	              if (mutation.removedNodes) {
	                [].forEach.call(mutation.removedNodes, function (node) {
	                  if (node == element || $(node).find(element).length > 0) {
	                    module.debug('Element removed from DOM, tearing down events');
	                    module.destroy();
	                  }
	                });
	              }
	            });
	          },
	          hideGracefully: function hideGracefully(event) {
	            var $target = $(event.target),
	                isInDOM = $.contains(document.documentElement, event.target),
	                inPopup = $target.closest(selector.popup).length > 0;
	            // don't close on clicks inside popup
	            if (event && !inPopup && isInDOM) {
	              module.debug('Click occurred outside popup hiding popup');
	              module.hide();
	            } else {
	              module.debug('Click was inside popup, keeping popup open');
	            }
	          }
	        },

	        // generates popup html from metadata
	        create: function create() {
	          var html = module.get.html(),
	              title = module.get.title(),
	              content = module.get.content();

	          if (html || content || title) {
	            module.debug('Creating pop-up html');
	            if (!html) {
	              html = settings.templates.popup({
	                title: title,
	                content: content
	              });
	            }
	            $popup = $('<div/>').addClass(className.popup).data(metadata.activator, $module).html(html);
	            if (settings.inline) {
	              module.verbose('Inserting popup element inline', $popup);
	              $popup.insertAfter($module);
	            } else {
	              module.verbose('Appending popup element to body', $popup);
	              $popup.appendTo($context);
	            }
	            module.refresh();
	            module.set.variation();

	            if (settings.hoverable) {
	              module.bind.popup();
	            }
	            settings.onCreate.call($popup, element);
	          } else if ($target.next(selector.popup).length !== 0) {
	            module.verbose('Pre-existing popup found');
	            settings.inline = true;
	            settings.popup = $target.next(selector.popup).data(metadata.activator, $module);
	            module.refresh();
	            if (settings.hoverable) {
	              module.bind.popup();
	            }
	          } else if (settings.popup) {
	            $(settings.popup).data(metadata.activator, $module);
	            module.verbose('Used popup specified in settings');
	            module.refresh();
	            if (settings.hoverable) {
	              module.bind.popup();
	            }
	          } else {
	            module.debug('No content specified skipping display', element);
	          }
	        },

	        createID: function createID() {
	          _id = (Math.random().toString(16) + '000000000').substr(2, 8);
	          elementNamespace = '.' + _id;
	          module.verbose('Creating unique id for element', _id);
	        },

	        // determines popup state
	        toggle: function toggle() {
	          module.debug('Toggling pop-up');
	          if (module.is.hidden()) {
	            module.debug('Popup is hidden, showing pop-up');
	            module.unbind.close();
	            module.show();
	          } else {
	            module.debug('Popup is visible, hiding pop-up');
	            module.hide();
	          }
	        },

	        show: function show(callback) {
	          callback = callback || function () {};
	          module.debug('Showing pop-up', settings.transition);
	          if (module.is.hidden() && !(module.is.active() && module.is.dropdown())) {
	            if (!module.exists()) {
	              module.create();
	            }
	            if (settings.onShow.call($popup, element) === false) {
	              module.debug('onShow callback returned false, cancelling popup animation');
	              return;
	            } else if (!settings.preserve && !settings.popup) {
	              module.refresh();
	            }
	            if ($popup && module.set.position()) {
	              module.save.conditions();
	              if (settings.exclusive) {
	                module.hideAll();
	              }
	              module.animate.show(callback);
	            }
	          }
	        },

	        hide: function hide(callback) {
	          callback = callback || function () {};
	          if (module.is.visible() || module.is.animating()) {
	            if (settings.onHide.call($popup, element) === false) {
	              module.debug('onHide callback returned false, cancelling popup animation');
	              return;
	            }
	            module.remove.visible();
	            module.unbind.close();
	            module.restore.conditions();
	            module.animate.hide(callback);
	          }
	        },

	        hideAll: function hideAll() {
	          $(selector.popup).filter('.' + className.visible).each(function () {
	            $(this).data(metadata.activator).popup('hide');
	          });
	        },
	        exists: function exists() {
	          if (!$popup) {
	            return false;
	          }
	          if (settings.inline || settings.popup) {
	            return module.has.popup();
	          } else {
	            return $popup.closest($context).length >= 1 ? true : false;
	          }
	        },

	        removePopup: function removePopup() {
	          if (module.has.popup() && !settings.popup) {
	            module.debug('Removing popup', $popup);
	            $popup.remove();
	            $popup = undefined;
	            settings.onRemove.call($popup, element);
	          }
	        },

	        save: {
	          conditions: function conditions() {
	            module.cache = {
	              title: $module.attr('title')
	            };
	            if (module.cache.title) {
	              $module.removeAttr('title');
	            }
	            module.verbose('Saving original attributes', module.cache.title);
	          }
	        },
	        restore: {
	          conditions: function conditions() {
	            if (module.cache && module.cache.title) {
	              $module.attr('title', module.cache.title);
	              module.verbose('Restoring original attributes', module.cache.title);
	            }
	            return true;
	          }
	        },
	        supports: {
	          svg: function svg() {
	            return (typeof SVGGraphicsElement === 'undefined' ? 'undefined' : _typeof(SVGGraphicsElement)) === undefined;
	          }
	        },
	        animate: {
	          show: function show(callback) {
	            callback = $.isFunction(callback) ? callback : function () {};
	            if (settings.transition && $.fn.transition !== undefined && $module.transition('is supported')) {
	              module.set.visible();
	              $popup.transition({
	                animation: settings.transition + ' in',
	                queue: false,
	                debug: settings.debug,
	                verbose: settings.verbose,
	                duration: settings.duration,
	                onComplete: function onComplete() {
	                  module.bind.close();
	                  callback.call($popup, element);
	                  settings.onVisible.call($popup, element);
	                }
	              });
	            } else {
	              module.error(error.noTransition);
	            }
	          },
	          hide: function hide(callback) {
	            callback = $.isFunction(callback) ? callback : function () {};
	            module.debug('Hiding pop-up');
	            if (settings.onHide.call($popup, element) === false) {
	              module.debug('onHide callback returned false, cancelling popup animation');
	              return;
	            }
	            if (settings.transition && $.fn.transition !== undefined && $module.transition('is supported')) {
	              $popup.transition({
	                animation: settings.transition + ' out',
	                queue: false,
	                duration: settings.duration,
	                debug: settings.debug,
	                verbose: settings.verbose,
	                onComplete: function onComplete() {
	                  module.reset();
	                  callback.call($popup, element);
	                  settings.onHidden.call($popup, element);
	                }
	              });
	            } else {
	              module.error(error.noTransition);
	            }
	          }
	        },

	        change: {
	          content: function content(html) {
	            $popup.html(html);
	          }
	        },

	        get: {
	          html: function html() {
	            $module.removeData(metadata.html);
	            return $module.data(metadata.html) || settings.html;
	          },
	          title: function title() {
	            $module.removeData(metadata.title);
	            return $module.data(metadata.title) || settings.title;
	          },
	          content: function content() {
	            $module.removeData(metadata.content);
	            return $module.data(metadata.content) || $module.attr('title') || settings.content;
	          },
	          variation: function variation() {
	            $module.removeData(metadata.variation);
	            return $module.data(metadata.variation) || settings.variation;
	          },
	          popup: function popup() {
	            return $popup;
	          },
	          popupOffset: function popupOffset() {
	            return $popup.offset();
	          },
	          calculations: function calculations() {
	            var targetElement = $target[0],
	                isWindow = $boundary[0] == window,
	                targetPosition = settings.inline || settings.popup && settings.movePopup ? $target.position() : $target.offset(),
	                screenPosition = isWindow ? { top: 0, left: 0 } : $boundary.offset(),
	                calculations = {},
	                scroll = isWindow ? { top: $window.scrollTop(), left: $window.scrollLeft() } : { top: 0, left: 0 },
	                screen;
	            calculations = {
	              // element which is launching popup
	              target: {
	                element: $target[0],
	                width: $target.outerWidth(),
	                height: $target.outerHeight(),
	                top: targetPosition.top,
	                left: targetPosition.left,
	                margin: {}
	              },
	              // popup itself
	              popup: {
	                width: $popup.outerWidth(),
	                height: $popup.outerHeight()
	              },
	              // offset container (or 3d context)
	              parent: {
	                width: $offsetParent.outerWidth(),
	                height: $offsetParent.outerHeight()
	              },
	              // screen boundaries
	              screen: {
	                top: screenPosition.top,
	                left: screenPosition.left,
	                scroll: {
	                  top: scroll.top,
	                  left: scroll.left
	                },
	                width: $boundary.width(),
	                height: $boundary.height()
	              }
	            };

	            // add in container calcs if fluid
	            if (settings.setFluidWidth && module.is.fluid()) {
	              calculations.container = {
	                width: $popup.parent().outerWidth()
	              };
	              calculations.popup.width = calculations.container.width;
	            }

	            // add in margins if inline
	            calculations.target.margin.top = settings.inline ? parseInt(window.getComputedStyle(targetElement).getPropertyValue('margin-top'), 10) : 0;
	            calculations.target.margin.left = settings.inline ? module.is.rtl() ? parseInt(window.getComputedStyle(targetElement).getPropertyValue('margin-right'), 10) : parseInt(window.getComputedStyle(targetElement).getPropertyValue('margin-left'), 10) : 0;
	            // calculate screen boundaries
	            screen = calculations.screen;
	            calculations.boundary = {
	              top: screen.top + screen.scroll.top,
	              bottom: screen.top + screen.scroll.top + screen.height,
	              left: screen.left + screen.scroll.left,
	              right: screen.left + screen.scroll.left + screen.width
	            };
	            return calculations;
	          },
	          id: function id() {
	            return _id;
	          },
	          startEvent: function startEvent() {
	            if (settings.on == 'hover') {
	              return 'mouseenter';
	            } else if (settings.on == 'focus') {
	              return 'focus';
	            }
	            return false;
	          },
	          scrollEvent: function scrollEvent() {
	            return 'scroll';
	          },
	          endEvent: function endEvent() {
	            if (settings.on == 'hover') {
	              return 'mouseleave';
	            } else if (settings.on == 'focus') {
	              return 'blur';
	            }
	            return false;
	          },
	          distanceFromBoundary: function distanceFromBoundary(offset, calculations) {
	            var distanceFromBoundary = {},
	                popup,
	                boundary;
	            calculations = calculations || module.get.calculations();

	            // shorthand
	            popup = calculations.popup;
	            boundary = calculations.boundary;

	            if (offset) {
	              distanceFromBoundary = {
	                top: offset.top - boundary.top,
	                left: offset.left - boundary.left,
	                right: boundary.right - (offset.left + popup.width),
	                bottom: boundary.bottom - (offset.top + popup.height)
	              };
	              module.verbose('Distance from boundaries determined', offset, distanceFromBoundary);
	            }
	            return distanceFromBoundary;
	          },
	          offsetParent: function offsetParent($target) {
	            var element = $target !== undefined ? $target[0] : $module[0],
	                parentNode = element.parentNode,
	                $node = $(parentNode);
	            if (parentNode) {
	              var is2D = $node.css('transform') === 'none',
	                  isStatic = $node.css('position') === 'static',
	                  isHTML = $node.is('html');
	              while (parentNode && !isHTML && isStatic && is2D) {
	                parentNode = parentNode.parentNode;
	                $node = $(parentNode);
	                is2D = $node.css('transform') === 'none';
	                isStatic = $node.css('position') === 'static';
	                isHTML = $node.is('html');
	              }
	            }
	            return $node && $node.length > 0 ? $node : $();
	          },
	          positions: function positions() {
	            return {
	              'top left': false,
	              'top center': false,
	              'top right': false,
	              'bottom left': false,
	              'bottom center': false,
	              'bottom right': false,
	              'left center': false,
	              'right center': false
	            };
	          },
	          nextPosition: function nextPosition(position) {
	            var positions = position.split(' '),
	                verticalPosition = positions[0],
	                horizontalPosition = positions[1],
	                opposite = {
	              top: 'bottom',
	              bottom: 'top',
	              left: 'right',
	              right: 'left'
	            },
	                adjacent = {
	              left: 'center',
	              center: 'right',
	              right: 'left'
	            },
	                backup = {
	              'top left': 'top center',
	              'top center': 'top right',
	              'top right': 'right center',
	              'right center': 'bottom right',
	              'bottom right': 'bottom center',
	              'bottom center': 'bottom left',
	              'bottom left': 'left center',
	              'left center': 'top left'
	            },
	                adjacentsAvailable = verticalPosition == 'top' || verticalPosition == 'bottom',
	                oppositeTried = false,
	                adjacentTried = false,
	                nextPosition = false;
	            if (!triedPositions) {
	              module.verbose('All available positions available');
	              triedPositions = module.get.positions();
	            }

	            module.debug('Recording last position tried', position);
	            triedPositions[position] = true;

	            if (settings.prefer === 'opposite') {
	              nextPosition = [opposite[verticalPosition], horizontalPosition];
	              nextPosition = nextPosition.join(' ');
	              oppositeTried = triedPositions[nextPosition] === true;
	              module.debug('Trying opposite strategy', nextPosition);
	            }
	            if (settings.prefer === 'adjacent' && adjacentsAvailable) {
	              nextPosition = [verticalPosition, adjacent[horizontalPosition]];
	              nextPosition = nextPosition.join(' ');
	              adjacentTried = triedPositions[nextPosition] === true;
	              module.debug('Trying adjacent strategy', nextPosition);
	            }
	            if (adjacentTried || oppositeTried) {
	              module.debug('Using backup position', nextPosition);
	              nextPosition = backup[position];
	            }
	            return nextPosition;
	          }
	        },

	        set: {
	          position: function position(_position, calculations) {

	            // exit conditions
	            if ($target.length === 0 || $popup.length === 0) {
	              module.error(error.notFound);
	              return;
	            }
	            var offset, distanceAway, target, popup, parent, positioning, popupOffset, distanceFromBoundary;

	            calculations = calculations || module.get.calculations();
	            _position = _position || $module.data(metadata.position) || settings.position;

	            offset = $module.data(metadata.offset) || settings.offset;
	            distanceAway = settings.distanceAway;

	            // shorthand
	            target = calculations.target;
	            popup = calculations.popup;
	            parent = calculations.parent;

	            if (target.width === 0 && target.height === 0 && !module.is.svg(target.element)) {
	              module.debug('Popup target is hidden, no action taken');
	              return false;
	            }

	            if (settings.inline) {
	              module.debug('Adding margin to calculation', target.margin);
	              if (_position == 'left center' || _position == 'right center') {
	                offset += target.margin.top;
	                distanceAway += -target.margin.left;
	              } else if (_position == 'top left' || _position == 'top center' || _position == 'top right') {
	                offset += target.margin.left;
	                distanceAway -= target.margin.top;
	              } else {
	                offset += target.margin.left;
	                distanceAway += target.margin.top;
	              }
	            }

	            module.debug('Determining popup position from calculations', _position, calculations);

	            if (module.is.rtl()) {
	              _position = _position.replace(/left|right/g, function (match) {
	                return match == 'left' ? 'right' : 'left';
	              });
	              module.debug('RTL: Popup position updated', _position);
	            }

	            // if last attempt use specified last resort position
	            if (searchDepth == settings.maxSearchDepth && typeof settings.lastResort === 'string') {
	              _position = settings.lastResort;
	            }

	            switch (_position) {
	              case 'top left':
	                positioning = {
	                  top: 'auto',
	                  bottom: parent.height - target.top + distanceAway,
	                  left: target.left + offset,
	                  right: 'auto'
	                };
	                break;
	              case 'top center':
	                positioning = {
	                  bottom: parent.height - target.top + distanceAway,
	                  left: target.left + target.width / 2 - popup.width / 2 + offset,
	                  top: 'auto',
	                  right: 'auto'
	                };
	                break;
	              case 'top right':
	                positioning = {
	                  bottom: parent.height - target.top + distanceAway,
	                  right: parent.width - target.left - target.width - offset,
	                  top: 'auto',
	                  left: 'auto'
	                };
	                break;
	              case 'left center':
	                positioning = {
	                  top: target.top + target.height / 2 - popup.height / 2 + offset,
	                  right: parent.width - target.left + distanceAway,
	                  left: 'auto',
	                  bottom: 'auto'
	                };
	                break;
	              case 'right center':
	                positioning = {
	                  top: target.top + target.height / 2 - popup.height / 2 + offset,
	                  left: target.left + target.width + distanceAway,
	                  bottom: 'auto',
	                  right: 'auto'
	                };
	                break;
	              case 'bottom left':
	                positioning = {
	                  top: target.top + target.height + distanceAway,
	                  left: target.left + offset,
	                  bottom: 'auto',
	                  right: 'auto'
	                };
	                break;
	              case 'bottom center':
	                positioning = {
	                  top: target.top + target.height + distanceAway,
	                  left: target.left + target.width / 2 - popup.width / 2 + offset,
	                  bottom: 'auto',
	                  right: 'auto'
	                };
	                break;
	              case 'bottom right':
	                positioning = {
	                  top: target.top + target.height + distanceAway,
	                  right: parent.width - target.left - target.width - offset,
	                  left: 'auto',
	                  bottom: 'auto'
	                };
	                break;
	            }
	            if (positioning === undefined) {
	              module.error(error.invalidPosition, _position);
	            }

	            module.debug('Calculated popup positioning values', positioning);

	            // tentatively place on stage
	            $popup.css(positioning).removeClass(className.position).addClass(_position).addClass(className.loading);

	            popupOffset = module.get.popupOffset();

	            // see if any boundaries are surpassed with this tentative position
	            distanceFromBoundary = module.get.distanceFromBoundary(popupOffset, calculations);

	            if (module.is.offstage(distanceFromBoundary, _position)) {
	              module.debug('Position is outside viewport', _position);
	              if (searchDepth < settings.maxSearchDepth) {
	                searchDepth++;
	                _position = module.get.nextPosition(_position);
	                module.debug('Trying new position', _position);
	                return $popup ? module.set.position(_position, calculations) : false;
	              } else {
	                if (settings.lastResort) {
	                  module.debug('No position found, showing with last position');
	                } else {
	                  module.debug('Popup could not find a position to display', $popup);
	                  module.error(error.cannotPlace, element);
	                  module.remove.attempts();
	                  module.remove.loading();
	                  module.reset();
	                  settings.onUnplaceable.call($popup, element);
	                  return false;
	                }
	              }
	            }
	            module.debug('Position is on stage', _position);
	            module.remove.attempts();
	            module.remove.loading();
	            if (settings.setFluidWidth && module.is.fluid()) {
	              module.set.fluidWidth(calculations);
	            }
	            return true;
	          },

	          fluidWidth: function fluidWidth(calculations) {
	            calculations = calculations || module.get.calculations();
	            module.debug('Automatically setting element width to parent width', calculations.parent.width);
	            $popup.css('width', calculations.container.width);
	          },

	          variation: function variation(_variation) {
	            _variation = _variation || module.get.variation();
	            if (_variation && module.has.popup()) {
	              module.verbose('Adding variation to popup', _variation);
	              $popup.addClass(_variation);
	            }
	          },

	          visible: function visible() {
	            $module.addClass(className.visible);
	          }
	        },

	        remove: {
	          loading: function loading() {
	            $popup.removeClass(className.loading);
	          },
	          variation: function variation(_variation2) {
	            _variation2 = _variation2 || module.get.variation();
	            if (_variation2) {
	              module.verbose('Removing variation', _variation2);
	              $popup.removeClass(_variation2);
	            }
	          },
	          visible: function visible() {
	            $module.removeClass(className.visible);
	          },
	          attempts: function attempts() {
	            module.verbose('Resetting all searched positions');
	            searchDepth = 0;
	            triedPositions = false;
	          }
	        },

	        bind: {
	          events: function events() {
	            module.debug('Binding popup events to module');
	            if (settings.on == 'click') {
	              $module.on('click' + eventNamespace, module.toggle);
	            }
	            if (settings.on == 'hover' && hasTouch) {
	              $module.on('touchstart' + eventNamespace, module.event.touchstart);
	            }
	            if (module.get.startEvent()) {
	              $module.on(module.get.startEvent() + eventNamespace, module.event.start).on(module.get.endEvent() + eventNamespace, module.event.end);
	            }
	            if (settings.target) {
	              module.debug('Target set to element', $target);
	            }
	            $window.on('resize' + elementNamespace, module.event.resize);
	          },
	          popup: function popup() {
	            module.verbose('Allowing hover events on popup to prevent closing');
	            if ($popup && module.has.popup()) {
	              $popup.on('mouseenter' + eventNamespace, module.event.start).on('mouseleave' + eventNamespace, module.event.end);
	            }
	          },
	          close: function close() {
	            if (settings.hideOnScroll === true || settings.hideOnScroll == 'auto' && settings.on != 'click') {
	              $scrollContext.one(module.get.scrollEvent() + elementNamespace, module.event.hideGracefully);
	            }
	            if (settings.on == 'hover' && openedWithTouch) {
	              module.verbose('Binding popup close event to document');
	              $document.on('touchstart' + elementNamespace, function (event) {
	                module.verbose('Touched away from popup');
	                module.event.hideGracefully.call(element, event);
	              });
	            }
	            if (settings.on == 'click' && settings.closable) {
	              module.verbose('Binding popup close event to document');
	              $document.on('click' + elementNamespace, function (event) {
	                module.verbose('Clicked away from popup');
	                module.event.hideGracefully.call(element, event);
	              });
	            }
	          }
	        },

	        unbind: {
	          events: function events() {
	            $window.off(elementNamespace);
	            $module.off(eventNamespace);
	          },
	          close: function close() {
	            $document.off(elementNamespace);
	            $scrollContext.off(elementNamespace);
	          }
	        },

	        has: {
	          popup: function popup() {
	            return $popup && $popup.length > 0;
	          }
	        },

	        is: {
	          offstage: function offstage(distanceFromBoundary, position) {
	            var offstage = [];
	            // return boundaries that have been surpassed
	            $.each(distanceFromBoundary, function (direction, distance) {
	              if (distance < -settings.jitter) {
	                module.debug('Position exceeds allowable distance from edge', direction, distance, position);
	                offstage.push(direction);
	              }
	            });
	            if (offstage.length > 0) {
	              return true;
	            } else {
	              return false;
	            }
	          },
	          svg: function svg(element) {
	            return module.supports.svg() && element instanceof SVGGraphicsElement;
	          },
	          active: function active() {
	            return $module.hasClass(className.active);
	          },
	          animating: function animating() {
	            return $popup !== undefined && $popup.hasClass(className.animating);
	          },
	          fluid: function fluid() {
	            return $popup !== undefined && $popup.hasClass(className.fluid);
	          },
	          visible: function visible() {
	            return $popup !== undefined && $popup.hasClass(className.visible);
	          },
	          dropdown: function dropdown() {
	            return $module.hasClass(className.dropdown);
	          },
	          hidden: function hidden() {
	            return !module.is.visible();
	          },
	          rtl: function rtl() {
	            return $module.css('direction') == 'rtl';
	          }
	        },

	        reset: function reset() {
	          module.remove.visible();
	          if (settings.preserve) {
	            if ($.fn.transition !== undefined) {
	              $popup.transition('remove transition');
	            }
	          } else {
	            module.removePopup();
	          }
	        },

	        setting: function setting(name, value) {
	          if ($.isPlainObject(name)) {
	            $.extend(true, settings, name);
	          } else if (value !== undefined) {
	            settings[name] = value;
	          } else {
	            return settings[name];
	          }
	        },
	        internal: function internal(name, value) {
	          if ($.isPlainObject(name)) {
	            $.extend(true, module, name);
	          } else if (value !== undefined) {
	            module[name] = value;
	          } else {
	            return module[name];
	          }
	        },
	        debug: function debug() {
	          if (!settings.silent && settings.debug) {
	            if (settings.performance) {
	              module.performance.log(arguments);
	            } else {
	              module.debug = Function.prototype.bind.call(console.info, console, settings.name + ':');
	              module.debug.apply(console, arguments);
	            }
	          }
	        },
	        verbose: function verbose() {
	          if (!settings.silent && settings.verbose && settings.debug) {
	            if (settings.performance) {
	              module.performance.log(arguments);
	            } else {
	              module.verbose = Function.prototype.bind.call(console.info, console, settings.name + ':');
	              module.verbose.apply(console, arguments);
	            }
	          }
	        },
	        error: function error() {
	          if (!settings.silent) {
	            module.error = Function.prototype.bind.call(console.error, console, settings.name + ':');
	            module.error.apply(console, arguments);
	          }
	        },
	        performance: {
	          log: function log(message) {
	            var currentTime, executionTime, previousTime;
	            if (settings.performance) {
	              currentTime = new Date().getTime();
	              previousTime = time || currentTime;
	              executionTime = currentTime - previousTime;
	              time = currentTime;
	              performance.push({
	                'Name': message[0],
	                'Arguments': [].slice.call(message, 1) || '',
	                'Element': element,
	                'Execution Time': executionTime
	              });
	            }
	            clearTimeout(module.performance.timer);
	            module.performance.timer = setTimeout(module.performance.display, 500);
	          },
	          display: function display() {
	            var title = settings.name + ':',
	                totalTime = 0;
	            time = false;
	            clearTimeout(module.performance.timer);
	            $.each(performance, function (index, data) {
	              totalTime += data['Execution Time'];
	            });
	            title += ' ' + totalTime + 'ms';
	            if (moduleSelector) {
	              title += ' \'' + moduleSelector + '\'';
	            }
	            if ((console.group !== undefined || console.table !== undefined) && performance.length > 0) {
	              console.groupCollapsed(title);
	              if (console.table) {
	                console.table(performance);
	              } else {
	                $.each(performance, function (index, data) {
	                  console.log(data['Name'] + ': ' + data['Execution Time'] + 'ms');
	                });
	              }
	              console.groupEnd();
	            }
	            performance = [];
	          }
	        },
	        invoke: function invoke(query, passedArguments, context) {
	          var object = instance,
	              maxDepth,
	              found,
	              response;
	          passedArguments = passedArguments || queryArguments;
	          context = element || context;
	          if (typeof query == 'string' && object !== undefined) {
	            query = query.split(/[\. ]/);
	            maxDepth = query.length - 1;
	            $.each(query, function (depth, value) {
	              var camelCaseValue = depth != maxDepth ? value + query[depth + 1].charAt(0).toUpperCase() + query[depth + 1].slice(1) : query;
	              if ($.isPlainObject(object[camelCaseValue]) && depth != maxDepth) {
	                object = object[camelCaseValue];
	              } else if (object[camelCaseValue] !== undefined) {
	                found = object[camelCaseValue];
	                return false;
	              } else if ($.isPlainObject(object[value]) && depth != maxDepth) {
	                object = object[value];
	              } else if (object[value] !== undefined) {
	                found = object[value];
	                return false;
	              } else {
	                return false;
	              }
	            });
	          }
	          if ($.isFunction(found)) {
	            response = found.apply(context, passedArguments);
	          } else if (found !== undefined) {
	            response = found;
	          }
	          if ($.isArray(returnedValue)) {
	            returnedValue.push(response);
	          } else if (returnedValue !== undefined) {
	            returnedValue = [returnedValue, response];
	          } else if (response !== undefined) {
	            returnedValue = response;
	          }
	          return found;
	        }
	      };

	      if (methodInvoked) {
	        if (instance === undefined) {
	          module.initialize();
	        }
	        module.invoke(query);
	      } else {
	        if (instance !== undefined) {
	          instance.invoke('destroy');
	        }
	        module.initialize();
	      }
	    });

	    return returnedValue !== undefined ? returnedValue : this;
	  };

	  $.fn.popup.settings = {

	    name: 'Popup',

	    // module settings
	    silent: false,
	    debug: false,
	    verbose: false,
	    performance: true,
	    namespace: 'popup',

	    // whether it should use dom mutation observers
	    observeChanges: true,

	    // callback only when element added to dom
	    onCreate: function onCreate() {},

	    // callback before element removed from dom
	    onRemove: function onRemove() {},

	    // callback before show animation
	    onShow: function onShow() {},

	    // callback after show animation
	    onVisible: function onVisible() {},

	    // callback before hide animation
	    onHide: function onHide() {},

	    // callback when popup cannot be positioned in visible screen
	    onUnplaceable: function onUnplaceable() {},

	    // callback after hide animation
	    onHidden: function onHidden() {},

	    // when to show popup
	    on: 'hover',

	    // element to use to determine if popup is out of boundary
	    boundary: window,

	    // whether to add touchstart events when using hover
	    addTouchEvents: true,

	    // default position relative to element
	    position: 'top left',

	    // name of variation to use
	    variation: '',

	    // whether popup should be moved to context
	    movePopup: true,

	    // element which popup should be relative to
	    target: false,

	    // jq selector or element that should be used as popup
	    popup: false,

	    // popup should remain inline next to activator
	    inline: false,

	    // popup should be removed from page on hide
	    preserve: false,

	    // popup should not close when being hovered on
	    hoverable: false,

	    // explicitly set content
	    content: false,

	    // explicitly set html
	    html: false,

	    // explicitly set title
	    title: false,

	    // whether automatically close on clickaway when on click
	    closable: true,

	    // automatically hide on scroll
	    hideOnScroll: 'auto',

	    // hide other popups on show
	    exclusive: false,

	    // context to attach popups
	    context: 'body',

	    // context for binding scroll events
	    scrollContext: window,

	    // position to prefer when calculating new position
	    prefer: 'opposite',

	    // specify position to appear even if it doesn't fit
	    lastResort: false,

	    // delay used to prevent accidental refiring of animations due to user error
	    delay: {
	      show: 50,
	      hide: 70
	    },

	    // whether fluid variation should assign width explicitly
	    setFluidWidth: true,

	    // transition settings
	    duration: 200,
	    transition: 'scale',

	    // distance away from activating element in px
	    distanceAway: 0,

	    // number of pixels an element is allowed to be "offstage" for a position to be chosen (allows for rounding)
	    jitter: 2,

	    // offset on aligning axis from calculated position
	    offset: 0,

	    // maximum times to look for a position before failing (9 positions total)
	    maxSearchDepth: 15,

	    error: {
	      invalidPosition: 'The position you specified is not a valid position',
	      cannotPlace: 'Popup does not fit within the boundaries of the viewport',
	      method: 'The method you called is not defined.',
	      noTransition: 'This module requires ui transitions <https://github.com/Semantic-Org/UI-Transition>',
	      notFound: 'The target or popup you specified does not exist on the page'
	    },

	    metadata: {
	      activator: 'activator',
	      content: 'content',
	      html: 'html',
	      offset: 'offset',
	      position: 'position',
	      title: 'title',
	      variation: 'variation'
	    },

	    className: {
	      active: 'active',
	      animating: 'animating',
	      dropdown: 'dropdown',
	      fluid: 'fluid',
	      loading: 'loading',
	      popup: 'ui popup',
	      position: 'top left center bottom right',
	      visible: 'visible'
	    },

	    selector: {
	      popup: '.ui.popup'
	    },

	    templates: {
	      escape: function escape(string) {
	        var badChars = /[&<>"'`]/g,
	            shouldEscape = /[&<>"'`]/,
	            escape = {
	          "&": "&amp;",
	          "<": "&lt;",
	          ">": "&gt;",
	          '"': "&quot;",
	          "'": "&#x27;",
	          "`": "&#x60;"
	        },
	            escapedChar = function escapedChar(chr) {
	          return escape[chr];
	        };
	        if (shouldEscape.test(string)) {
	          return string.replace(badChars, escapedChar);
	        }
	        return string;
	      },
	      popup: function popup(text) {
	        var html = '',
	            escape = $.fn.popup.settings.templates.escape;
	        if ((typeof text === 'undefined' ? 'undefined' : _typeof(text)) !== undefined) {
	          if (_typeof(text.title) !== undefined && text.title) {
	            text.title = escape(text.title);
	            html += '<div class="header">' + text.title + '</div>';
	          }
	          if (_typeof(text.content) !== undefined && text.content) {
	            text.content = escape(text.content);
	            html += '<div class="content">' + text.content + '</div>';
	          }
	        }
	        return html;
	      }
	    }

	  };
	})(jQuery, window, document);
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(jQuery) {'use strict';

	/*!
	 * # Semantic UI - Form Validation
	 * http://github.com/semantic-org/semantic-ui/
	 *
	 *
	 * Released under the MIT license
	 * http://opensource.org/licenses/MIT
	 *
	 */

	;(function ($, window, document, undefined) {

	  "use strict";

	  window = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();

	  $.fn.form = function (parameters) {
	    var $allModules = $(this),
	        moduleSelector = $allModules.selector || '',
	        time = new Date().getTime(),
	        performance = [],
	        query = arguments[0],
	        legacyParameters = arguments[1],
	        methodInvoked = typeof query == 'string',
	        queryArguments = [].slice.call(arguments, 1),
	        returnedValue;
	    $allModules.each(function () {
	      var $module = $(this),
	          element = this,
	          formErrors = [],
	          keyHeldDown = false,


	      // set at run-time
	      $field,
	          $group,
	          $message,
	          $prompt,
	          $submit,
	          $clear,
	          $reset,
	          _settings,
	          _validation,
	          metadata,
	          selector,
	          className,
	          error,
	          namespace,
	          moduleNamespace,
	          eventNamespace,
	          instance,
	          module;

	      module = {

	        initialize: function initialize() {

	          // settings grabbed at run time
	          module.get.settings();
	          if (methodInvoked) {
	            if (instance === undefined) {
	              module.instantiate();
	            }
	            module.invoke(query);
	          } else {
	            if (instance !== undefined) {
	              instance.invoke('destroy');
	            }
	            module.verbose('Initializing form validation', $module, _settings);
	            module.bindEvents();
	            module.set.defaults();
	            module.instantiate();
	          }
	        },

	        instantiate: function instantiate() {
	          module.verbose('Storing instance of module', module);
	          instance = module;
	          $module.data(moduleNamespace, module);
	        },

	        destroy: function destroy() {
	          module.verbose('Destroying previous module', instance);
	          module.removeEvents();
	          $module.removeData(moduleNamespace);
	        },

	        refresh: function refresh() {
	          module.verbose('Refreshing selector cache');
	          $field = $module.find(selector.field);
	          $group = $module.find(selector.group);
	          $message = $module.find(selector.message);
	          $prompt = $module.find(selector.prompt);

	          $submit = $module.find(selector.submit);
	          $clear = $module.find(selector.clear);
	          $reset = $module.find(selector.reset);
	        },

	        submit: function submit() {
	          module.verbose('Submitting form', $module);
	          $module.submit();
	        },

	        attachEvents: function attachEvents(selector, action) {
	          action = action || 'submit';
	          $(selector).on('click' + eventNamespace, function (event) {
	            module[action]();
	            event.preventDefault();
	          });
	        },

	        bindEvents: function bindEvents() {
	          module.verbose('Attaching form events');
	          $module.on('submit' + eventNamespace, module.validate.form).on('blur' + eventNamespace, selector.field, module.event.field.blur).on('click' + eventNamespace, selector.submit, module.submit).on('click' + eventNamespace, selector.reset, module.reset).on('click' + eventNamespace, selector.clear, module.clear);
	          if (_settings.keyboardShortcuts) {
	            $module.on('keydown' + eventNamespace, selector.field, module.event.field.keydown);
	          }
	          $field.each(function () {
	            var $input = $(this),
	                type = $input.prop('type'),
	                inputEvent = module.get.changeEvent(type, $input);
	            $(this).on(inputEvent + eventNamespace, module.event.field.change);
	          });
	        },

	        clear: function clear() {
	          $field.each(function () {
	            var $field = $(this),
	                $element = $field.parent(),
	                $fieldGroup = $field.closest($group),
	                $prompt = $fieldGroup.find(selector.prompt),
	                defaultValue = $field.data(metadata.defaultValue) || '',
	                isCheckbox = $element.is(selector.uiCheckbox),
	                isDropdown = $element.is(selector.uiDropdown),
	                isErrored = $fieldGroup.hasClass(className.error);
	            if (isErrored) {
	              module.verbose('Resetting error on field', $fieldGroup);
	              $fieldGroup.removeClass(className.error);
	              $prompt.remove();
	            }
	            if (isDropdown) {
	              module.verbose('Resetting dropdown value', $element, defaultValue);
	              $element.dropdown('clear');
	            } else if (isCheckbox) {
	              $field.prop('checked', false);
	            } else {
	              module.verbose('Resetting field value', $field, defaultValue);
	              $field.val('');
	            }
	          });
	        },

	        reset: function reset() {
	          $field.each(function () {
	            var $field = $(this),
	                $element = $field.parent(),
	                $fieldGroup = $field.closest($group),
	                $prompt = $fieldGroup.find(selector.prompt),
	                defaultValue = $field.data(metadata.defaultValue),
	                isCheckbox = $element.is(selector.uiCheckbox),
	                isDropdown = $element.is(selector.uiDropdown),
	                isErrored = $fieldGroup.hasClass(className.error);
	            if (defaultValue === undefined) {
	              return;
	            }
	            if (isErrored) {
	              module.verbose('Resetting error on field', $fieldGroup);
	              $fieldGroup.removeClass(className.error);
	              $prompt.remove();
	            }
	            if (isDropdown) {
	              module.verbose('Resetting dropdown value', $element, defaultValue);
	              $element.dropdown('restore defaults');
	            } else if (isCheckbox) {
	              module.verbose('Resetting checkbox value', $element, defaultValue);
	              $field.prop('checked', defaultValue);
	            } else {
	              module.verbose('Resetting field value', $field, defaultValue);
	              $field.val(defaultValue);
	            }
	          });
	        },

	        is: {
	          bracketedRule: function bracketedRule(rule) {
	            return rule.type && rule.type.match(_settings.regExp.bracket);
	          },
	          empty: function empty($field) {
	            if (!$field || $field.length === 0) {
	              return true;
	            } else if ($field.is('input[type="checkbox"]')) {
	              return !$field.is(':checked');
	            } else {
	              return module.is.blank($field);
	            }
	          },
	          blank: function blank($field) {
	            return $.trim($field.val()) === '';
	          },
	          valid: function valid() {
	            var allValid = true;
	            module.verbose('Checking if form is valid');
	            $.each(_validation, function (fieldName, field) {
	              if (!module.validate.field(field, fieldName)) {
	                allValid = false;
	              }
	            });
	            return allValid;
	          }
	        },

	        removeEvents: function removeEvents() {
	          $module.off(eventNamespace);
	          $field.off(eventNamespace);
	          $submit.off(eventNamespace);
	          $field.off(eventNamespace);
	        },

	        event: {
	          field: {
	            keydown: function keydown(event) {
	              var $field = $(this),
	                  key = event.which,
	                  isInput = $field.is(selector.input),
	                  isCheckbox = $field.is(selector.checkbox),
	                  isInDropdown = $field.closest(selector.uiDropdown).length > 0,
	                  keyCode = {
	                enter: 13,
	                escape: 27
	              };
	              if (key == keyCode.escape) {
	                module.verbose('Escape key pressed blurring field');
	                $field.blur();
	              }
	              if (!event.ctrlKey && key == keyCode.enter && isInput && !isInDropdown && !isCheckbox) {
	                if (!keyHeldDown) {
	                  $field.one('keyup' + eventNamespace, module.event.field.keyup);
	                  module.submit();
	                  module.debug('Enter pressed on input submitting form');
	                }
	                keyHeldDown = true;
	              }
	            },
	            keyup: function keyup() {
	              keyHeldDown = false;
	            },
	            blur: function blur(event) {
	              var $field = $(this),
	                  $fieldGroup = $field.closest($group),
	                  validationRules = module.get.validation($field);
	              if ($fieldGroup.hasClass(className.error)) {
	                module.debug('Revalidating field', $field, validationRules);
	                if (validationRules) {
	                  module.validate.field(validationRules);
	                }
	              } else if (_settings.on == 'blur' || _settings.on == 'change') {
	                if (validationRules) {
	                  module.validate.field(validationRules);
	                }
	              }
	            },
	            change: function change(event) {
	              var $field = $(this),
	                  $fieldGroup = $field.closest($group),
	                  validationRules = module.get.validation($field);
	              if (_settings.on == 'change' || $fieldGroup.hasClass(className.error) && _settings.revalidate) {
	                clearTimeout(module.timer);
	                module.timer = setTimeout(function () {
	                  module.debug('Revalidating field', $field, module.get.validation($field));
	                  module.validate.field(validationRules);
	                }, _settings.delay);
	              }
	            }
	          }

	        },

	        get: {
	          ancillaryValue: function ancillaryValue(rule) {
	            if (!rule.type || !rule.value && !module.is.bracketedRule(rule)) {
	              return false;
	            }
	            return rule.value !== undefined ? rule.value : rule.type.match(_settings.regExp.bracket)[1] + '';
	          },
	          ruleName: function ruleName(rule) {
	            if (module.is.bracketedRule(rule)) {
	              return rule.type.replace(rule.type.match(_settings.regExp.bracket)[0], '');
	            }
	            return rule.type;
	          },
	          changeEvent: function changeEvent(type, $input) {
	            if (type == 'checkbox' || type == 'radio' || type == 'hidden' || $input.is('select')) {
	              return 'change';
	            } else {
	              return module.get.inputEvent();
	            }
	          },
	          inputEvent: function inputEvent() {
	            return document.createElement('input').oninput !== undefined ? 'input' : document.createElement('input').onpropertychange !== undefined ? 'propertychange' : 'keyup';
	          },
	          prompt: function prompt(rule, field) {
	            var ruleName = module.get.ruleName(rule),
	                ancillary = module.get.ancillaryValue(rule),
	                prompt = rule.prompt || _settings.prompt[ruleName] || _settings.text.unspecifiedRule,
	                requiresValue = prompt.search('{value}') !== -1,
	                requiresName = prompt.search('{name}') !== -1,
	                $label,
	                $field,
	                name;
	            if (requiresName || requiresValue) {
	              $field = module.get.field(field.identifier);
	            }
	            if (requiresValue) {
	              prompt = prompt.replace('{value}', $field.val());
	            }
	            if (requiresName) {
	              $label = $field.closest(selector.group).find('label').eq(0);
	              name = $label.length == 1 ? $label.text() : $field.prop('placeholder') || _settings.text.unspecifiedField;
	              prompt = prompt.replace('{name}', name);
	            }
	            prompt = prompt.replace('{identifier}', field.identifier);
	            prompt = prompt.replace('{ruleValue}', ancillary);
	            if (!rule.prompt) {
	              module.verbose('Using default validation prompt for type', prompt, ruleName);
	            }
	            return prompt;
	          },
	          settings: function settings() {
	            if ($.isPlainObject(parameters)) {
	              var keys = Object.keys(parameters),
	                  isLegacySettings = keys.length > 0 ? parameters[keys[0]].identifier !== undefined && parameters[keys[0]].rules !== undefined : false,
	                  ruleKeys;
	              if (isLegacySettings) {
	                // 1.x (ducktyped)
	                _settings = $.extend(true, {}, $.fn.form.settings, legacyParameters);
	                _validation = $.extend({}, $.fn.form.settings.defaults, parameters);
	                module.error(_settings.error.oldSyntax, element);
	                module.verbose('Extending settings from legacy parameters', _validation, _settings);
	              } else {
	                // 2.x
	                if (parameters.fields) {
	                  ruleKeys = Object.keys(parameters.fields);
	                  if (typeof parameters.fields[ruleKeys[0]] == 'string' || $.isArray(parameters.fields[ruleKeys[0]])) {
	                    $.each(parameters.fields, function (name, rules) {
	                      if (typeof rules == 'string') {
	                        rules = [rules];
	                      }
	                      parameters.fields[name] = {
	                        rules: []
	                      };
	                      $.each(rules, function (index, rule) {
	                        parameters.fields[name].rules.push({ type: rule });
	                      });
	                    });
	                  }
	                }

	                _settings = $.extend(true, {}, $.fn.form.settings, parameters);
	                _validation = $.extend({}, $.fn.form.settings.defaults, _settings.fields);
	                module.verbose('Extending settings', _validation, _settings);
	              }
	            } else {
	              _settings = $.fn.form.settings;
	              _validation = $.fn.form.settings.defaults;
	              module.verbose('Using default form validation', _validation, _settings);
	            }

	            // shorthand
	            namespace = _settings.namespace;
	            metadata = _settings.metadata;
	            selector = _settings.selector;
	            className = _settings.className;
	            error = _settings.error;
	            moduleNamespace = 'module-' + namespace;
	            eventNamespace = '.' + namespace;

	            // grab instance
	            instance = $module.data(moduleNamespace);

	            // refresh selector cache
	            module.refresh();
	          },
	          field: function field(identifier) {
	            module.verbose('Finding field with identifier', identifier);
	            if ($field.filter('#' + identifier).length > 0) {
	              return $field.filter('#' + identifier);
	            } else if ($field.filter('[name="' + identifier + '"]').length > 0) {
	              return $field.filter('[name="' + identifier + '"]');
	            } else if ($field.filter('[name="' + identifier + '[]"]').length > 0) {
	              return $field.filter('[name="' + identifier + '[]"]');
	            } else if ($field.filter('[data-' + metadata.validate + '="' + identifier + '"]').length > 0) {
	              return $field.filter('[data-' + metadata.validate + '="' + identifier + '"]');
	            }
	            return $('<input/>');
	          },
	          fields: function fields(_fields) {
	            var $fields = $();
	            $.each(_fields, function (index, name) {
	              $fields = $fields.add(module.get.field(name));
	            });
	            return $fields;
	          },
	          validation: function validation($field) {
	            var fieldValidation, identifier;
	            if (!_validation) {
	              return false;
	            }
	            $.each(_validation, function (fieldName, field) {
	              identifier = field.identifier || fieldName;
	              if (module.get.field(identifier)[0] == $field[0]) {
	                field.identifier = identifier;
	                fieldValidation = field;
	              }
	            });
	            return fieldValidation || false;
	          },
	          value: function value(field) {
	            var fields = [],
	                results;
	            fields.push(field);
	            results = module.get.values.call(element, fields);
	            return results[field];
	          },
	          values: function values(fields) {
	            var $fields = $.isArray(fields) ? module.get.fields(fields) : $field,
	                values = {};
	            $fields.each(function (index, field) {
	              var $field = $(field),
	                  type = $field.prop('type'),
	                  name = $field.prop('name'),
	                  value = $field.val(),
	                  isCheckbox = $field.is(selector.checkbox),
	                  isRadio = $field.is(selector.radio),
	                  isMultiple = name.indexOf('[]') !== -1,
	                  isChecked = isCheckbox ? $field.is(':checked') : false;
	              if (name) {
	                if (isMultiple) {
	                  name = name.replace('[]', '');
	                  if (!values[name]) {
	                    values[name] = [];
	                  }
	                  if (isCheckbox) {
	                    if (isChecked) {
	                      values[name].push(value || true);
	                    } else {
	                      values[name].push(false);
	                    }
	                  } else {
	                    values[name].push(value);
	                  }
	                } else {
	                  if (isRadio) {
	                    if (isChecked) {
	                      values[name] = value;
	                    }
	                  } else if (isCheckbox) {
	                    if (isChecked) {
	                      values[name] = value || true;
	                    } else {
	                      values[name] = false;
	                    }
	                  } else {
	                    values[name] = value;
	                  }
	                }
	              }
	            });
	            return values;
	          }
	        },

	        has: {

	          field: function field(identifier) {
	            module.verbose('Checking for existence of a field with identifier', identifier);
	            if (typeof identifier !== 'string') {
	              module.error(error.identifier, identifier);
	            }
	            if ($field.filter('#' + identifier).length > 0) {
	              return true;
	            } else if ($field.filter('[name="' + identifier + '"]').length > 0) {
	              return true;
	            } else if ($field.filter('[data-' + metadata.validate + '="' + identifier + '"]').length > 0) {
	              return true;
	            }
	            return false;
	          }

	        },

	        add: {
	          prompt: function prompt(identifier, errors) {
	            var $field = module.get.field(identifier),
	                $fieldGroup = $field.closest($group),
	                $prompt = $fieldGroup.children(selector.prompt),
	                promptExists = $prompt.length !== 0;
	            errors = typeof errors == 'string' ? [errors] : errors;
	            module.verbose('Adding field error state', identifier);
	            $fieldGroup.addClass(className.error);
	            if (_settings.inline) {
	              if (!promptExists) {
	                $prompt = _settings.templates.prompt(errors);
	                $prompt.appendTo($fieldGroup);
	              }
	              $prompt.html(errors[0]);
	              if (!promptExists) {
	                if (_settings.transition && $.fn.transition !== undefined && $module.transition('is supported')) {
	                  module.verbose('Displaying error with css transition', _settings.transition);
	                  $prompt.transition(_settings.transition + ' in', _settings.duration);
	                } else {
	                  module.verbose('Displaying error with fallback javascript animation');
	                  $prompt.fadeIn(_settings.duration);
	                }
	              } else {
	                module.verbose('Inline errors are disabled, no inline error added', identifier);
	              }
	            }
	          },
	          errors: function errors(_errors) {
	            module.debug('Adding form error messages', _errors);
	            module.set.error();
	            $message.html(_settings.templates.error(_errors));
	          }
	        },

	        remove: {
	          prompt: function prompt(identifier) {
	            var $field = module.get.field(identifier),
	                $fieldGroup = $field.closest($group),
	                $prompt = $fieldGroup.children(selector.prompt);
	            $fieldGroup.removeClass(className.error);
	            if (_settings.inline && $prompt.is(':visible')) {
	              module.verbose('Removing prompt for field', identifier);
	              if (_settings.transition && $.fn.transition !== undefined && $module.transition('is supported')) {
	                $prompt.transition(_settings.transition + ' out', _settings.duration, function () {
	                  $prompt.remove();
	                });
	              } else {
	                $prompt.fadeOut(_settings.duration, function () {
	                  $prompt.remove();
	                });
	              }
	            }
	          }
	        },

	        set: {
	          success: function success() {
	            $module.removeClass(className.error).addClass(className.success);
	          },
	          defaults: function defaults() {
	            $field.each(function () {
	              var $field = $(this),
	                  isCheckbox = $field.filter(selector.checkbox).length > 0,
	                  value = isCheckbox ? $field.is(':checked') : $field.val();
	              $field.data(metadata.defaultValue, value);
	            });
	          },
	          error: function error() {
	            $module.removeClass(className.success).addClass(className.error);
	          },
	          value: function value(field, _value) {
	            var fields = {};
	            fields[field] = _value;
	            return module.set.values.call(element, fields);
	          },
	          values: function values(fields) {
	            if ($.isEmptyObject(fields)) {
	              return;
	            }
	            $.each(fields, function (key, value) {
	              var $field = module.get.field(key),
	                  $element = $field.parent(),
	                  isMultiple = $.isArray(value),
	                  isCheckbox = $element.is(selector.uiCheckbox),
	                  isDropdown = $element.is(selector.uiDropdown),
	                  isRadio = $field.is(selector.radio) && isCheckbox,
	                  fieldExists = $field.length > 0,
	                  $multipleField;
	              if (fieldExists) {
	                if (isMultiple && isCheckbox) {
	                  module.verbose('Selecting multiple', value, $field);
	                  $element.checkbox('uncheck');
	                  $.each(value, function (index, value) {
	                    $multipleField = $field.filter('[value="' + value + '"]');
	                    $element = $multipleField.parent();
	                    if ($multipleField.length > 0) {
	                      $element.checkbox('check');
	                    }
	                  });
	                } else if (isRadio) {
	                  module.verbose('Selecting radio value', value, $field);
	                  $field.filter('[value="' + value + '"]').parent(selector.uiCheckbox).checkbox('check');
	                } else if (isCheckbox) {
	                  module.verbose('Setting checkbox value', value, $element);
	                  if (value === true) {
	                    $element.checkbox('check');
	                  } else {
	                    $element.checkbox('uncheck');
	                  }
	                } else if (isDropdown) {
	                  module.verbose('Setting dropdown value', value, $element);
	                  $element.dropdown('set selected', value);
	                } else {
	                  module.verbose('Setting field value', value, $field);
	                  $field.val(value);
	                }
	              }
	            });
	          }
	        },

	        validate: {

	          form: function form(event, ignoreCallbacks) {
	            var values = module.get.values(),
	                apiRequest;

	            // input keydown event will fire submit repeatedly by browser default
	            if (keyHeldDown) {
	              return false;
	            }

	            // reset errors
	            formErrors = [];
	            if (module.is.valid()) {
	              module.debug('Form has no validation errors, submitting');
	              module.set.success();
	              if (ignoreCallbacks !== true) {
	                return _settings.onSuccess.call(element, event, values);
	              }
	            } else {
	              module.debug('Form has errors');
	              module.set.error();
	              if (!_settings.inline) {
	                module.add.errors(formErrors);
	              }
	              // prevent ajax submit
	              if ($module.data('moduleApi') !== undefined) {
	                event.stopImmediatePropagation();
	              }
	              if (ignoreCallbacks !== true) {
	                return _settings.onFailure.call(element, formErrors, values);
	              }
	            }
	          },

	          // takes a validation object and returns whether field passes validation
	          field: function field(_field, fieldName) {
	            var identifier = _field.identifier || fieldName,
	                $field = module.get.field(identifier),
	                $dependsField = _field.depends ? module.get.field(_field.depends) : false,
	                fieldValid = true,
	                fieldErrors = [];
	            if (!_field.identifier) {
	              module.debug('Using field name as identifier', identifier);
	              _field.identifier = identifier;
	            }
	            if ($field.prop('disabled')) {
	              module.debug('Field is disabled. Skipping', identifier);
	              fieldValid = true;
	            } else if (_field.optional && module.is.blank($field)) {
	              module.debug('Field is optional and blank. Skipping', identifier);
	              fieldValid = true;
	            } else if (_field.depends && module.is.empty($dependsField)) {
	              module.debug('Field depends on another value that is not present or empty. Skipping', $dependsField);
	              fieldValid = true;
	            } else if (_field.rules !== undefined) {
	              $.each(_field.rules, function (index, rule) {
	                if (module.has.field(identifier) && !module.validate.rule(_field, rule)) {
	                  module.debug('Field is invalid', identifier, rule.type);
	                  fieldErrors.push(module.get.prompt(rule, _field));
	                  fieldValid = false;
	                }
	              });
	            }
	            if (fieldValid) {
	              module.remove.prompt(identifier, fieldErrors);
	              _settings.onValid.call($field);
	            } else {
	              formErrors = formErrors.concat(fieldErrors);
	              module.add.prompt(identifier, fieldErrors);
	              _settings.onInvalid.call($field, fieldErrors);
	              return false;
	            }
	            return true;
	          },

	          // takes validation rule and returns whether field passes rule
	          rule: function rule(field, _rule) {
	            var $field = module.get.field(field.identifier),
	                type = _rule.type,
	                value = $field.val(),
	                isValid = true,
	                ancillary = module.get.ancillaryValue(_rule),
	                ruleName = module.get.ruleName(_rule),
	                ruleFunction = _settings.rules[ruleName];
	            if (!$.isFunction(ruleFunction)) {
	              module.error(error.noRule, ruleName);
	              return;
	            }
	            // cast to string avoiding encoding special values
	            value = value === undefined || value === '' || value === null ? '' : $.trim(value + '');
	            return ruleFunction.call($field, value, ancillary);
	          }
	        },

	        setting: function setting(name, value) {
	          if ($.isPlainObject(name)) {
	            $.extend(true, _settings, name);
	          } else if (value !== undefined) {
	            _settings[name] = value;
	          } else {
	            return _settings[name];
	          }
	        },
	        internal: function internal(name, value) {
	          if ($.isPlainObject(name)) {
	            $.extend(true, module, name);
	          } else if (value !== undefined) {
	            module[name] = value;
	          } else {
	            return module[name];
	          }
	        },
	        debug: function debug() {
	          if (!_settings.silent && _settings.debug) {
	            if (_settings.performance) {
	              module.performance.log(arguments);
	            } else {
	              module.debug = Function.prototype.bind.call(console.info, console, _settings.name + ':');
	              module.debug.apply(console, arguments);
	            }
	          }
	        },
	        verbose: function verbose() {
	          if (!_settings.silent && _settings.verbose && _settings.debug) {
	            if (_settings.performance) {
	              module.performance.log(arguments);
	            } else {
	              module.verbose = Function.prototype.bind.call(console.info, console, _settings.name + ':');
	              module.verbose.apply(console, arguments);
	            }
	          }
	        },
	        error: function error() {
	          if (!_settings.silent) {
	            module.error = Function.prototype.bind.call(console.error, console, _settings.name + ':');
	            module.error.apply(console, arguments);
	          }
	        },
	        performance: {
	          log: function log(message) {
	            var currentTime, executionTime, previousTime;
	            if (_settings.performance) {
	              currentTime = new Date().getTime();
	              previousTime = time || currentTime;
	              executionTime = currentTime - previousTime;
	              time = currentTime;
	              performance.push({
	                'Name': message[0],
	                'Arguments': [].slice.call(message, 1) || '',
	                'Element': element,
	                'Execution Time': executionTime
	              });
	            }
	            clearTimeout(module.performance.timer);
	            module.performance.timer = setTimeout(module.performance.display, 500);
	          },
	          display: function display() {
	            var title = _settings.name + ':',
	                totalTime = 0;
	            time = false;
	            clearTimeout(module.performance.timer);
	            $.each(performance, function (index, data) {
	              totalTime += data['Execution Time'];
	            });
	            title += ' ' + totalTime + 'ms';
	            if (moduleSelector) {
	              title += ' \'' + moduleSelector + '\'';
	            }
	            if ($allModules.length > 1) {
	              title += ' ' + '(' + $allModules.length + ')';
	            }
	            if ((console.group !== undefined || console.table !== undefined) && performance.length > 0) {
	              console.groupCollapsed(title);
	              if (console.table) {
	                console.table(performance);
	              } else {
	                $.each(performance, function (index, data) {
	                  console.log(data['Name'] + ': ' + data['Execution Time'] + 'ms');
	                });
	              }
	              console.groupEnd();
	            }
	            performance = [];
	          }
	        },
	        invoke: function invoke(query, passedArguments, context) {
	          var object = instance,
	              maxDepth,
	              found,
	              response;
	          passedArguments = passedArguments || queryArguments;
	          context = element || context;
	          if (typeof query == 'string' && object !== undefined) {
	            query = query.split(/[\. ]/);
	            maxDepth = query.length - 1;
	            $.each(query, function (depth, value) {
	              var camelCaseValue = depth != maxDepth ? value + query[depth + 1].charAt(0).toUpperCase() + query[depth + 1].slice(1) : query;
	              if ($.isPlainObject(object[camelCaseValue]) && depth != maxDepth) {
	                object = object[camelCaseValue];
	              } else if (object[camelCaseValue] !== undefined) {
	                found = object[camelCaseValue];
	                return false;
	              } else if ($.isPlainObject(object[value]) && depth != maxDepth) {
	                object = object[value];
	              } else if (object[value] !== undefined) {
	                found = object[value];
	                return false;
	              } else {
	                return false;
	              }
	            });
	          }
	          if ($.isFunction(found)) {
	            response = found.apply(context, passedArguments);
	          } else if (found !== undefined) {
	            response = found;
	          }
	          if ($.isArray(returnedValue)) {
	            returnedValue.push(response);
	          } else if (returnedValue !== undefined) {
	            returnedValue = [returnedValue, response];
	          } else if (response !== undefined) {
	            returnedValue = response;
	          }
	          return found;
	        }
	      };
	      module.initialize();
	    });

	    return returnedValue !== undefined ? returnedValue : this;
	  };

	  $.fn.form.settings = {

	    name: 'Form',
	    namespace: 'form',

	    debug: false,
	    verbose: false,
	    performance: true,

	    fields: false,

	    keyboardShortcuts: true,
	    on: 'submit',
	    inline: false,

	    delay: 200,
	    revalidate: true,

	    transition: 'scale',
	    duration: 200,

	    onValid: function onValid() {},
	    onInvalid: function onInvalid() {},
	    onSuccess: function onSuccess() {
	      return true;
	    },
	    onFailure: function onFailure() {
	      return false;
	    },

	    metadata: {
	      defaultValue: 'default',
	      validate: 'validate'
	    },

	    regExp: {
	      bracket: /\[(.*)\]/i,
	      decimal: /^\d*(\.)\d+/,
	      email: /^[a-z0-9!#$%&'*+\/=?^_`{|}~.-]+@[a-z0-9]([a-z0-9-]*[a-z0-9])?(\.[a-z0-9]([a-z0-9-]*[a-z0-9])?)*$/i,
	      escape: /[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g,
	      flags: /^\/(.*)\/(.*)?/,
	      integer: /^\-?\d+$/,
	      number: /^\-?\d*(\.\d+)?$/,
	      url: /(https?:\/\/(?:www\.|(?!www))[^\s\.]+\.[^\s]{2,}|www\.[^\s]+\.[^\s]{2,})/i
	    },

	    text: {
	      unspecifiedRule: 'Please enter a valid value',
	      unspecifiedField: 'This field'
	    },

	    prompt: {
	      empty: '{name} must have a value',
	      checked: '{name} must be checked',
	      email: '{name} must be a valid e-mail',
	      url: '{name} must be a valid url',
	      regExp: '{name} is not formatted correctly',
	      integer: '{name} must be an integer',
	      decimal: '{name} must be a decimal number',
	      number: '{name} must be set to a number',
	      is: '{name} must be "{ruleValue}"',
	      isExactly: '{name} must be exactly "{ruleValue}"',
	      not: '{name} cannot be set to "{ruleValue}"',
	      notExactly: '{name} cannot be set to exactly "{ruleValue}"',
	      contain: '{name} cannot contain "{ruleValue}"',
	      containExactly: '{name} cannot contain exactly "{ruleValue}"',
	      doesntContain: '{name} must contain  "{ruleValue}"',
	      doesntContainExactly: '{name} must contain exactly "{ruleValue}"',
	      minLength: '{name} must be at least {ruleValue} characters',
	      length: '{name} must be at least {ruleValue} characters',
	      exactLength: '{name} must be exactly {ruleValue} characters',
	      maxLength: '{name} cannot be longer than {ruleValue} characters',
	      match: '{name} must match {ruleValue} field',
	      different: '{name} must have a different value than {ruleValue} field',
	      creditCard: '{name} must be a valid credit card number',
	      minCount: '{name} must have at least {ruleValue} choices',
	      exactCount: '{name} must have exactly {ruleValue} choices',
	      maxCount: '{name} must have {ruleValue} or less choices'
	    },

	    selector: {
	      checkbox: 'input[type="checkbox"], input[type="radio"]',
	      clear: '.clear',
	      field: 'input, textarea, select',
	      group: '.field',
	      input: 'input',
	      message: '.error.message',
	      prompt: '.prompt.label',
	      radio: 'input[type="radio"]',
	      reset: '.reset:not([type="reset"])',
	      submit: '.submit:not([type="submit"])',
	      uiCheckbox: '.ui.checkbox',
	      uiDropdown: '.ui.dropdown'
	    },

	    className: {
	      error: 'error',
	      label: 'ui prompt label',
	      pressed: 'down',
	      success: 'success'
	    },

	    error: {
	      identifier: 'You must specify a string identifier for each field',
	      method: 'The method you called is not defined.',
	      noRule: 'There is no rule matching the one you specified',
	      oldSyntax: 'Starting in 2.0 forms now only take a single settings object. Validation settings converted to new syntax automatically.'
	    },

	    templates: {

	      // template that produces error message
	      error: function error(errors) {
	        var html = '<ul class="list">';
	        $.each(errors, function (index, value) {
	          html += '<li>' + value + '</li>';
	        });
	        html += '</ul>';
	        return $(html);
	      },

	      // template that produces label
	      prompt: function prompt(errors) {
	        return $('<div/>').addClass('ui basic red pointing prompt label').html(errors[0]);
	      }
	    },

	    rules: {

	      // is not empty or blank string
	      empty: function empty(value) {
	        return !(value === undefined || '' === value || $.isArray(value) && value.length === 0);
	      },

	      // checkbox checked
	      checked: function checked() {
	        return $(this).filter(':checked').length > 0;
	      },

	      // is most likely an email
	      email: function email(value) {
	        return $.fn.form.settings.regExp.email.test(value);
	      },

	      // value is most likely url
	      url: function url(value) {
	        return $.fn.form.settings.regExp.url.test(value);
	      },

	      // matches specified regExp
	      regExp: function regExp(value, _regExp) {
	        if (_regExp instanceof RegExp) {
	          return value.match(_regExp);
	        }
	        var regExpParts = _regExp.match($.fn.form.settings.regExp.flags),
	            flags;
	        // regular expression specified as /baz/gi (flags)
	        if (regExpParts) {
	          _regExp = regExpParts.length >= 2 ? regExpParts[1] : _regExp;
	          flags = regExpParts.length >= 3 ? regExpParts[2] : '';
	        }
	        return value.match(new RegExp(_regExp, flags));
	      },

	      // is valid integer or matches range
	      integer: function integer(value, range) {
	        var intRegExp = $.fn.form.settings.regExp.integer,
	            min,
	            max,
	            parts;
	        if (!range || ['', '..'].indexOf(range) !== -1) {
	          // do nothing
	        } else if (range.indexOf('..') == -1) {
	          if (intRegExp.test(range)) {
	            min = max = range - 0;
	          }
	        } else {
	          parts = range.split('..', 2);
	          if (intRegExp.test(parts[0])) {
	            min = parts[0] - 0;
	          }
	          if (intRegExp.test(parts[1])) {
	            max = parts[1] - 0;
	          }
	        }
	        return intRegExp.test(value) && (min === undefined || value >= min) && (max === undefined || value <= max);
	      },

	      // is valid number (with decimal)
	      decimal: function decimal(value) {
	        return $.fn.form.settings.regExp.decimal.test(value);
	      },

	      // is valid number
	      number: function number(value) {
	        return $.fn.form.settings.regExp.number.test(value);
	      },

	      // is value (case insensitive)
	      is: function is(value, text) {
	        text = typeof text == 'string' ? text.toLowerCase() : text;
	        value = typeof value == 'string' ? value.toLowerCase() : value;
	        return value == text;
	      },

	      // is value
	      isExactly: function isExactly(value, text) {
	        return value == text;
	      },

	      // value is not another value (case insensitive)
	      not: function not(value, notValue) {
	        value = typeof value == 'string' ? value.toLowerCase() : value;
	        notValue = typeof notValue == 'string' ? notValue.toLowerCase() : notValue;
	        return value != notValue;
	      },

	      // value is not another value (case sensitive)
	      notExactly: function notExactly(value, notValue) {
	        return value != notValue;
	      },

	      // value contains text (insensitive)
	      contains: function contains(value, text) {
	        // escape regex characters
	        text = text.replace($.fn.form.settings.regExp.escape, "\\$&");
	        return value.search(new RegExp(text, 'i')) !== -1;
	      },

	      // value contains text (case sensitive)
	      containsExactly: function containsExactly(value, text) {
	        // escape regex characters
	        text = text.replace($.fn.form.settings.regExp.escape, "\\$&");
	        return value.search(new RegExp(text)) !== -1;
	      },

	      // value contains text (insensitive)
	      doesntContain: function doesntContain(value, text) {
	        // escape regex characters
	        text = text.replace($.fn.form.settings.regExp.escape, "\\$&");
	        return value.search(new RegExp(text, 'i')) === -1;
	      },

	      // value contains text (case sensitive)
	      doesntContainExactly: function doesntContainExactly(value, text) {
	        // escape regex characters
	        text = text.replace($.fn.form.settings.regExp.escape, "\\$&");
	        return value.search(new RegExp(text)) === -1;
	      },

	      // is at least string length
	      minLength: function minLength(value, requiredLength) {
	        return value !== undefined ? value.length >= requiredLength : false;
	      },

	      // see rls notes for 2.0.6 (this is a duplicate of minLength)
	      length: function length(value, requiredLength) {
	        return value !== undefined ? value.length >= requiredLength : false;
	      },

	      // is exactly length
	      exactLength: function exactLength(value, requiredLength) {
	        return value !== undefined ? value.length == requiredLength : false;
	      },

	      // is less than length
	      maxLength: function maxLength(value, _maxLength) {
	        return value !== undefined ? value.length <= _maxLength : false;
	      },

	      // matches another field
	      match: function match(value, identifier) {
	        var $form = $(this),
	            matchingValue;
	        if ($('[data-validate="' + identifier + '"]').length > 0) {
	          matchingValue = $('[data-validate="' + identifier + '"]').val();
	        } else if ($('#' + identifier).length > 0) {
	          matchingValue = $('#' + identifier).val();
	        } else if ($('[name="' + identifier + '"]').length > 0) {
	          matchingValue = $('[name="' + identifier + '"]').val();
	        } else if ($('[name="' + identifier + '[]"]').length > 0) {
	          matchingValue = $('[name="' + identifier + '[]"]');
	        }
	        return matchingValue !== undefined ? value.toString() == matchingValue.toString() : false;
	      },

	      // different than another field
	      different: function different(value, identifier) {
	        // use either id or name of field
	        var $form = $(this),
	            matchingValue;
	        if ($('[data-validate="' + identifier + '"]').length > 0) {
	          matchingValue = $('[data-validate="' + identifier + '"]').val();
	        } else if ($('#' + identifier).length > 0) {
	          matchingValue = $('#' + identifier).val();
	        } else if ($('[name="' + identifier + '"]').length > 0) {
	          matchingValue = $('[name="' + identifier + '"]').val();
	        } else if ($('[name="' + identifier + '[]"]').length > 0) {
	          matchingValue = $('[name="' + identifier + '[]"]');
	        }
	        return matchingValue !== undefined ? value.toString() !== matchingValue.toString() : false;
	      },

	      creditCard: function creditCard(cardNumber, cardTypes) {
	        var cards = {
	          visa: {
	            pattern: /^4/,
	            length: [16]
	          },
	          amex: {
	            pattern: /^3[47]/,
	            length: [15]
	          },
	          mastercard: {
	            pattern: /^5[1-5]/,
	            length: [16]
	          },
	          discover: {
	            pattern: /^(6011|622(12[6-9]|1[3-9][0-9]|[2-8][0-9]{2}|9[0-1][0-9]|92[0-5]|64[4-9])|65)/,
	            length: [16]
	          },
	          unionPay: {
	            pattern: /^(62|88)/,
	            length: [16, 17, 18, 19]
	          },
	          jcb: {
	            pattern: /^35(2[89]|[3-8][0-9])/,
	            length: [16]
	          },
	          maestro: {
	            pattern: /^(5018|5020|5038|6304|6759|676[1-3])/,
	            length: [12, 13, 14, 15, 16, 17, 18, 19]
	          },
	          dinersClub: {
	            pattern: /^(30[0-5]|^36)/,
	            length: [14]
	          },
	          laser: {
	            pattern: /^(6304|670[69]|6771)/,
	            length: [16, 17, 18, 19]
	          },
	          visaElectron: {
	            pattern: /^(4026|417500|4508|4844|491(3|7))/,
	            length: [16]
	          }
	        },
	            valid = {},
	            validCard = false,
	            requiredTypes = typeof cardTypes == 'string' ? cardTypes.split(',') : false,
	            unionPay,
	            validation;

	        if (typeof cardNumber !== 'string' || cardNumber.length === 0) {
	          return;
	        }

	        // verify card types
	        if (requiredTypes) {
	          $.each(requiredTypes, function (index, type) {
	            // verify each card type
	            validation = cards[type];
	            if (validation) {
	              valid = {
	                length: $.inArray(cardNumber.length, validation.length) !== -1,
	                pattern: cardNumber.search(validation.pattern) !== -1
	              };
	              if (valid.length && valid.pattern) {
	                validCard = true;
	              }
	            }
	          });

	          if (!validCard) {
	            return false;
	          }
	        }

	        // skip luhn for UnionPay
	        unionPay = {
	          number: $.inArray(cardNumber.length, cards.unionPay.length) !== -1,
	          pattern: cardNumber.search(cards.unionPay.pattern) !== -1
	        };
	        if (unionPay.number && unionPay.pattern) {
	          return true;
	        }

	        // verify luhn, adapted from  <https://gist.github.com/2134376>
	        var length = cardNumber.length,
	            multiple = 0,
	            producedValue = [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [0, 2, 4, 6, 8, 1, 3, 5, 7, 9]],
	            sum = 0;
	        while (length--) {
	          sum += producedValue[multiple][parseInt(cardNumber.charAt(length), 10)];
	          multiple ^= 1;
	        }
	        return sum % 10 === 0 && sum > 0;
	      },

	      minCount: function minCount(value, _minCount) {
	        if (_minCount == 0) {
	          return true;
	        }
	        if (_minCount == 1) {
	          return value !== '';
	        }
	        return value.split(',').length >= _minCount;
	      },

	      exactCount: function exactCount(value, _exactCount) {
	        if (_exactCount == 0) {
	          return value === '';
	        }
	        if (_exactCount == 1) {
	          return value !== '' && value.search(',') === -1;
	        }
	        return value.split(',').length == _exactCount;
	      },

	      maxCount: function maxCount(value, _maxCount) {
	        if (_maxCount == 0) {
	          return false;
	        }
	        if (_maxCount == 1) {
	          return value.search(',') === -1;
	        }
	        return value.split(',').length <= _maxCount;
	      }
	    }

	  };
	})(jQuery, window, document);
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(jQuery) {'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	/*!
	 * # Semantic UI - Transition
	 * http://github.com/semantic-org/semantic-ui/
	 *
	 *
	 * Released under the MIT license
	 * http://opensource.org/licenses/MIT
	 *
	 */

	;(function ($, window, document, undefined) {

	  "use strict";

	  window = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();

	  $.fn.transition = function () {
	    var $allModules = $(this),
	        moduleSelector = $allModules.selector || '',
	        time = new Date().getTime(),
	        performance = [],
	        moduleArguments = arguments,
	        query = moduleArguments[0],
	        queryArguments = [].slice.call(arguments, 1),
	        methodInvoked = typeof query === 'string',
	        requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {
	      setTimeout(callback, 0);
	    },
	        returnedValue;
	    $allModules.each(function (index) {
	      var $module = $(this),
	          element = this,


	      // set at run time
	      settings,
	          instance,
	          error,
	          className,
	          metadata,
	          animationEnd,
	          animationName,
	          namespace,
	          moduleNamespace,
	          eventNamespace,
	          module;

	      module = {

	        initialize: function initialize() {

	          // get full settings
	          settings = module.get.settings.apply(element, moduleArguments);

	          // shorthand
	          className = settings.className;
	          error = settings.error;
	          metadata = settings.metadata;

	          // define namespace
	          eventNamespace = '.' + settings.namespace;
	          moduleNamespace = 'module-' + settings.namespace;
	          instance = $module.data(moduleNamespace) || module;

	          // get vendor specific events
	          animationEnd = module.get.animationEndEvent();

	          if (methodInvoked) {
	            methodInvoked = module.invoke(query);
	          }

	          // method not invoked, lets run an animation
	          if (methodInvoked === false) {
	            module.verbose('Converted arguments into settings object', settings);
	            if (settings.interval) {
	              module.delay(settings.animate);
	            } else {
	              module.animate();
	            }
	            module.instantiate();
	          }
	        },

	        instantiate: function instantiate() {
	          module.verbose('Storing instance of module', module);
	          instance = module;
	          $module.data(moduleNamespace, instance);
	        },

	        destroy: function destroy() {
	          module.verbose('Destroying previous module for', element);
	          $module.removeData(moduleNamespace);
	        },

	        refresh: function refresh() {
	          module.verbose('Refreshing display type on next animation');
	          delete module.displayType;
	        },

	        forceRepaint: function forceRepaint() {
	          module.verbose('Forcing element repaint');
	          var $parentElement = $module.parent(),
	              $nextElement = $module.next();
	          if ($nextElement.length === 0) {
	            $module.detach().appendTo($parentElement);
	          } else {
	            $module.detach().insertBefore($nextElement);
	          }
	        },

	        repaint: function repaint() {
	          module.verbose('Repainting element');
	          var fakeAssignment = element.offsetWidth;
	        },

	        delay: function delay(interval) {
	          var direction = module.get.animationDirection(),
	              shouldReverse,
	              delay;
	          if (!direction) {
	            direction = module.can.transition() ? module.get.direction() : 'static';
	          }
	          interval = interval !== undefined ? interval : settings.interval;
	          shouldReverse = settings.reverse == 'auto' && direction == className.outward;
	          delay = shouldReverse || settings.reverse == true ? ($allModules.length - index) * settings.interval : index * settings.interval;
	          module.debug('Delaying animation by', delay);
	          setTimeout(module.animate, delay);
	        },

	        animate: function animate(overrideSettings) {
	          settings = overrideSettings || settings;
	          if (!module.is.supported()) {
	            module.error(error.support);
	            return false;
	          }
	          module.debug('Preparing animation', settings.animation);
	          if (module.is.animating()) {
	            if (settings.queue) {
	              if (!settings.allowRepeats && module.has.direction() && module.is.occurring() && module.queuing !== true) {
	                module.debug('Animation is currently occurring, preventing queueing same animation', settings.animation);
	              } else {
	                module.queue(settings.animation);
	              }
	              return false;
	            } else if (!settings.allowRepeats && module.is.occurring()) {
	              module.debug('Animation is already occurring, will not execute repeated animation', settings.animation);
	              return false;
	            } else {
	              module.debug('New animation started, completing previous early', settings.animation);
	              instance.complete();
	            }
	          }
	          if (module.can.animate()) {
	            module.set.animating(settings.animation);
	          } else {
	            module.error(error.noAnimation, settings.animation, element);
	          }
	        },

	        reset: function reset() {
	          module.debug('Resetting animation to beginning conditions');
	          module.remove.animationCallbacks();
	          module.restore.conditions();
	          module.remove.animating();
	        },

	        queue: function queue(animation) {
	          module.debug('Queueing animation of', animation);
	          module.queuing = true;
	          $module.one(animationEnd + '.queue' + eventNamespace, function () {
	            module.queuing = false;
	            module.repaint();
	            module.animate.apply(this, settings);
	          });
	        },

	        complete: function complete(event) {
	          module.debug('Animation complete', settings.animation);
	          module.remove.completeCallback();
	          module.remove.failSafe();
	          if (!module.is.looping()) {
	            if (module.is.outward()) {
	              module.verbose('Animation is outward, hiding element');
	              module.restore.conditions();
	              module.hide();
	            } else if (module.is.inward()) {
	              module.verbose('Animation is outward, showing element');
	              module.restore.conditions();
	              module.show();
	            } else {
	              module.verbose('Static animation completed');
	              module.restore.conditions();
	              settings.onComplete.call(element);
	            }
	          }
	        },

	        force: {
	          visible: function visible() {
	            var style = $module.attr('style'),
	                userStyle = module.get.userStyle(),
	                displayType = module.get.displayType(),
	                overrideStyle = userStyle + 'display: ' + displayType + ' !important;',
	                currentDisplay = $module.css('display'),
	                emptyStyle = style === undefined || style === '';
	            if (currentDisplay !== displayType) {
	              module.verbose('Overriding default display to show element', displayType);
	              $module.attr('style', overrideStyle);
	            } else if (emptyStyle) {
	              $module.removeAttr('style');
	            }
	          },
	          hidden: function hidden() {
	            var style = $module.attr('style'),
	                currentDisplay = $module.css('display'),
	                emptyStyle = style === undefined || style === '';
	            if (currentDisplay !== 'none' && !module.is.hidden()) {
	              module.verbose('Overriding default display to hide element');
	              $module.css('display', 'none');
	            } else if (emptyStyle) {
	              $module.removeAttr('style');
	            }
	          }
	        },

	        has: {
	          direction: function direction(animation) {
	            var hasDirection = false;
	            animation = animation || settings.animation;
	            if (typeof animation === 'string') {
	              animation = animation.split(' ');
	              $.each(animation, function (index, word) {
	                if (word === className.inward || word === className.outward) {
	                  hasDirection = true;
	                }
	              });
	            }
	            return hasDirection;
	          },
	          inlineDisplay: function inlineDisplay() {
	            var style = $module.attr('style') || '';
	            return $.isArray(style.match(/display.*?;/, ''));
	          }
	        },

	        set: {
	          animating: function animating(animation) {
	            var animationClass, direction;
	            // remove previous callbacks
	            module.remove.completeCallback();

	            // determine exact animation
	            animation = animation || settings.animation;
	            animationClass = module.get.animationClass(animation);

	            // save animation class in cache to restore class names
	            module.save.animation(animationClass);

	            // override display if necessary so animation appears visibly
	            module.force.visible();

	            module.remove.hidden();
	            module.remove.direction();

	            module.start.animation(animationClass);
	          },
	          duration: function duration(animationName, _duration) {
	            _duration = _duration || settings.duration;
	            _duration = typeof _duration == 'number' ? _duration + 'ms' : _duration;
	            if (_duration || _duration === 0) {
	              module.verbose('Setting animation duration', _duration);
	              $module.css({
	                'animation-duration': _duration
	              });
	            }
	          },
	          direction: function direction(_direction) {
	            _direction = _direction || module.get.direction();
	            if (_direction == className.inward) {
	              module.set.inward();
	            } else {
	              module.set.outward();
	            }
	          },
	          looping: function looping() {
	            module.debug('Transition set to loop');
	            $module.addClass(className.looping);
	          },
	          hidden: function hidden() {
	            $module.addClass(className.transition).addClass(className.hidden);
	          },
	          inward: function inward() {
	            module.debug('Setting direction to inward');
	            $module.removeClass(className.outward).addClass(className.inward);
	          },
	          outward: function outward() {
	            module.debug('Setting direction to outward');
	            $module.removeClass(className.inward).addClass(className.outward);
	          },
	          visible: function visible() {
	            $module.addClass(className.transition).addClass(className.visible);
	          }
	        },

	        start: {
	          animation: function animation(animationClass) {
	            animationClass = animationClass || module.get.animationClass();
	            module.debug('Starting tween', animationClass);
	            $module.addClass(animationClass).one(animationEnd + '.complete' + eventNamespace, module.complete);
	            if (settings.useFailSafe) {
	              module.add.failSafe();
	            }
	            module.set.duration(settings.duration);
	            settings.onStart.call(element);
	          }
	        },

	        save: {
	          animation: function animation(_animation) {
	            if (!module.cache) {
	              module.cache = {};
	            }
	            module.cache.animation = _animation;
	          },
	          displayType: function displayType(_displayType) {
	            if (_displayType !== 'none') {
	              $module.data(metadata.displayType, _displayType);
	            }
	          },
	          transitionExists: function transitionExists(animation, exists) {
	            $.fn.transition.exists[animation] = exists;
	            module.verbose('Saving existence of transition', animation, exists);
	          }
	        },

	        restore: {
	          conditions: function conditions() {
	            var animation = module.get.currentAnimation();
	            if (animation) {
	              $module.removeClass(animation);
	              module.verbose('Removing animation class', module.cache);
	            }
	            module.remove.duration();
	          }
	        },

	        add: {
	          failSafe: function failSafe() {
	            var duration = module.get.duration();
	            module.timer = setTimeout(function () {
	              $module.triggerHandler(animationEnd);
	            }, duration + settings.failSafeDelay);
	            module.verbose('Adding fail safe timer', module.timer);
	          }
	        },

	        remove: {
	          animating: function animating() {
	            $module.removeClass(className.animating);
	          },
	          animationCallbacks: function animationCallbacks() {
	            module.remove.queueCallback();
	            module.remove.completeCallback();
	          },
	          queueCallback: function queueCallback() {
	            $module.off('.queue' + eventNamespace);
	          },
	          completeCallback: function completeCallback() {
	            $module.off('.complete' + eventNamespace);
	          },
	          display: function display() {
	            $module.css('display', '');
	          },
	          direction: function direction() {
	            $module.removeClass(className.inward).removeClass(className.outward);
	          },
	          duration: function duration() {
	            $module.css('animation-duration', '');
	          },
	          failSafe: function failSafe() {
	            module.verbose('Removing fail safe timer', module.timer);
	            if (module.timer) {
	              clearTimeout(module.timer);
	            }
	          },
	          hidden: function hidden() {
	            $module.removeClass(className.hidden);
	          },
	          visible: function visible() {
	            $module.removeClass(className.visible);
	          },
	          looping: function looping() {
	            module.debug('Transitions are no longer looping');
	            if (module.is.looping()) {
	              module.reset();
	              $module.removeClass(className.looping);
	            }
	          },
	          transition: function transition() {
	            $module.removeClass(className.visible).removeClass(className.hidden);
	          }
	        },
	        get: {
	          settings: function settings(animation, duration, onComplete) {
	            // single settings object
	            if ((typeof animation === 'undefined' ? 'undefined' : _typeof(animation)) == 'object') {
	              return $.extend(true, {}, $.fn.transition.settings, animation);
	            }
	            // all arguments provided
	            else if (typeof onComplete == 'function') {
	                return $.extend({}, $.fn.transition.settings, {
	                  animation: animation,
	                  onComplete: onComplete,
	                  duration: duration
	                });
	              }
	              // only duration provided
	              else if (typeof duration == 'string' || typeof duration == 'number') {
	                  return $.extend({}, $.fn.transition.settings, {
	                    animation: animation,
	                    duration: duration
	                  });
	                }
	                // duration is actually settings object
	                else if ((typeof duration === 'undefined' ? 'undefined' : _typeof(duration)) == 'object') {
	                    return $.extend({}, $.fn.transition.settings, duration, {
	                      animation: animation
	                    });
	                  }
	                  // duration is actually callback
	                  else if (typeof duration == 'function') {
	                      return $.extend({}, $.fn.transition.settings, {
	                        animation: animation,
	                        onComplete: duration
	                      });
	                    }
	                    // only animation provided
	                    else {
	                        return $.extend({}, $.fn.transition.settings, {
	                          animation: animation
	                        });
	                      }
	          },
	          animationClass: function animationClass(animation) {
	            var animationClass = animation || settings.animation,
	                directionClass = module.can.transition() && !module.has.direction() ? module.get.direction() + ' ' : '';
	            return className.animating + ' ' + className.transition + ' ' + directionClass + animationClass;
	          },
	          currentAnimation: function currentAnimation() {
	            return module.cache && module.cache.animation !== undefined ? module.cache.animation : false;
	          },
	          currentDirection: function currentDirection() {
	            return module.is.inward() ? className.inward : className.outward;
	          },
	          direction: function direction() {
	            return module.is.hidden() || !module.is.visible() ? className.inward : className.outward;
	          },
	          animationDirection: function animationDirection(animation) {
	            var direction;
	            animation = animation || settings.animation;
	            if (typeof animation === 'string') {
	              animation = animation.split(' ');
	              // search animation name for out/in class
	              $.each(animation, function (index, word) {
	                if (word === className.inward) {
	                  direction = className.inward;
	                } else if (word === className.outward) {
	                  direction = className.outward;
	                }
	              });
	            }
	            // return found direction
	            if (direction) {
	              return direction;
	            }
	            return false;
	          },
	          duration: function duration(_duration2) {
	            _duration2 = _duration2 || settings.duration;
	            if (_duration2 === false) {
	              _duration2 = $module.css('animation-duration') || 0;
	            }
	            return typeof _duration2 === 'string' ? _duration2.indexOf('ms') > -1 ? parseFloat(_duration2) : parseFloat(_duration2) * 1000 : _duration2;
	          },
	          displayType: function displayType() {
	            if (settings.displayType) {
	              return settings.displayType;
	            }
	            if ($module.data(metadata.displayType) === undefined) {
	              // create fake element to determine display state
	              module.can.transition(true);
	            }
	            return $module.data(metadata.displayType);
	          },
	          userStyle: function userStyle(style) {
	            style = style || $module.attr('style') || '';
	            return style.replace(/display.*?;/, '');
	          },
	          transitionExists: function transitionExists(animation) {
	            return $.fn.transition.exists[animation];
	          },
	          animationStartEvent: function animationStartEvent() {
	            var element = document.createElement('div'),
	                animations = {
	              'animation': 'animationstart',
	              'OAnimation': 'oAnimationStart',
	              'MozAnimation': 'mozAnimationStart',
	              'WebkitAnimation': 'webkitAnimationStart'
	            },
	                animation;
	            for (animation in animations) {
	              if (element.style[animation] !== undefined) {
	                return animations[animation];
	              }
	            }
	            return false;
	          },
	          animationEndEvent: function animationEndEvent() {
	            var element = document.createElement('div'),
	                animations = {
	              'animation': 'animationend',
	              'OAnimation': 'oAnimationEnd',
	              'MozAnimation': 'mozAnimationEnd',
	              'WebkitAnimation': 'webkitAnimationEnd'
	            },
	                animation;
	            for (animation in animations) {
	              if (element.style[animation] !== undefined) {
	                return animations[animation];
	              }
	            }
	            return false;
	          }

	        },

	        can: {
	          transition: function transition(forced) {
	            var animation = settings.animation,
	                transitionExists = module.get.transitionExists(animation),
	                elementClass,
	                tagName,
	                $clone,
	                currentAnimation,
	                inAnimation,
	                directionExists,
	                displayType;
	            if (transitionExists === undefined || forced) {
	              module.verbose('Determining whether animation exists');
	              elementClass = $module.attr('class');
	              tagName = $module.prop('tagName');

	              $clone = $('<' + tagName + ' />').addClass(elementClass).insertAfter($module);
	              currentAnimation = $clone.addClass(animation).removeClass(className.inward).removeClass(className.outward).addClass(className.animating).addClass(className.transition).css('animationName');
	              inAnimation = $clone.addClass(className.inward).css('animationName');
	              displayType = $clone.attr('class', elementClass).removeAttr('style').removeClass(className.hidden).removeClass(className.visible).show().css('display');
	              module.verbose('Determining final display state', displayType);
	              module.save.displayType(displayType);

	              $clone.remove();
	              if (currentAnimation != inAnimation) {
	                module.debug('Direction exists for animation', animation);
	                directionExists = true;
	              } else if (currentAnimation == 'none' || !currentAnimation) {
	                module.debug('No animation defined in css', animation);
	                return;
	              } else {
	                module.debug('Static animation found', animation, displayType);
	                directionExists = false;
	              }
	              module.save.transitionExists(animation, directionExists);
	            }
	            return transitionExists !== undefined ? transitionExists : directionExists;
	          },
	          animate: function animate() {
	            // can transition does not return a value if animation does not exist
	            return module.can.transition() !== undefined;
	          }
	        },

	        is: {
	          animating: function animating() {
	            return $module.hasClass(className.animating);
	          },
	          inward: function inward() {
	            return $module.hasClass(className.inward);
	          },
	          outward: function outward() {
	            return $module.hasClass(className.outward);
	          },
	          looping: function looping() {
	            return $module.hasClass(className.looping);
	          },
	          occurring: function occurring(animation) {
	            animation = animation || settings.animation;
	            animation = '.' + animation.replace(' ', '.');
	            return $module.filter(animation).length > 0;
	          },
	          visible: function visible() {
	            return $module.is(':visible');
	          },
	          hidden: function hidden() {
	            return $module.css('visibility') === 'hidden';
	          },
	          supported: function supported() {
	            return animationEnd !== false;
	          }
	        },

	        hide: function hide() {
	          module.verbose('Hiding element');
	          if (module.is.animating()) {
	            module.reset();
	          }
	          element.blur(); // IE will trigger focus change if element is not blurred before hiding
	          module.remove.display();
	          module.remove.visible();
	          module.set.hidden();
	          module.force.hidden();
	          settings.onHide.call(element);
	          settings.onComplete.call(element);
	          // module.repaint();
	        },

	        show: function show(display) {
	          module.verbose('Showing element', display);
	          module.remove.hidden();
	          module.set.visible();
	          module.force.visible();
	          settings.onShow.call(element);
	          settings.onComplete.call(element);
	          // module.repaint();
	        },

	        toggle: function toggle() {
	          if (module.is.visible()) {
	            module.hide();
	          } else {
	            module.show();
	          }
	        },

	        stop: function stop() {
	          module.debug('Stopping current animation');
	          $module.triggerHandler(animationEnd);
	        },

	        stopAll: function stopAll() {
	          module.debug('Stopping all animation');
	          module.remove.queueCallback();
	          $module.triggerHandler(animationEnd);
	        },

	        clear: {
	          queue: function queue() {
	            module.debug('Clearing animation queue');
	            module.remove.queueCallback();
	          }
	        },

	        enable: function enable() {
	          module.verbose('Starting animation');
	          $module.removeClass(className.disabled);
	        },

	        disable: function disable() {
	          module.debug('Stopping animation');
	          $module.addClass(className.disabled);
	        },

	        setting: function setting(name, value) {
	          module.debug('Changing setting', name, value);
	          if ($.isPlainObject(name)) {
	            $.extend(true, settings, name);
	          } else if (value !== undefined) {
	            if ($.isPlainObject(settings[name])) {
	              $.extend(true, settings[name], value);
	            } else {
	              settings[name] = value;
	            }
	          } else {
	            return settings[name];
	          }
	        },
	        internal: function internal(name, value) {
	          if ($.isPlainObject(name)) {
	            $.extend(true, module, name);
	          } else if (value !== undefined) {
	            module[name] = value;
	          } else {
	            return module[name];
	          }
	        },
	        debug: function debug() {
	          if (!settings.silent && settings.debug) {
	            if (settings.performance) {
	              module.performance.log(arguments);
	            } else {
	              module.debug = Function.prototype.bind.call(console.info, console, settings.name + ':');
	              module.debug.apply(console, arguments);
	            }
	          }
	        },
	        verbose: function verbose() {
	          if (!settings.silent && settings.verbose && settings.debug) {
	            if (settings.performance) {
	              module.performance.log(arguments);
	            } else {
	              module.verbose = Function.prototype.bind.call(console.info, console, settings.name + ':');
	              module.verbose.apply(console, arguments);
	            }
	          }
	        },
	        error: function error() {
	          if (!settings.silent) {
	            module.error = Function.prototype.bind.call(console.error, console, settings.name + ':');
	            module.error.apply(console, arguments);
	          }
	        },
	        performance: {
	          log: function log(message) {
	            var currentTime, executionTime, previousTime;
	            if (settings.performance) {
	              currentTime = new Date().getTime();
	              previousTime = time || currentTime;
	              executionTime = currentTime - previousTime;
	              time = currentTime;
	              performance.push({
	                'Name': message[0],
	                'Arguments': [].slice.call(message, 1) || '',
	                'Element': element,
	                'Execution Time': executionTime
	              });
	            }
	            clearTimeout(module.performance.timer);
	            module.performance.timer = setTimeout(module.performance.display, 500);
	          },
	          display: function display() {
	            var title = settings.name + ':',
	                totalTime = 0;
	            time = false;
	            clearTimeout(module.performance.timer);
	            $.each(performance, function (index, data) {
	              totalTime += data['Execution Time'];
	            });
	            title += ' ' + totalTime + 'ms';
	            if (moduleSelector) {
	              title += ' \'' + moduleSelector + '\'';
	            }
	            if ($allModules.length > 1) {
	              title += ' ' + '(' + $allModules.length + ')';
	            }
	            if ((console.group !== undefined || console.table !== undefined) && performance.length > 0) {
	              console.groupCollapsed(title);
	              if (console.table) {
	                console.table(performance);
	              } else {
	                $.each(performance, function (index, data) {
	                  console.log(data['Name'] + ': ' + data['Execution Time'] + 'ms');
	                });
	              }
	              console.groupEnd();
	            }
	            performance = [];
	          }
	        },
	        // modified for transition to return invoke success
	        invoke: function invoke(query, passedArguments, context) {
	          var object = instance,
	              maxDepth,
	              found,
	              response;
	          passedArguments = passedArguments || queryArguments;
	          context = element || context;
	          if (typeof query == 'string' && object !== undefined) {
	            query = query.split(/[\. ]/);
	            maxDepth = query.length - 1;
	            $.each(query, function (depth, value) {
	              var camelCaseValue = depth != maxDepth ? value + query[depth + 1].charAt(0).toUpperCase() + query[depth + 1].slice(1) : query;
	              if ($.isPlainObject(object[camelCaseValue]) && depth != maxDepth) {
	                object = object[camelCaseValue];
	              } else if (object[camelCaseValue] !== undefined) {
	                found = object[camelCaseValue];
	                return false;
	              } else if ($.isPlainObject(object[value]) && depth != maxDepth) {
	                object = object[value];
	              } else if (object[value] !== undefined) {
	                found = object[value];
	                return false;
	              } else {
	                return false;
	              }
	            });
	          }
	          if ($.isFunction(found)) {
	            response = found.apply(context, passedArguments);
	          } else if (found !== undefined) {
	            response = found;
	          }

	          if ($.isArray(returnedValue)) {
	            returnedValue.push(response);
	          } else if (returnedValue !== undefined) {
	            returnedValue = [returnedValue, response];
	          } else if (response !== undefined) {
	            returnedValue = response;
	          }
	          return found !== undefined ? found : false;
	        }
	      };
	      module.initialize();
	    });
	    return returnedValue !== undefined ? returnedValue : this;
	  };

	  // Records if CSS transition is available
	  $.fn.transition.exists = {};

	  $.fn.transition.settings = {

	    // module info
	    name: 'Transition',

	    // hide all output from this component regardless of other settings
	    silent: false,

	    // debug content outputted to console
	    debug: false,

	    // verbose debug output
	    verbose: false,

	    // performance data output
	    performance: true,

	    // event namespace
	    namespace: 'transition',

	    // delay between animations in group
	    interval: 0,

	    // whether group animations should be reversed
	    reverse: 'auto',

	    // animation callback event
	    onStart: function onStart() {},
	    onComplete: function onComplete() {},
	    onShow: function onShow() {},
	    onHide: function onHide() {},

	    // whether timeout should be used to ensure callback fires in cases animationend does not
	    useFailSafe: true,

	    // delay in ms for fail safe
	    failSafeDelay: 100,

	    // whether EXACT animation can occur twice in a row
	    allowRepeats: false,

	    // Override final display type on visible
	    displayType: false,

	    // animation duration
	    animation: 'fade',
	    duration: false,

	    // new animations will occur after previous ones
	    queue: true,

	    metadata: {
	      displayType: 'display'
	    },

	    className: {
	      animating: 'animating',
	      disabled: 'disabled',
	      hidden: 'hidden',
	      inward: 'in',
	      loading: 'loading',
	      looping: 'looping',
	      outward: 'out',
	      transition: 'transition',
	      visible: 'visible'
	    },

	    // possible errors
	    error: {
	      noAnimation: 'Element is no longer attached to DOM. Unable to animate.  Use silent setting to surpress this warning in production.',
	      repeated: 'That animation is already occurring, cancelling repeated animation',
	      method: 'The method you called is not defined',
	      support: 'This browser does not support CSS animations'
	    }

	  };
	})(jQuery, window, document);
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _modelEndpoint = __webpack_require__(11);

	var _modelEndpoint2 = _interopRequireDefault(_modelEndpoint);

	var _httpFetch = __webpack_require__(19);

	var _httpFetch2 = _interopRequireDefault(_httpFetch);

	var _serviceHttp = __webpack_require__(24);

	var _serviceHttp2 = _interopRequireDefault(_serviceHttp);

	var _modelDecorator = __webpack_require__(25);

	var _httpRequest = __webpack_require__(26);

	var _httpRequest2 = _interopRequireDefault(_httpRequest);

	var _modelScope = __webpack_require__(27);

	var _modelScope2 = _interopRequireDefault(_modelScope);

	var instances = [];

	function restful(baseUrl, httpBackend) {
	    var rootScope = (0, _modelScope2['default'])();
	    rootScope.assign('config', 'entityIdentifier', 'id');
	    if (!baseUrl && typeof window !== 'undefined' && window.location) {
	        rootScope.set('url', window.location.protocol + '//' + window.location.host);
	    } else {
	        rootScope.set('url', baseUrl);
	    }

	    var rootEndpoint = (0, _modelDecorator.member)((0, _modelEndpoint2['default'])((0, _serviceHttp2['default'])(httpBackend))(rootScope));

	    instances.push(rootEndpoint);

	    return rootEndpoint;
	}

	restful._instances = function () {
	    return instances;
	};
	restful._flush = function () {
	    return instances.length = 0;
	};

	exports.fetchBackend = _httpFetch2['default'];
	exports.requestBackend = _httpRequest2['default'];
	exports['default'] = restful;

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _objectAssign = __webpack_require__(12);

	var _objectAssign2 = _interopRequireDefault(_objectAssign);

	var _response = __webpack_require__(13);

	var _response2 = _interopRequireDefault(_response);

	var _immutable = __webpack_require__(15);

	var _utilSerialize = __webpack_require__(16);

	var _utilSerialize2 = _interopRequireDefault(_utilSerialize);

	/* eslint-disable new-cap */

	exports['default'] = function (request) {
	    return function endpointFactory(scope) {
	        scope.on('error', function () {
	            return true;
	        }); // Add a default error listener to prevent unwanted exception
	        var endpoint = {}; // Persists reference

	        function _generateRequestConfig(method, data, params, headers) {
	            var config = (0, _immutable.Map)({
	                errorInterceptors: (0, _immutable.List)(scope.get('errorInterceptors')),
	                headers: (0, _immutable.Map)(scope.get('headers')).mergeDeep((0, _immutable.Map)(headers)),
	                method: method,
	                params: params,
	                requestInterceptors: (0, _immutable.List)(scope.get('requestInterceptors')),
	                responseInterceptors: (0, _immutable.List)(scope.get('responseInterceptors')),
	                url: scope.get('url')
	            });

	            if (data) {
	                if (!config.hasIn(['headers', 'Content-Type'])) {
	                    config = config.setIn(['headers', 'Content-Type'], 'application/json;charset=UTF-8');
	                }

	                config = config.set('data', (0, _immutable.fromJS)(data));
	            }

	            return config;
	        }

	        function _onResponse(config, rawResponse) {
	            var response = (0, _response2['default'])(rawResponse, endpoint);
	            scope.emit('response', response, (0, _utilSerialize2['default'])(config));
	            return response;
	        }

	        function _onError(config, error) {
	            scope.emit('error', error, (0, _utilSerialize2['default'])(config));
	            throw error;
	        }

	        function _httpMethodFactory(method) {
	            var expectData = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

	            var emitter = function emitter() {
	                scope.emit.apply(scope, arguments);
	            };

	            if (expectData) {
	                return function (data) {
	                    var params = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	                    var headers = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

	                    var config = _generateRequestConfig(method, data, params, headers);
	                    return request(config, emitter).then(function (rawResponse) {
	                        return _onResponse(config, rawResponse);
	                    }, function (rawResponse) {
	                        return _onError(config, rawResponse);
	                    });
	                };
	            }

	            return function () {
	                var params = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
	                var headers = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

	                var config = _generateRequestConfig(method, null, params, headers);
	                return request(config, emitter).then(function (rawResponse) {
	                    return _onResponse(config, rawResponse);
	                }, function (error) {
	                    return _onError(config, error);
	                });
	            };
	        }

	        function addInterceptor(type) {
	            return function (interceptor) {
	                scope.push(type + 'Interceptors', interceptor);

	                return endpoint;
	            };
	        }

	        (0, _objectAssign2['default'])(endpoint, {
	            addErrorInterceptor: addInterceptor('error'),
	            addRequestInterceptor: addInterceptor('request'),
	            addResponseInterceptor: addInterceptor('response'),
	            'delete': _httpMethodFactory('DELETE'),
	            identifier: function identifier(newIdentifier) {
	                if (newIdentifier === undefined) {
	                    return scope.get('config').get('entityIdentifier');
	                }

	                scope.assign('config', 'entityIdentifier', newIdentifier);

	                return endpoint;
	            },
	            get: _httpMethodFactory('GET', false),
	            head: _httpMethodFactory('HEAD', false),
	            header: function header(key, value) {
	                return scope.assign('headers', key, value);
	            },
	            headers: function headers() {
	                return scope.get('headers');
	            },
	            'new': function _new(url) {
	                var childScope = scope['new']();
	                childScope.set('url', url);

	                return endpointFactory(childScope);
	            },
	            on: scope.on,
	            once: scope.once,
	            patch: _httpMethodFactory('PATCH'),
	            post: _httpMethodFactory('POST'),
	            put: _httpMethodFactory('PUT'),
	            url: function url() {
	                return scope.get('url');
	            }
	        });

	        return endpoint;
	    };
	};

	module.exports = exports['default'];

/***/ },
/* 12 */
/***/ function(module, exports) {

	'use strict';

	function ToObject(val) {
		if (val == null) {
			throw new TypeError('Object.assign cannot be called with null or undefined');
		}

		return Object(val);
	}

	module.exports = Object.assign || function (target, source) {
		var from;
		var keys;
		var to = ToObject(target);

		for (var s = 1; s < arguments.length; s++) {
			from = arguments[s];
			keys = Object.keys(Object(from));

			for (var i = 0; i < keys.length; i++) {
				to[keys[i]] = from[keys[i]];
			}
		}

		return to;
	};


/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _entity = __webpack_require__(14);

	var _entity2 = _interopRequireDefault(_entity);

	var _immutable = __webpack_require__(15);

	var _utilSerialize = __webpack_require__(16);

	var _utilSerialize2 = _interopRequireDefault(_utilSerialize);

	var _warning = __webpack_require__(17);

	var _warning2 = _interopRequireDefault(_warning);

	/* eslint-disable new-cap */

	exports['default'] = function (response, decoratedEndpoint) {
	    var identifier = decoratedEndpoint.identifier();

	    return {
	        statusCode: function statusCode() {
	            return (0, _utilSerialize2['default'])(response.get('statusCode'));
	        },
	        body: function body() {
	            var hydrate = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];

	            var data = response.get('data');

	            if (!hydrate) {
	                return (0, _utilSerialize2['default'])(data);
	            }

	            if (_immutable.List.isList(data)) {
	                (0, _warning2['default'])(response.get('method') !== 'get' || !decoratedEndpoint.all, 'Unexpected array as response, you should use all method for that');

	                return (0, _utilSerialize2['default'])(data.map(function (datum) {
	                    var id = datum.get(identifier);
	                    return (0, _entity2['default'])((0, _utilSerialize2['default'])(datum), decoratedEndpoint.custom('' + id));
	                }));
	            }

	            (0, _warning2['default'])(response.get('method') !== 'get' || decoratedEndpoint.all, 'Expected array as response, you should use one method for that');

	            return (0, _entity2['default'])((0, _utilSerialize2['default'])(data), decoratedEndpoint);
	        },
	        headers: function headers() {
	            return (0, _utilSerialize2['default'])(response.get('headers'));
	        }
	    };
	};

	module.exports = exports['default'];

/***/ },
/* 14 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	exports["default"] = function (_data, endpoint) {
	    return {
	        all: endpoint.all,
	        custom: endpoint.custom,
	        data: function data() {
	            return _data;
	        },
	        "delete": endpoint["delete"],
	        id: function id() {
	            return _data[endpoint.identifier()];
	        },
	        one: endpoint.one,
	        save: function save() {
	            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	                args[_key] = arguments[_key];
	            }

	            return endpoint.put.apply(endpoint, [_data].concat(args));
	        },
	        url: endpoint.url
	    };
	};

	module.exports = exports["default"];

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 *  Copyright (c) 2014-2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */

	(function (global, factory) {
	   true ? module.exports = factory() :
	  typeof define === 'function' && define.amd ? define(factory) :
	  global.Immutable = factory();
	}(this, function () { 'use strict';var SLICE$0 = Array.prototype.slice;

	  function createClass(ctor, superClass) {
	    if (superClass) {
	      ctor.prototype = Object.create(superClass.prototype);
	    }
	    ctor.prototype.constructor = ctor;
	  }

	  function Iterable(value) {
	      return isIterable(value) ? value : Seq(value);
	    }


	  createClass(KeyedIterable, Iterable);
	    function KeyedIterable(value) {
	      return isKeyed(value) ? value : KeyedSeq(value);
	    }


	  createClass(IndexedIterable, Iterable);
	    function IndexedIterable(value) {
	      return isIndexed(value) ? value : IndexedSeq(value);
	    }


	  createClass(SetIterable, Iterable);
	    function SetIterable(value) {
	      return isIterable(value) && !isAssociative(value) ? value : SetSeq(value);
	    }



	  function isIterable(maybeIterable) {
	    return !!(maybeIterable && maybeIterable[IS_ITERABLE_SENTINEL]);
	  }

	  function isKeyed(maybeKeyed) {
	    return !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL]);
	  }

	  function isIndexed(maybeIndexed) {
	    return !!(maybeIndexed && maybeIndexed[IS_INDEXED_SENTINEL]);
	  }

	  function isAssociative(maybeAssociative) {
	    return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);
	  }

	  function isOrdered(maybeOrdered) {
	    return !!(maybeOrdered && maybeOrdered[IS_ORDERED_SENTINEL]);
	  }

	  Iterable.isIterable = isIterable;
	  Iterable.isKeyed = isKeyed;
	  Iterable.isIndexed = isIndexed;
	  Iterable.isAssociative = isAssociative;
	  Iterable.isOrdered = isOrdered;

	  Iterable.Keyed = KeyedIterable;
	  Iterable.Indexed = IndexedIterable;
	  Iterable.Set = SetIterable;


	  var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
	  var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
	  var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';
	  var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';

	  // Used for setting prototype methods that IE8 chokes on.
	  var DELETE = 'delete';

	  // Constants describing the size of trie nodes.
	  var SHIFT = 5; // Resulted in best performance after ______?
	  var SIZE = 1 << SHIFT;
	  var MASK = SIZE - 1;

	  // A consistent shared value representing "not set" which equals nothing other
	  // than itself, and nothing that could be provided externally.
	  var NOT_SET = {};

	  // Boolean references, Rough equivalent of `bool &`.
	  var CHANGE_LENGTH = { value: false };
	  var DID_ALTER = { value: false };

	  function MakeRef(ref) {
	    ref.value = false;
	    return ref;
	  }

	  function SetRef(ref) {
	    ref && (ref.value = true);
	  }

	  // A function which returns a value representing an "owner" for transient writes
	  // to tries. The return value will only ever equal itself, and will not equal
	  // the return of any subsequent call of this function.
	  function OwnerID() {}

	  // http://jsperf.com/copy-array-inline
	  function arrCopy(arr, offset) {
	    offset = offset || 0;
	    var len = Math.max(0, arr.length - offset);
	    var newArr = new Array(len);
	    for (var ii = 0; ii < len; ii++) {
	      newArr[ii] = arr[ii + offset];
	    }
	    return newArr;
	  }

	  function ensureSize(iter) {
	    if (iter.size === undefined) {
	      iter.size = iter.__iterate(returnTrue);
	    }
	    return iter.size;
	  }

	  function wrapIndex(iter, index) {
	    // This implements "is array index" which the ECMAString spec defines as:
	    //
	    //     A String property name P is an array index if and only if
	    //     ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal
	    //     to 2^32−1.
	    //
	    // http://www.ecma-international.org/ecma-262/6.0/#sec-array-exotic-objects
	    if (typeof index !== 'number') {
	      var uint32Index = index >>> 0; // N >>> 0 is shorthand for ToUint32
	      if ('' + uint32Index !== index || uint32Index === 4294967295) {
	        return NaN;
	      }
	      index = uint32Index;
	    }
	    return index < 0 ? ensureSize(iter) + index : index;
	  }

	  function returnTrue() {
	    return true;
	  }

	  function wholeSlice(begin, end, size) {
	    return (begin === 0 || (size !== undefined && begin <= -size)) &&
	      (end === undefined || (size !== undefined && end >= size));
	  }

	  function resolveBegin(begin, size) {
	    return resolveIndex(begin, size, 0);
	  }

	  function resolveEnd(end, size) {
	    return resolveIndex(end, size, size);
	  }

	  function resolveIndex(index, size, defaultIndex) {
	    return index === undefined ?
	      defaultIndex :
	      index < 0 ?
	        Math.max(0, size + index) :
	        size === undefined ?
	          index :
	          Math.min(size, index);
	  }

	  /* global Symbol */

	  var ITERATE_KEYS = 0;
	  var ITERATE_VALUES = 1;
	  var ITERATE_ENTRIES = 2;

	  var REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
	  var FAUX_ITERATOR_SYMBOL = '@@iterator';

	  var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;


	  function Iterator(next) {
	      this.next = next;
	    }

	    Iterator.prototype.toString = function() {
	      return '[Iterator]';
	    };


	  Iterator.KEYS = ITERATE_KEYS;
	  Iterator.VALUES = ITERATE_VALUES;
	  Iterator.ENTRIES = ITERATE_ENTRIES;

	  Iterator.prototype.inspect =
	  Iterator.prototype.toSource = function () { return this.toString(); }
	  Iterator.prototype[ITERATOR_SYMBOL] = function () {
	    return this;
	  };


	  function iteratorValue(type, k, v, iteratorResult) {
	    var value = type === 0 ? k : type === 1 ? v : [k, v];
	    iteratorResult ? (iteratorResult.value = value) : (iteratorResult = {
	      value: value, done: false
	    });
	    return iteratorResult;
	  }

	  function iteratorDone() {
	    return { value: undefined, done: true };
	  }

	  function hasIterator(maybeIterable) {
	    return !!getIteratorFn(maybeIterable);
	  }

	  function isIterator(maybeIterator) {
	    return maybeIterator && typeof maybeIterator.next === 'function';
	  }

	  function getIterator(iterable) {
	    var iteratorFn = getIteratorFn(iterable);
	    return iteratorFn && iteratorFn.call(iterable);
	  }

	  function getIteratorFn(iterable) {
	    var iteratorFn = iterable && (
	      (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL]) ||
	      iterable[FAUX_ITERATOR_SYMBOL]
	    );
	    if (typeof iteratorFn === 'function') {
	      return iteratorFn;
	    }
	  }

	  function isArrayLike(value) {
	    return value && typeof value.length === 'number';
	  }

	  createClass(Seq, Iterable);
	    function Seq(value) {
	      return value === null || value === undefined ? emptySequence() :
	        isIterable(value) ? value.toSeq() : seqFromValue(value);
	    }

	    Seq.of = function(/*...values*/) {
	      return Seq(arguments);
	    };

	    Seq.prototype.toSeq = function() {
	      return this;
	    };

	    Seq.prototype.toString = function() {
	      return this.__toString('Seq {', '}');
	    };

	    Seq.prototype.cacheResult = function() {
	      if (!this._cache && this.__iterateUncached) {
	        this._cache = this.entrySeq().toArray();
	        this.size = this._cache.length;
	      }
	      return this;
	    };

	    // abstract __iterateUncached(fn, reverse)

	    Seq.prototype.__iterate = function(fn, reverse) {
	      return seqIterate(this, fn, reverse, true);
	    };

	    // abstract __iteratorUncached(type, reverse)

	    Seq.prototype.__iterator = function(type, reverse) {
	      return seqIterator(this, type, reverse, true);
	    };



	  createClass(KeyedSeq, Seq);
	    function KeyedSeq(value) {
	      return value === null || value === undefined ?
	        emptySequence().toKeyedSeq() :
	        isIterable(value) ?
	          (isKeyed(value) ? value.toSeq() : value.fromEntrySeq()) :
	          keyedSeqFromValue(value);
	    }

	    KeyedSeq.prototype.toKeyedSeq = function() {
	      return this;
	    };



	  createClass(IndexedSeq, Seq);
	    function IndexedSeq(value) {
	      return value === null || value === undefined ? emptySequence() :
	        !isIterable(value) ? indexedSeqFromValue(value) :
	        isKeyed(value) ? value.entrySeq() : value.toIndexedSeq();
	    }

	    IndexedSeq.of = function(/*...values*/) {
	      return IndexedSeq(arguments);
	    };

	    IndexedSeq.prototype.toIndexedSeq = function() {
	      return this;
	    };

	    IndexedSeq.prototype.toString = function() {
	      return this.__toString('Seq [', ']');
	    };

	    IndexedSeq.prototype.__iterate = function(fn, reverse) {
	      return seqIterate(this, fn, reverse, false);
	    };

	    IndexedSeq.prototype.__iterator = function(type, reverse) {
	      return seqIterator(this, type, reverse, false);
	    };



	  createClass(SetSeq, Seq);
	    function SetSeq(value) {
	      return (
	        value === null || value === undefined ? emptySequence() :
	        !isIterable(value) ? indexedSeqFromValue(value) :
	        isKeyed(value) ? value.entrySeq() : value
	      ).toSetSeq();
	    }

	    SetSeq.of = function(/*...values*/) {
	      return SetSeq(arguments);
	    };

	    SetSeq.prototype.toSetSeq = function() {
	      return this;
	    };



	  Seq.isSeq = isSeq;
	  Seq.Keyed = KeyedSeq;
	  Seq.Set = SetSeq;
	  Seq.Indexed = IndexedSeq;

	  var IS_SEQ_SENTINEL = '@@__IMMUTABLE_SEQ__@@';

	  Seq.prototype[IS_SEQ_SENTINEL] = true;



	  createClass(ArraySeq, IndexedSeq);
	    function ArraySeq(array) {
	      this._array = array;
	      this.size = array.length;
	    }

	    ArraySeq.prototype.get = function(index, notSetValue) {
	      return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;
	    };

	    ArraySeq.prototype.__iterate = function(fn, reverse) {
	      var array = this._array;
	      var maxIndex = array.length - 1;
	      for (var ii = 0; ii <= maxIndex; ii++) {
	        if (fn(array[reverse ? maxIndex - ii : ii], ii, this) === false) {
	          return ii + 1;
	        }
	      }
	      return ii;
	    };

	    ArraySeq.prototype.__iterator = function(type, reverse) {
	      var array = this._array;
	      var maxIndex = array.length - 1;
	      var ii = 0;
	      return new Iterator(function() 
	        {return ii > maxIndex ?
	          iteratorDone() :
	          iteratorValue(type, ii, array[reverse ? maxIndex - ii++ : ii++])}
	      );
	    };



	  createClass(ObjectSeq, KeyedSeq);
	    function ObjectSeq(object) {
	      var keys = Object.keys(object);
	      this._object = object;
	      this._keys = keys;
	      this.size = keys.length;
	    }

	    ObjectSeq.prototype.get = function(key, notSetValue) {
	      if (notSetValue !== undefined && !this.has(key)) {
	        return notSetValue;
	      }
	      return this._object[key];
	    };

	    ObjectSeq.prototype.has = function(key) {
	      return this._object.hasOwnProperty(key);
	    };

	    ObjectSeq.prototype.__iterate = function(fn, reverse) {
	      var object = this._object;
	      var keys = this._keys;
	      var maxIndex = keys.length - 1;
	      for (var ii = 0; ii <= maxIndex; ii++) {
	        var key = keys[reverse ? maxIndex - ii : ii];
	        if (fn(object[key], key, this) === false) {
	          return ii + 1;
	        }
	      }
	      return ii;
	    };

	    ObjectSeq.prototype.__iterator = function(type, reverse) {
	      var object = this._object;
	      var keys = this._keys;
	      var maxIndex = keys.length - 1;
	      var ii = 0;
	      return new Iterator(function()  {
	        var key = keys[reverse ? maxIndex - ii : ii];
	        return ii++ > maxIndex ?
	          iteratorDone() :
	          iteratorValue(type, key, object[key]);
	      });
	    };

	  ObjectSeq.prototype[IS_ORDERED_SENTINEL] = true;


	  createClass(IterableSeq, IndexedSeq);
	    function IterableSeq(iterable) {
	      this._iterable = iterable;
	      this.size = iterable.length || iterable.size;
	    }

	    IterableSeq.prototype.__iterateUncached = function(fn, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var iterable = this._iterable;
	      var iterator = getIterator(iterable);
	      var iterations = 0;
	      if (isIterator(iterator)) {
	        var step;
	        while (!(step = iterator.next()).done) {
	          if (fn(step.value, iterations++, this) === false) {
	            break;
	          }
	        }
	      }
	      return iterations;
	    };

	    IterableSeq.prototype.__iteratorUncached = function(type, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterable = this._iterable;
	      var iterator = getIterator(iterable);
	      if (!isIterator(iterator)) {
	        return new Iterator(iteratorDone);
	      }
	      var iterations = 0;
	      return new Iterator(function()  {
	        var step = iterator.next();
	        return step.done ? step : iteratorValue(type, iterations++, step.value);
	      });
	    };



	  createClass(IteratorSeq, IndexedSeq);
	    function IteratorSeq(iterator) {
	      this._iterator = iterator;
	      this._iteratorCache = [];
	    }

	    IteratorSeq.prototype.__iterateUncached = function(fn, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var iterator = this._iterator;
	      var cache = this._iteratorCache;
	      var iterations = 0;
	      while (iterations < cache.length) {
	        if (fn(cache[iterations], iterations++, this) === false) {
	          return iterations;
	        }
	      }
	      var step;
	      while (!(step = iterator.next()).done) {
	        var val = step.value;
	        cache[iterations] = val;
	        if (fn(val, iterations++, this) === false) {
	          break;
	        }
	      }
	      return iterations;
	    };

	    IteratorSeq.prototype.__iteratorUncached = function(type, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterator = this._iterator;
	      var cache = this._iteratorCache;
	      var iterations = 0;
	      return new Iterator(function()  {
	        if (iterations >= cache.length) {
	          var step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	          cache[iterations] = step.value;
	        }
	        return iteratorValue(type, iterations, cache[iterations++]);
	      });
	    };




	  // # pragma Helper functions

	  function isSeq(maybeSeq) {
	    return !!(maybeSeq && maybeSeq[IS_SEQ_SENTINEL]);
	  }

	  var EMPTY_SEQ;

	  function emptySequence() {
	    return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));
	  }

	  function keyedSeqFromValue(value) {
	    var seq =
	      Array.isArray(value) ? new ArraySeq(value).fromEntrySeq() :
	      isIterator(value) ? new IteratorSeq(value).fromEntrySeq() :
	      hasIterator(value) ? new IterableSeq(value).fromEntrySeq() :
	      typeof value === 'object' ? new ObjectSeq(value) :
	      undefined;
	    if (!seq) {
	      throw new TypeError(
	        'Expected Array or iterable object of [k, v] entries, '+
	        'or keyed object: ' + value
	      );
	    }
	    return seq;
	  }

	  function indexedSeqFromValue(value) {
	    var seq = maybeIndexedSeqFromValue(value);
	    if (!seq) {
	      throw new TypeError(
	        'Expected Array or iterable object of values: ' + value
	      );
	    }
	    return seq;
	  }

	  function seqFromValue(value) {
	    var seq = maybeIndexedSeqFromValue(value) ||
	      (typeof value === 'object' && new ObjectSeq(value));
	    if (!seq) {
	      throw new TypeError(
	        'Expected Array or iterable object of values, or keyed object: ' + value
	      );
	    }
	    return seq;
	  }

	  function maybeIndexedSeqFromValue(value) {
	    return (
	      isArrayLike(value) ? new ArraySeq(value) :
	      isIterator(value) ? new IteratorSeq(value) :
	      hasIterator(value) ? new IterableSeq(value) :
	      undefined
	    );
	  }

	  function seqIterate(seq, fn, reverse, useKeys) {
	    var cache = seq._cache;
	    if (cache) {
	      var maxIndex = cache.length - 1;
	      for (var ii = 0; ii <= maxIndex; ii++) {
	        var entry = cache[reverse ? maxIndex - ii : ii];
	        if (fn(entry[1], useKeys ? entry[0] : ii, seq) === false) {
	          return ii + 1;
	        }
	      }
	      return ii;
	    }
	    return seq.__iterateUncached(fn, reverse);
	  }

	  function seqIterator(seq, type, reverse, useKeys) {
	    var cache = seq._cache;
	    if (cache) {
	      var maxIndex = cache.length - 1;
	      var ii = 0;
	      return new Iterator(function()  {
	        var entry = cache[reverse ? maxIndex - ii : ii];
	        return ii++ > maxIndex ?
	          iteratorDone() :
	          iteratorValue(type, useKeys ? entry[0] : ii - 1, entry[1]);
	      });
	    }
	    return seq.__iteratorUncached(type, reverse);
	  }

	  function fromJS(json, converter) {
	    return converter ?
	      fromJSWith(converter, json, '', {'': json}) :
	      fromJSDefault(json);
	  }

	  function fromJSWith(converter, json, key, parentJSON) {
	    if (Array.isArray(json)) {
	      return converter.call(parentJSON, key, IndexedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));
	    }
	    if (isPlainObj(json)) {
	      return converter.call(parentJSON, key, KeyedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));
	    }
	    return json;
	  }

	  function fromJSDefault(json) {
	    if (Array.isArray(json)) {
	      return IndexedSeq(json).map(fromJSDefault).toList();
	    }
	    if (isPlainObj(json)) {
	      return KeyedSeq(json).map(fromJSDefault).toMap();
	    }
	    return json;
	  }

	  function isPlainObj(value) {
	    return value && (value.constructor === Object || value.constructor === undefined);
	  }

	  /**
	   * An extension of the "same-value" algorithm as [described for use by ES6 Map
	   * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)
	   *
	   * NaN is considered the same as NaN, however -0 and 0 are considered the same
	   * value, which is different from the algorithm described by
	   * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).
	   *
	   * This is extended further to allow Objects to describe the values they
	   * represent, by way of `valueOf` or `equals` (and `hashCode`).
	   *
	   * Note: because of this extension, the key equality of Immutable.Map and the
	   * value equality of Immutable.Set will differ from ES6 Map and Set.
	   *
	   * ### Defining custom values
	   *
	   * The easiest way to describe the value an object represents is by implementing
	   * `valueOf`. For example, `Date` represents a value by returning a unix
	   * timestamp for `valueOf`:
	   *
	   *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...
	   *     var date2 = new Date(1234567890000);
	   *     date1.valueOf(); // 1234567890000
	   *     assert( date1 !== date2 );
	   *     assert( Immutable.is( date1, date2 ) );
	   *
	   * Note: overriding `valueOf` may have other implications if you use this object
	   * where JavaScript expects a primitive, such as implicit string coercion.
	   *
	   * For more complex types, especially collections, implementing `valueOf` may
	   * not be performant. An alternative is to implement `equals` and `hashCode`.
	   *
	   * `equals` takes another object, presumably of similar type, and returns true
	   * if the it is equal. Equality is symmetrical, so the same result should be
	   * returned if this and the argument are flipped.
	   *
	   *     assert( a.equals(b) === b.equals(a) );
	   *
	   * `hashCode` returns a 32bit integer number representing the object which will
	   * be used to determine how to store the value object in a Map or Set. You must
	   * provide both or neither methods, one must not exist without the other.
	   *
	   * Also, an important relationship between these methods must be upheld: if two
	   * values are equal, they *must* return the same hashCode. If the values are not
	   * equal, they might have the same hashCode; this is called a hash collision,
	   * and while undesirable for performance reasons, it is acceptable.
	   *
	   *     if (a.equals(b)) {
	   *       assert( a.hashCode() === b.hashCode() );
	   *     }
	   *
	   * All Immutable collections implement `equals` and `hashCode`.
	   *
	   */
	  function is(valueA, valueB) {
	    if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {
	      return true;
	    }
	    if (!valueA || !valueB) {
	      return false;
	    }
	    if (typeof valueA.valueOf === 'function' &&
	        typeof valueB.valueOf === 'function') {
	      valueA = valueA.valueOf();
	      valueB = valueB.valueOf();
	      if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {
	        return true;
	      }
	      if (!valueA || !valueB) {
	        return false;
	      }
	    }
	    if (typeof valueA.equals === 'function' &&
	        typeof valueB.equals === 'function' &&
	        valueA.equals(valueB)) {
	      return true;
	    }
	    return false;
	  }

	  function deepEqual(a, b) {
	    if (a === b) {
	      return true;
	    }

	    if (
	      !isIterable(b) ||
	      a.size !== undefined && b.size !== undefined && a.size !== b.size ||
	      a.__hash !== undefined && b.__hash !== undefined && a.__hash !== b.__hash ||
	      isKeyed(a) !== isKeyed(b) ||
	      isIndexed(a) !== isIndexed(b) ||
	      isOrdered(a) !== isOrdered(b)
	    ) {
	      return false;
	    }

	    if (a.size === 0 && b.size === 0) {
	      return true;
	    }

	    var notAssociative = !isAssociative(a);

	    if (isOrdered(a)) {
	      var entries = a.entries();
	      return b.every(function(v, k)  {
	        var entry = entries.next().value;
	        return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));
	      }) && entries.next().done;
	    }

	    var flipped = false;

	    if (a.size === undefined) {
	      if (b.size === undefined) {
	        if (typeof a.cacheResult === 'function') {
	          a.cacheResult();
	        }
	      } else {
	        flipped = true;
	        var _ = a;
	        a = b;
	        b = _;
	      }
	    }

	    var allEqual = true;
	    var bSize = b.__iterate(function(v, k)  {
	      if (notAssociative ? !a.has(v) :
	          flipped ? !is(v, a.get(k, NOT_SET)) : !is(a.get(k, NOT_SET), v)) {
	        allEqual = false;
	        return false;
	      }
	    });

	    return allEqual && a.size === bSize;
	  }

	  createClass(Repeat, IndexedSeq);

	    function Repeat(value, times) {
	      if (!(this instanceof Repeat)) {
	        return new Repeat(value, times);
	      }
	      this._value = value;
	      this.size = times === undefined ? Infinity : Math.max(0, times);
	      if (this.size === 0) {
	        if (EMPTY_REPEAT) {
	          return EMPTY_REPEAT;
	        }
	        EMPTY_REPEAT = this;
	      }
	    }

	    Repeat.prototype.toString = function() {
	      if (this.size === 0) {
	        return 'Repeat []';
	      }
	      return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';
	    };

	    Repeat.prototype.get = function(index, notSetValue) {
	      return this.has(index) ? this._value : notSetValue;
	    };

	    Repeat.prototype.includes = function(searchValue) {
	      return is(this._value, searchValue);
	    };

	    Repeat.prototype.slice = function(begin, end) {
	      var size = this.size;
	      return wholeSlice(begin, end, size) ? this :
	        new Repeat(this._value, resolveEnd(end, size) - resolveBegin(begin, size));
	    };

	    Repeat.prototype.reverse = function() {
	      return this;
	    };

	    Repeat.prototype.indexOf = function(searchValue) {
	      if (is(this._value, searchValue)) {
	        return 0;
	      }
	      return -1;
	    };

	    Repeat.prototype.lastIndexOf = function(searchValue) {
	      if (is(this._value, searchValue)) {
	        return this.size;
	      }
	      return -1;
	    };

	    Repeat.prototype.__iterate = function(fn, reverse) {
	      for (var ii = 0; ii < this.size; ii++) {
	        if (fn(this._value, ii, this) === false) {
	          return ii + 1;
	        }
	      }
	      return ii;
	    };

	    Repeat.prototype.__iterator = function(type, reverse) {var this$0 = this;
	      var ii = 0;
	      return new Iterator(function() 
	        {return ii < this$0.size ? iteratorValue(type, ii++, this$0._value) : iteratorDone()}
	      );
	    };

	    Repeat.prototype.equals = function(other) {
	      return other instanceof Repeat ?
	        is(this._value, other._value) :
	        deepEqual(other);
	    };


	  var EMPTY_REPEAT;

	  function invariant(condition, error) {
	    if (!condition) throw new Error(error);
	  }

	  createClass(Range, IndexedSeq);

	    function Range(start, end, step) {
	      if (!(this instanceof Range)) {
	        return new Range(start, end, step);
	      }
	      invariant(step !== 0, 'Cannot step a Range by 0');
	      start = start || 0;
	      if (end === undefined) {
	        end = Infinity;
	      }
	      step = step === undefined ? 1 : Math.abs(step);
	      if (end < start) {
	        step = -step;
	      }
	      this._start = start;
	      this._end = end;
	      this._step = step;
	      this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);
	      if (this.size === 0) {
	        if (EMPTY_RANGE) {
	          return EMPTY_RANGE;
	        }
	        EMPTY_RANGE = this;
	      }
	    }

	    Range.prototype.toString = function() {
	      if (this.size === 0) {
	        return 'Range []';
	      }
	      return 'Range [ ' +
	        this._start + '...' + this._end +
	        (this._step > 1 ? ' by ' + this._step : '') +
	      ' ]';
	    };

	    Range.prototype.get = function(index, notSetValue) {
	      return this.has(index) ?
	        this._start + wrapIndex(this, index) * this._step :
	        notSetValue;
	    };

	    Range.prototype.includes = function(searchValue) {
	      var possibleIndex = (searchValue - this._start) / this._step;
	      return possibleIndex >= 0 &&
	        possibleIndex < this.size &&
	        possibleIndex === Math.floor(possibleIndex);
	    };

	    Range.prototype.slice = function(begin, end) {
	      if (wholeSlice(begin, end, this.size)) {
	        return this;
	      }
	      begin = resolveBegin(begin, this.size);
	      end = resolveEnd(end, this.size);
	      if (end <= begin) {
	        return new Range(0, 0);
	      }
	      return new Range(this.get(begin, this._end), this.get(end, this._end), this._step);
	    };

	    Range.prototype.indexOf = function(searchValue) {
	      var offsetValue = searchValue - this._start;
	      if (offsetValue % this._step === 0) {
	        var index = offsetValue / this._step;
	        if (index >= 0 && index < this.size) {
	          return index
	        }
	      }
	      return -1;
	    };

	    Range.prototype.lastIndexOf = function(searchValue) {
	      return this.indexOf(searchValue);
	    };

	    Range.prototype.__iterate = function(fn, reverse) {
	      var maxIndex = this.size - 1;
	      var step = this._step;
	      var value = reverse ? this._start + maxIndex * step : this._start;
	      for (var ii = 0; ii <= maxIndex; ii++) {
	        if (fn(value, ii, this) === false) {
	          return ii + 1;
	        }
	        value += reverse ? -step : step;
	      }
	      return ii;
	    };

	    Range.prototype.__iterator = function(type, reverse) {
	      var maxIndex = this.size - 1;
	      var step = this._step;
	      var value = reverse ? this._start + maxIndex * step : this._start;
	      var ii = 0;
	      return new Iterator(function()  {
	        var v = value;
	        value += reverse ? -step : step;
	        return ii > maxIndex ? iteratorDone() : iteratorValue(type, ii++, v);
	      });
	    };

	    Range.prototype.equals = function(other) {
	      return other instanceof Range ?
	        this._start === other._start &&
	        this._end === other._end &&
	        this._step === other._step :
	        deepEqual(this, other);
	    };


	  var EMPTY_RANGE;

	  createClass(Collection, Iterable);
	    function Collection() {
	      throw TypeError('Abstract');
	    }


	  createClass(KeyedCollection, Collection);function KeyedCollection() {}

	  createClass(IndexedCollection, Collection);function IndexedCollection() {}

	  createClass(SetCollection, Collection);function SetCollection() {}


	  Collection.Keyed = KeyedCollection;
	  Collection.Indexed = IndexedCollection;
	  Collection.Set = SetCollection;

	  var imul =
	    typeof Math.imul === 'function' && Math.imul(0xffffffff, 2) === -2 ?
	    Math.imul :
	    function imul(a, b) {
	      a = a | 0; // int
	      b = b | 0; // int
	      var c = a & 0xffff;
	      var d = b & 0xffff;
	      // Shift by 0 fixes the sign on the high part.
	      return (c * d) + ((((a >>> 16) * d + c * (b >>> 16)) << 16) >>> 0) | 0; // int
	    };

	  // v8 has an optimization for storing 31-bit signed numbers.
	  // Values which have either 00 or 11 as the high order bits qualify.
	  // This function drops the highest order bit in a signed number, maintaining
	  // the sign bit.
	  function smi(i32) {
	    return ((i32 >>> 1) & 0x40000000) | (i32 & 0xBFFFFFFF);
	  }

	  function hash(o) {
	    if (o === false || o === null || o === undefined) {
	      return 0;
	    }
	    if (typeof o.valueOf === 'function') {
	      o = o.valueOf();
	      if (o === false || o === null || o === undefined) {
	        return 0;
	      }
	    }
	    if (o === true) {
	      return 1;
	    }
	    var type = typeof o;
	    if (type === 'number') {
	      var h = o | 0;
	      if (h !== o) {
	        h ^= o * 0xFFFFFFFF;
	      }
	      while (o > 0xFFFFFFFF) {
	        o /= 0xFFFFFFFF;
	        h ^= o;
	      }
	      return smi(h);
	    }
	    if (type === 'string') {
	      return o.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(o) : hashString(o);
	    }
	    if (typeof o.hashCode === 'function') {
	      return o.hashCode();
	    }
	    if (type === 'object') {
	      return hashJSObj(o);
	    }
	    if (typeof o.toString === 'function') {
	      return hashString(o.toString());
	    }
	    throw new Error('Value type ' + type + ' cannot be hashed.');
	  }

	  function cachedHashString(string) {
	    var hash = stringHashCache[string];
	    if (hash === undefined) {
	      hash = hashString(string);
	      if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {
	        STRING_HASH_CACHE_SIZE = 0;
	        stringHashCache = {};
	      }
	      STRING_HASH_CACHE_SIZE++;
	      stringHashCache[string] = hash;
	    }
	    return hash;
	  }

	  // http://jsperf.com/hashing-strings
	  function hashString(string) {
	    // This is the hash from JVM
	    // The hash code for a string is computed as
	    // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],
	    // where s[i] is the ith character of the string and n is the length of
	    // the string. We "mod" the result to make it between 0 (inclusive) and 2^31
	    // (exclusive) by dropping high bits.
	    var hash = 0;
	    for (var ii = 0; ii < string.length; ii++) {
	      hash = 31 * hash + string.charCodeAt(ii) | 0;
	    }
	    return smi(hash);
	  }

	  function hashJSObj(obj) {
	    var hash;
	    if (usingWeakMap) {
	      hash = weakMap.get(obj);
	      if (hash !== undefined) {
	        return hash;
	      }
	    }

	    hash = obj[UID_HASH_KEY];
	    if (hash !== undefined) {
	      return hash;
	    }

	    if (!canDefineProperty) {
	      hash = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];
	      if (hash !== undefined) {
	        return hash;
	      }

	      hash = getIENodeHash(obj);
	      if (hash !== undefined) {
	        return hash;
	      }
	    }

	    hash = ++objHashUID;
	    if (objHashUID & 0x40000000) {
	      objHashUID = 0;
	    }

	    if (usingWeakMap) {
	      weakMap.set(obj, hash);
	    } else if (isExtensible !== undefined && isExtensible(obj) === false) {
	      throw new Error('Non-extensible objects are not allowed as keys.');
	    } else if (canDefineProperty) {
	      Object.defineProperty(obj, UID_HASH_KEY, {
	        'enumerable': false,
	        'configurable': false,
	        'writable': false,
	        'value': hash
	      });
	    } else if (obj.propertyIsEnumerable !== undefined &&
	               obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {
	      // Since we can't define a non-enumerable property on the object
	      // we'll hijack one of the less-used non-enumerable properties to
	      // save our hash on it. Since this is a function it will not show up in
	      // `JSON.stringify` which is what we want.
	      obj.propertyIsEnumerable = function() {
	        return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments);
	      };
	      obj.propertyIsEnumerable[UID_HASH_KEY] = hash;
	    } else if (obj.nodeType !== undefined) {
	      // At this point we couldn't get the IE `uniqueID` to use as a hash
	      // and we couldn't use a non-enumerable property to exploit the
	      // dontEnum bug so we simply add the `UID_HASH_KEY` on the node
	      // itself.
	      obj[UID_HASH_KEY] = hash;
	    } else {
	      throw new Error('Unable to set a non-enumerable property on object.');
	    }

	    return hash;
	  }

	  // Get references to ES5 object methods.
	  var isExtensible = Object.isExtensible;

	  // True if Object.defineProperty works as expected. IE8 fails this test.
	  var canDefineProperty = (function() {
	    try {
	      Object.defineProperty({}, '@', {});
	      return true;
	    } catch (e) {
	      return false;
	    }
	  }());

	  // IE has a `uniqueID` property on DOM nodes. We can construct the hash from it
	  // and avoid memory leaks from the IE cloneNode bug.
	  function getIENodeHash(node) {
	    if (node && node.nodeType > 0) {
	      switch (node.nodeType) {
	        case 1: // Element
	          return node.uniqueID;
	        case 9: // Document
	          return node.documentElement && node.documentElement.uniqueID;
	      }
	    }
	  }

	  // If possible, use a WeakMap.
	  var usingWeakMap = typeof WeakMap === 'function';
	  var weakMap;
	  if (usingWeakMap) {
	    weakMap = new WeakMap();
	  }

	  var objHashUID = 0;

	  var UID_HASH_KEY = '__immutablehash__';
	  if (typeof Symbol === 'function') {
	    UID_HASH_KEY = Symbol(UID_HASH_KEY);
	  }

	  var STRING_HASH_CACHE_MIN_STRLEN = 16;
	  var STRING_HASH_CACHE_MAX_SIZE = 255;
	  var STRING_HASH_CACHE_SIZE = 0;
	  var stringHashCache = {};

	  function assertNotInfinite(size) {
	    invariant(
	      size !== Infinity,
	      'Cannot perform this action with an infinite size.'
	    );
	  }

	  createClass(Map, KeyedCollection);

	    // @pragma Construction

	    function Map(value) {
	      return value === null || value === undefined ? emptyMap() :
	        isMap(value) && !isOrdered(value) ? value :
	        emptyMap().withMutations(function(map ) {
	          var iter = KeyedIterable(value);
	          assertNotInfinite(iter.size);
	          iter.forEach(function(v, k)  {return map.set(k, v)});
	        });
	    }

	    Map.prototype.toString = function() {
	      return this.__toString('Map {', '}');
	    };

	    // @pragma Access

	    Map.prototype.get = function(k, notSetValue) {
	      return this._root ?
	        this._root.get(0, undefined, k, notSetValue) :
	        notSetValue;
	    };

	    // @pragma Modification

	    Map.prototype.set = function(k, v) {
	      return updateMap(this, k, v);
	    };

	    Map.prototype.setIn = function(keyPath, v) {
	      return this.updateIn(keyPath, NOT_SET, function()  {return v});
	    };

	    Map.prototype.remove = function(k) {
	      return updateMap(this, k, NOT_SET);
	    };

	    Map.prototype.deleteIn = function(keyPath) {
	      return this.updateIn(keyPath, function()  {return NOT_SET});
	    };

	    Map.prototype.update = function(k, notSetValue, updater) {
	      return arguments.length === 1 ?
	        k(this) :
	        this.updateIn([k], notSetValue, updater);
	    };

	    Map.prototype.updateIn = function(keyPath, notSetValue, updater) {
	      if (!updater) {
	        updater = notSetValue;
	        notSetValue = undefined;
	      }
	      var updatedValue = updateInDeepMap(
	        this,
	        forceIterator(keyPath),
	        notSetValue,
	        updater
	      );
	      return updatedValue === NOT_SET ? undefined : updatedValue;
	    };

	    Map.prototype.clear = function() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = 0;
	        this._root = null;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return emptyMap();
	    };

	    // @pragma Composition

	    Map.prototype.merge = function(/*...iters*/) {
	      return mergeIntoMapWith(this, undefined, arguments);
	    };

	    Map.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return mergeIntoMapWith(this, merger, iters);
	    };

	    Map.prototype.mergeIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);
	      return this.updateIn(
	        keyPath,
	        emptyMap(),
	        function(m ) {return typeof m.merge === 'function' ?
	          m.merge.apply(m, iters) :
	          iters[iters.length - 1]}
	      );
	    };

	    Map.prototype.mergeDeep = function(/*...iters*/) {
	      return mergeIntoMapWith(this, deepMerger, arguments);
	    };

	    Map.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return mergeIntoMapWith(this, deepMergerWith(merger), iters);
	    };

	    Map.prototype.mergeDeepIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);
	      return this.updateIn(
	        keyPath,
	        emptyMap(),
	        function(m ) {return typeof m.mergeDeep === 'function' ?
	          m.mergeDeep.apply(m, iters) :
	          iters[iters.length - 1]}
	      );
	    };

	    Map.prototype.sort = function(comparator) {
	      // Late binding
	      return OrderedMap(sortFactory(this, comparator));
	    };

	    Map.prototype.sortBy = function(mapper, comparator) {
	      // Late binding
	      return OrderedMap(sortFactory(this, comparator, mapper));
	    };

	    // @pragma Mutability

	    Map.prototype.withMutations = function(fn) {
	      var mutable = this.asMutable();
	      fn(mutable);
	      return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;
	    };

	    Map.prototype.asMutable = function() {
	      return this.__ownerID ? this : this.__ensureOwner(new OwnerID());
	    };

	    Map.prototype.asImmutable = function() {
	      return this.__ensureOwner();
	    };

	    Map.prototype.wasAltered = function() {
	      return this.__altered;
	    };

	    Map.prototype.__iterator = function(type, reverse) {
	      return new MapIterator(this, type, reverse);
	    };

	    Map.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      var iterations = 0;
	      this._root && this._root.iterate(function(entry ) {
	        iterations++;
	        return fn(entry[1], entry[0], this$0);
	      }, reverse);
	      return iterations;
	    };

	    Map.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this.__altered = false;
	        return this;
	      }
	      return makeMap(this.size, this._root, ownerID, this.__hash);
	    };


	  function isMap(maybeMap) {
	    return !!(maybeMap && maybeMap[IS_MAP_SENTINEL]);
	  }

	  Map.isMap = isMap;

	  var IS_MAP_SENTINEL = '@@__IMMUTABLE_MAP__@@';

	  var MapPrototype = Map.prototype;
	  MapPrototype[IS_MAP_SENTINEL] = true;
	  MapPrototype[DELETE] = MapPrototype.remove;
	  MapPrototype.removeIn = MapPrototype.deleteIn;


	  // #pragma Trie Nodes



	    function ArrayMapNode(ownerID, entries) {
	      this.ownerID = ownerID;
	      this.entries = entries;
	    }

	    ArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      var entries = this.entries;
	      for (var ii = 0, len = entries.length; ii < len; ii++) {
	        if (is(key, entries[ii][0])) {
	          return entries[ii][1];
	        }
	      }
	      return notSetValue;
	    };

	    ArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      var removed = value === NOT_SET;

	      var entries = this.entries;
	      var idx = 0;
	      for (var len = entries.length; idx < len; idx++) {
	        if (is(key, entries[idx][0])) {
	          break;
	        }
	      }
	      var exists = idx < len;

	      if (exists ? entries[idx][1] === value : removed) {
	        return this;
	      }

	      SetRef(didAlter);
	      (removed || !exists) && SetRef(didChangeSize);

	      if (removed && entries.length === 1) {
	        return; // undefined
	      }

	      if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {
	        return createNodes(ownerID, entries, key, value);
	      }

	      var isEditable = ownerID && ownerID === this.ownerID;
	      var newEntries = isEditable ? entries : arrCopy(entries);

	      if (exists) {
	        if (removed) {
	          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());
	        } else {
	          newEntries[idx] = [key, value];
	        }
	      } else {
	        newEntries.push([key, value]);
	      }

	      if (isEditable) {
	        this.entries = newEntries;
	        return this;
	      }

	      return new ArrayMapNode(ownerID, newEntries);
	    };




	    function BitmapIndexedNode(ownerID, bitmap, nodes) {
	      this.ownerID = ownerID;
	      this.bitmap = bitmap;
	      this.nodes = nodes;
	    }

	    BitmapIndexedNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }
	      var bit = (1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK));
	      var bitmap = this.bitmap;
	      return (bitmap & bit) === 0 ? notSetValue :
	        this.nodes[popCount(bitmap & (bit - 1))].get(shift + SHIFT, keyHash, key, notSetValue);
	    };

	    BitmapIndexedNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }
	      var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
	      var bit = 1 << keyHashFrag;
	      var bitmap = this.bitmap;
	      var exists = (bitmap & bit) !== 0;

	      if (!exists && value === NOT_SET) {
	        return this;
	      }

	      var idx = popCount(bitmap & (bit - 1));
	      var nodes = this.nodes;
	      var node = exists ? nodes[idx] : undefined;
	      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);

	      if (newNode === node) {
	        return this;
	      }

	      if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {
	        return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);
	      }

	      if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {
	        return nodes[idx ^ 1];
	      }

	      if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {
	        return newNode;
	      }

	      var isEditable = ownerID && ownerID === this.ownerID;
	      var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;
	      var newNodes = exists ? newNode ?
	        setIn(nodes, idx, newNode, isEditable) :
	        spliceOut(nodes, idx, isEditable) :
	        spliceIn(nodes, idx, newNode, isEditable);

	      if (isEditable) {
	        this.bitmap = newBitmap;
	        this.nodes = newNodes;
	        return this;
	      }

	      return new BitmapIndexedNode(ownerID, newBitmap, newNodes);
	    };




	    function HashArrayMapNode(ownerID, count, nodes) {
	      this.ownerID = ownerID;
	      this.count = count;
	      this.nodes = nodes;
	    }

	    HashArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }
	      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
	      var node = this.nodes[idx];
	      return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;
	    };

	    HashArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }
	      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
	      var removed = value === NOT_SET;
	      var nodes = this.nodes;
	      var node = nodes[idx];

	      if (removed && !node) {
	        return this;
	      }

	      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);
	      if (newNode === node) {
	        return this;
	      }

	      var newCount = this.count;
	      if (!node) {
	        newCount++;
	      } else if (!newNode) {
	        newCount--;
	        if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {
	          return packNodes(ownerID, nodes, newCount, idx);
	        }
	      }

	      var isEditable = ownerID && ownerID === this.ownerID;
	      var newNodes = setIn(nodes, idx, newNode, isEditable);

	      if (isEditable) {
	        this.count = newCount;
	        this.nodes = newNodes;
	        return this;
	      }

	      return new HashArrayMapNode(ownerID, newCount, newNodes);
	    };




	    function HashCollisionNode(ownerID, keyHash, entries) {
	      this.ownerID = ownerID;
	      this.keyHash = keyHash;
	      this.entries = entries;
	    }

	    HashCollisionNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      var entries = this.entries;
	      for (var ii = 0, len = entries.length; ii < len; ii++) {
	        if (is(key, entries[ii][0])) {
	          return entries[ii][1];
	        }
	      }
	      return notSetValue;
	    };

	    HashCollisionNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }

	      var removed = value === NOT_SET;

	      if (keyHash !== this.keyHash) {
	        if (removed) {
	          return this;
	        }
	        SetRef(didAlter);
	        SetRef(didChangeSize);
	        return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);
	      }

	      var entries = this.entries;
	      var idx = 0;
	      for (var len = entries.length; idx < len; idx++) {
	        if (is(key, entries[idx][0])) {
	          break;
	        }
	      }
	      var exists = idx < len;

	      if (exists ? entries[idx][1] === value : removed) {
	        return this;
	      }

	      SetRef(didAlter);
	      (removed || !exists) && SetRef(didChangeSize);

	      if (removed && len === 2) {
	        return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);
	      }

	      var isEditable = ownerID && ownerID === this.ownerID;
	      var newEntries = isEditable ? entries : arrCopy(entries);

	      if (exists) {
	        if (removed) {
	          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());
	        } else {
	          newEntries[idx] = [key, value];
	        }
	      } else {
	        newEntries.push([key, value]);
	      }

	      if (isEditable) {
	        this.entries = newEntries;
	        return this;
	      }

	      return new HashCollisionNode(ownerID, this.keyHash, newEntries);
	    };




	    function ValueNode(ownerID, keyHash, entry) {
	      this.ownerID = ownerID;
	      this.keyHash = keyHash;
	      this.entry = entry;
	    }

	    ValueNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      return is(key, this.entry[0]) ? this.entry[1] : notSetValue;
	    };

	    ValueNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      var removed = value === NOT_SET;
	      var keyMatch = is(key, this.entry[0]);
	      if (keyMatch ? value === this.entry[1] : removed) {
	        return this;
	      }

	      SetRef(didAlter);

	      if (removed) {
	        SetRef(didChangeSize);
	        return; // undefined
	      }

	      if (keyMatch) {
	        if (ownerID && ownerID === this.ownerID) {
	          this.entry[1] = value;
	          return this;
	        }
	        return new ValueNode(ownerID, this.keyHash, [key, value]);
	      }

	      SetRef(didChangeSize);
	      return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);
	    };



	  // #pragma Iterators

	  ArrayMapNode.prototype.iterate =
	  HashCollisionNode.prototype.iterate = function (fn, reverse) {
	    var entries = this.entries;
	    for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {
	      if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {
	        return false;
	      }
	    }
	  }

	  BitmapIndexedNode.prototype.iterate =
	  HashArrayMapNode.prototype.iterate = function (fn, reverse) {
	    var nodes = this.nodes;
	    for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {
	      var node = nodes[reverse ? maxIndex - ii : ii];
	      if (node && node.iterate(fn, reverse) === false) {
	        return false;
	      }
	    }
	  }

	  ValueNode.prototype.iterate = function (fn, reverse) {
	    return fn(this.entry);
	  }

	  createClass(MapIterator, Iterator);

	    function MapIterator(map, type, reverse) {
	      this._type = type;
	      this._reverse = reverse;
	      this._stack = map._root && mapIteratorFrame(map._root);
	    }

	    MapIterator.prototype.next = function() {
	      var type = this._type;
	      var stack = this._stack;
	      while (stack) {
	        var node = stack.node;
	        var index = stack.index++;
	        var maxIndex;
	        if (node.entry) {
	          if (index === 0) {
	            return mapIteratorValue(type, node.entry);
	          }
	        } else if (node.entries) {
	          maxIndex = node.entries.length - 1;
	          if (index <= maxIndex) {
	            return mapIteratorValue(type, node.entries[this._reverse ? maxIndex - index : index]);
	          }
	        } else {
	          maxIndex = node.nodes.length - 1;
	          if (index <= maxIndex) {
	            var subNode = node.nodes[this._reverse ? maxIndex - index : index];
	            if (subNode) {
	              if (subNode.entry) {
	                return mapIteratorValue(type, subNode.entry);
	              }
	              stack = this._stack = mapIteratorFrame(subNode, stack);
	            }
	            continue;
	          }
	        }
	        stack = this._stack = this._stack.__prev;
	      }
	      return iteratorDone();
	    };


	  function mapIteratorValue(type, entry) {
	    return iteratorValue(type, entry[0], entry[1]);
	  }

	  function mapIteratorFrame(node, prev) {
	    return {
	      node: node,
	      index: 0,
	      __prev: prev
	    };
	  }

	  function makeMap(size, root, ownerID, hash) {
	    var map = Object.create(MapPrototype);
	    map.size = size;
	    map._root = root;
	    map.__ownerID = ownerID;
	    map.__hash = hash;
	    map.__altered = false;
	    return map;
	  }

	  var EMPTY_MAP;
	  function emptyMap() {
	    return EMPTY_MAP || (EMPTY_MAP = makeMap(0));
	  }

	  function updateMap(map, k, v) {
	    var newRoot;
	    var newSize;
	    if (!map._root) {
	      if (v === NOT_SET) {
	        return map;
	      }
	      newSize = 1;
	      newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);
	    } else {
	      var didChangeSize = MakeRef(CHANGE_LENGTH);
	      var didAlter = MakeRef(DID_ALTER);
	      newRoot = updateNode(map._root, map.__ownerID, 0, undefined, k, v, didChangeSize, didAlter);
	      if (!didAlter.value) {
	        return map;
	      }
	      newSize = map.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);
	    }
	    if (map.__ownerID) {
	      map.size = newSize;
	      map._root = newRoot;
	      map.__hash = undefined;
	      map.__altered = true;
	      return map;
	    }
	    return newRoot ? makeMap(newSize, newRoot) : emptyMap();
	  }

	  function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	    if (!node) {
	      if (value === NOT_SET) {
	        return node;
	      }
	      SetRef(didAlter);
	      SetRef(didChangeSize);
	      return new ValueNode(ownerID, keyHash, [key, value]);
	    }
	    return node.update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter);
	  }

	  function isLeafNode(node) {
	    return node.constructor === ValueNode || node.constructor === HashCollisionNode;
	  }

	  function mergeIntoNode(node, ownerID, shift, keyHash, entry) {
	    if (node.keyHash === keyHash) {
	      return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);
	    }

	    var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;
	    var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;

	    var newNode;
	    var nodes = idx1 === idx2 ?
	      [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)] :
	      ((newNode = new ValueNode(ownerID, keyHash, entry)), idx1 < idx2 ? [node, newNode] : [newNode, node]);

	    return new BitmapIndexedNode(ownerID, (1 << idx1) | (1 << idx2), nodes);
	  }

	  function createNodes(ownerID, entries, key, value) {
	    if (!ownerID) {
	      ownerID = new OwnerID();
	    }
	    var node = new ValueNode(ownerID, hash(key), [key, value]);
	    for (var ii = 0; ii < entries.length; ii++) {
	      var entry = entries[ii];
	      node = node.update(ownerID, 0, undefined, entry[0], entry[1]);
	    }
	    return node;
	  }

	  function packNodes(ownerID, nodes, count, excluding) {
	    var bitmap = 0;
	    var packedII = 0;
	    var packedNodes = new Array(count);
	    for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {
	      var node = nodes[ii];
	      if (node !== undefined && ii !== excluding) {
	        bitmap |= bit;
	        packedNodes[packedII++] = node;
	      }
	    }
	    return new BitmapIndexedNode(ownerID, bitmap, packedNodes);
	  }

	  function expandNodes(ownerID, nodes, bitmap, including, node) {
	    var count = 0;
	    var expandedNodes = new Array(SIZE);
	    for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {
	      expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;
	    }
	    expandedNodes[including] = node;
	    return new HashArrayMapNode(ownerID, count + 1, expandedNodes);
	  }

	  function mergeIntoMapWith(map, merger, iterables) {
	    var iters = [];
	    for (var ii = 0; ii < iterables.length; ii++) {
	      var value = iterables[ii];
	      var iter = KeyedIterable(value);
	      if (!isIterable(value)) {
	        iter = iter.map(function(v ) {return fromJS(v)});
	      }
	      iters.push(iter);
	    }
	    return mergeIntoCollectionWith(map, merger, iters);
	  }

	  function deepMerger(existing, value, key) {
	    return existing && existing.mergeDeep && isIterable(value) ?
	      existing.mergeDeep(value) :
	      is(existing, value) ? existing : value;
	  }

	  function deepMergerWith(merger) {
	    return function(existing, value, key)  {
	      if (existing && existing.mergeDeepWith && isIterable(value)) {
	        return existing.mergeDeepWith(merger, value);
	      }
	      var nextValue = merger(existing, value, key);
	      return is(existing, nextValue) ? existing : nextValue;
	    };
	  }

	  function mergeIntoCollectionWith(collection, merger, iters) {
	    iters = iters.filter(function(x ) {return x.size !== 0});
	    if (iters.length === 0) {
	      return collection;
	    }
	    if (collection.size === 0 && !collection.__ownerID && iters.length === 1) {
	      return collection.constructor(iters[0]);
	    }
	    return collection.withMutations(function(collection ) {
	      var mergeIntoMap = merger ?
	        function(value, key)  {
	          collection.update(key, NOT_SET, function(existing )
	            {return existing === NOT_SET ? value : merger(existing, value, key)}
	          );
	        } :
	        function(value, key)  {
	          collection.set(key, value);
	        }
	      for (var ii = 0; ii < iters.length; ii++) {
	        iters[ii].forEach(mergeIntoMap);
	      }
	    });
	  }

	  function updateInDeepMap(existing, keyPathIter, notSetValue, updater) {
	    var isNotSet = existing === NOT_SET;
	    var step = keyPathIter.next();
	    if (step.done) {
	      var existingValue = isNotSet ? notSetValue : existing;
	      var newValue = updater(existingValue);
	      return newValue === existingValue ? existing : newValue;
	    }
	    invariant(
	      isNotSet || (existing && existing.set),
	      'invalid keyPath'
	    );
	    var key = step.value;
	    var nextExisting = isNotSet ? NOT_SET : existing.get(key, NOT_SET);
	    var nextUpdated = updateInDeepMap(
	      nextExisting,
	      keyPathIter,
	      notSetValue,
	      updater
	    );
	    return nextUpdated === nextExisting ? existing :
	      nextUpdated === NOT_SET ? existing.remove(key) :
	      (isNotSet ? emptyMap() : existing).set(key, nextUpdated);
	  }

	  function popCount(x) {
	    x = x - ((x >> 1) & 0x55555555);
	    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
	    x = (x + (x >> 4)) & 0x0f0f0f0f;
	    x = x + (x >> 8);
	    x = x + (x >> 16);
	    return x & 0x7f;
	  }

	  function setIn(array, idx, val, canEdit) {
	    var newArray = canEdit ? array : arrCopy(array);
	    newArray[idx] = val;
	    return newArray;
	  }

	  function spliceIn(array, idx, val, canEdit) {
	    var newLen = array.length + 1;
	    if (canEdit && idx + 1 === newLen) {
	      array[idx] = val;
	      return array;
	    }
	    var newArray = new Array(newLen);
	    var after = 0;
	    for (var ii = 0; ii < newLen; ii++) {
	      if (ii === idx) {
	        newArray[ii] = val;
	        after = -1;
	      } else {
	        newArray[ii] = array[ii + after];
	      }
	    }
	    return newArray;
	  }

	  function spliceOut(array, idx, canEdit) {
	    var newLen = array.length - 1;
	    if (canEdit && idx === newLen) {
	      array.pop();
	      return array;
	    }
	    var newArray = new Array(newLen);
	    var after = 0;
	    for (var ii = 0; ii < newLen; ii++) {
	      if (ii === idx) {
	        after = 1;
	      }
	      newArray[ii] = array[ii + after];
	    }
	    return newArray;
	  }

	  var MAX_ARRAY_MAP_SIZE = SIZE / 4;
	  var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;
	  var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;

	  createClass(List, IndexedCollection);

	    // @pragma Construction

	    function List(value) {
	      var empty = emptyList();
	      if (value === null || value === undefined) {
	        return empty;
	      }
	      if (isList(value)) {
	        return value;
	      }
	      var iter = IndexedIterable(value);
	      var size = iter.size;
	      if (size === 0) {
	        return empty;
	      }
	      assertNotInfinite(size);
	      if (size > 0 && size < SIZE) {
	        return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));
	      }
	      return empty.withMutations(function(list ) {
	        list.setSize(size);
	        iter.forEach(function(v, i)  {return list.set(i, v)});
	      });
	    }

	    List.of = function(/*...values*/) {
	      return this(arguments);
	    };

	    List.prototype.toString = function() {
	      return this.__toString('List [', ']');
	    };

	    // @pragma Access

	    List.prototype.get = function(index, notSetValue) {
	      index = wrapIndex(this, index);
	      if (index >= 0 && index < this.size) {
	        index += this._origin;
	        var node = listNodeFor(this, index);
	        return node && node.array[index & MASK];
	      }
	      return notSetValue;
	    };

	    // @pragma Modification

	    List.prototype.set = function(index, value) {
	      return updateList(this, index, value);
	    };

	    List.prototype.remove = function(index) {
	      return !this.has(index) ? this :
	        index === 0 ? this.shift() :
	        index === this.size - 1 ? this.pop() :
	        this.splice(index, 1);
	    };

	    List.prototype.insert = function(index, value) {
	      return this.splice(index, 0, value);
	    };

	    List.prototype.clear = function() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = this._origin = this._capacity = 0;
	        this._level = SHIFT;
	        this._root = this._tail = null;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return emptyList();
	    };

	    List.prototype.push = function(/*...values*/) {
	      var values = arguments;
	      var oldSize = this.size;
	      return this.withMutations(function(list ) {
	        setListBounds(list, 0, oldSize + values.length);
	        for (var ii = 0; ii < values.length; ii++) {
	          list.set(oldSize + ii, values[ii]);
	        }
	      });
	    };

	    List.prototype.pop = function() {
	      return setListBounds(this, 0, -1);
	    };

	    List.prototype.unshift = function(/*...values*/) {
	      var values = arguments;
	      return this.withMutations(function(list ) {
	        setListBounds(list, -values.length);
	        for (var ii = 0; ii < values.length; ii++) {
	          list.set(ii, values[ii]);
	        }
	      });
	    };

	    List.prototype.shift = function() {
	      return setListBounds(this, 1);
	    };

	    // @pragma Composition

	    List.prototype.merge = function(/*...iters*/) {
	      return mergeIntoListWith(this, undefined, arguments);
	    };

	    List.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return mergeIntoListWith(this, merger, iters);
	    };

	    List.prototype.mergeDeep = function(/*...iters*/) {
	      return mergeIntoListWith(this, deepMerger, arguments);
	    };

	    List.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return mergeIntoListWith(this, deepMergerWith(merger), iters);
	    };

	    List.prototype.setSize = function(size) {
	      return setListBounds(this, 0, size);
	    };

	    // @pragma Iteration

	    List.prototype.slice = function(begin, end) {
	      var size = this.size;
	      if (wholeSlice(begin, end, size)) {
	        return this;
	      }
	      return setListBounds(
	        this,
	        resolveBegin(begin, size),
	        resolveEnd(end, size)
	      );
	    };

	    List.prototype.__iterator = function(type, reverse) {
	      var index = 0;
	      var values = iterateList(this, reverse);
	      return new Iterator(function()  {
	        var value = values();
	        return value === DONE ?
	          iteratorDone() :
	          iteratorValue(type, index++, value);
	      });
	    };

	    List.prototype.__iterate = function(fn, reverse) {
	      var index = 0;
	      var values = iterateList(this, reverse);
	      var value;
	      while ((value = values()) !== DONE) {
	        if (fn(value, index++, this) === false) {
	          break;
	        }
	      }
	      return index;
	    };

	    List.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        return this;
	      }
	      return makeList(this._origin, this._capacity, this._level, this._root, this._tail, ownerID, this.__hash);
	    };


	  function isList(maybeList) {
	    return !!(maybeList && maybeList[IS_LIST_SENTINEL]);
	  }

	  List.isList = isList;

	  var IS_LIST_SENTINEL = '@@__IMMUTABLE_LIST__@@';

	  var ListPrototype = List.prototype;
	  ListPrototype[IS_LIST_SENTINEL] = true;
	  ListPrototype[DELETE] = ListPrototype.remove;
	  ListPrototype.setIn = MapPrototype.setIn;
	  ListPrototype.deleteIn =
	  ListPrototype.removeIn = MapPrototype.removeIn;
	  ListPrototype.update = MapPrototype.update;
	  ListPrototype.updateIn = MapPrototype.updateIn;
	  ListPrototype.mergeIn = MapPrototype.mergeIn;
	  ListPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
	  ListPrototype.withMutations = MapPrototype.withMutations;
	  ListPrototype.asMutable = MapPrototype.asMutable;
	  ListPrototype.asImmutable = MapPrototype.asImmutable;
	  ListPrototype.wasAltered = MapPrototype.wasAltered;



	    function VNode(array, ownerID) {
	      this.array = array;
	      this.ownerID = ownerID;
	    }

	    // TODO: seems like these methods are very similar

	    VNode.prototype.removeBefore = function(ownerID, level, index) {
	      if (index === level ? 1 << level : 0 || this.array.length === 0) {
	        return this;
	      }
	      var originIndex = (index >>> level) & MASK;
	      if (originIndex >= this.array.length) {
	        return new VNode([], ownerID);
	      }
	      var removingFirst = originIndex === 0;
	      var newChild;
	      if (level > 0) {
	        var oldChild = this.array[originIndex];
	        newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);
	        if (newChild === oldChild && removingFirst) {
	          return this;
	        }
	      }
	      if (removingFirst && !newChild) {
	        return this;
	      }
	      var editable = editableVNode(this, ownerID);
	      if (!removingFirst) {
	        for (var ii = 0; ii < originIndex; ii++) {
	          editable.array[ii] = undefined;
	        }
	      }
	      if (newChild) {
	        editable.array[originIndex] = newChild;
	      }
	      return editable;
	    };

	    VNode.prototype.removeAfter = function(ownerID, level, index) {
	      if (index === (level ? 1 << level : 0) || this.array.length === 0) {
	        return this;
	      }
	      var sizeIndex = ((index - 1) >>> level) & MASK;
	      if (sizeIndex >= this.array.length) {
	        return this;
	      }

	      var newChild;
	      if (level > 0) {
	        var oldChild = this.array[sizeIndex];
	        newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);
	        if (newChild === oldChild && sizeIndex === this.array.length - 1) {
	          return this;
	        }
	      }

	      var editable = editableVNode(this, ownerID);
	      editable.array.splice(sizeIndex + 1);
	      if (newChild) {
	        editable.array[sizeIndex] = newChild;
	      }
	      return editable;
	    };



	  var DONE = {};

	  function iterateList(list, reverse) {
	    var left = list._origin;
	    var right = list._capacity;
	    var tailPos = getTailOffset(right);
	    var tail = list._tail;

	    return iterateNodeOrLeaf(list._root, list._level, 0);

	    function iterateNodeOrLeaf(node, level, offset) {
	      return level === 0 ?
	        iterateLeaf(node, offset) :
	        iterateNode(node, level, offset);
	    }

	    function iterateLeaf(node, offset) {
	      var array = offset === tailPos ? tail && tail.array : node && node.array;
	      var from = offset > left ? 0 : left - offset;
	      var to = right - offset;
	      if (to > SIZE) {
	        to = SIZE;
	      }
	      return function()  {
	        if (from === to) {
	          return DONE;
	        }
	        var idx = reverse ? --to : from++;
	        return array && array[idx];
	      };
	    }

	    function iterateNode(node, level, offset) {
	      var values;
	      var array = node && node.array;
	      var from = offset > left ? 0 : (left - offset) >> level;
	      var to = ((right - offset) >> level) + 1;
	      if (to > SIZE) {
	        to = SIZE;
	      }
	      return function()  {
	        do {
	          if (values) {
	            var value = values();
	            if (value !== DONE) {
	              return value;
	            }
	            values = null;
	          }
	          if (from === to) {
	            return DONE;
	          }
	          var idx = reverse ? --to : from++;
	          values = iterateNodeOrLeaf(
	            array && array[idx], level - SHIFT, offset + (idx << level)
	          );
	        } while (true);
	      };
	    }
	  }

	  function makeList(origin, capacity, level, root, tail, ownerID, hash) {
	    var list = Object.create(ListPrototype);
	    list.size = capacity - origin;
	    list._origin = origin;
	    list._capacity = capacity;
	    list._level = level;
	    list._root = root;
	    list._tail = tail;
	    list.__ownerID = ownerID;
	    list.__hash = hash;
	    list.__altered = false;
	    return list;
	  }

	  var EMPTY_LIST;
	  function emptyList() {
	    return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));
	  }

	  function updateList(list, index, value) {
	    index = wrapIndex(list, index);

	    if (index !== index) {
	      return list;
	    }

	    if (index >= list.size || index < 0) {
	      return list.withMutations(function(list ) {
	        index < 0 ?
	          setListBounds(list, index).set(0, value) :
	          setListBounds(list, 0, index + 1).set(index, value)
	      });
	    }

	    index += list._origin;

	    var newTail = list._tail;
	    var newRoot = list._root;
	    var didAlter = MakeRef(DID_ALTER);
	    if (index >= getTailOffset(list._capacity)) {
	      newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);
	    } else {
	      newRoot = updateVNode(newRoot, list.__ownerID, list._level, index, value, didAlter);
	    }

	    if (!didAlter.value) {
	      return list;
	    }

	    if (list.__ownerID) {
	      list._root = newRoot;
	      list._tail = newTail;
	      list.__hash = undefined;
	      list.__altered = true;
	      return list;
	    }
	    return makeList(list._origin, list._capacity, list._level, newRoot, newTail);
	  }

	  function updateVNode(node, ownerID, level, index, value, didAlter) {
	    var idx = (index >>> level) & MASK;
	    var nodeHas = node && idx < node.array.length;
	    if (!nodeHas && value === undefined) {
	      return node;
	    }

	    var newNode;

	    if (level > 0) {
	      var lowerNode = node && node.array[idx];
	      var newLowerNode = updateVNode(lowerNode, ownerID, level - SHIFT, index, value, didAlter);
	      if (newLowerNode === lowerNode) {
	        return node;
	      }
	      newNode = editableVNode(node, ownerID);
	      newNode.array[idx] = newLowerNode;
	      return newNode;
	    }

	    if (nodeHas && node.array[idx] === value) {
	      return node;
	    }

	    SetRef(didAlter);

	    newNode = editableVNode(node, ownerID);
	    if (value === undefined && idx === newNode.array.length - 1) {
	      newNode.array.pop();
	    } else {
	      newNode.array[idx] = value;
	    }
	    return newNode;
	  }

	  function editableVNode(node, ownerID) {
	    if (ownerID && node && ownerID === node.ownerID) {
	      return node;
	    }
	    return new VNode(node ? node.array.slice() : [], ownerID);
	  }

	  function listNodeFor(list, rawIndex) {
	    if (rawIndex >= getTailOffset(list._capacity)) {
	      return list._tail;
	    }
	    if (rawIndex < 1 << (list._level + SHIFT)) {
	      var node = list._root;
	      var level = list._level;
	      while (node && level > 0) {
	        node = node.array[(rawIndex >>> level) & MASK];
	        level -= SHIFT;
	      }
	      return node;
	    }
	  }

	  function setListBounds(list, begin, end) {
	    // Sanitize begin & end using this shorthand for ToInt32(argument)
	    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
	    if (begin !== undefined) {
	      begin = begin | 0;
	    }
	    if (end !== undefined) {
	      end = end | 0;
	    }
	    var owner = list.__ownerID || new OwnerID();
	    var oldOrigin = list._origin;
	    var oldCapacity = list._capacity;
	    var newOrigin = oldOrigin + begin;
	    var newCapacity = end === undefined ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;
	    if (newOrigin === oldOrigin && newCapacity === oldCapacity) {
	      return list;
	    }

	    // If it's going to end after it starts, it's empty.
	    if (newOrigin >= newCapacity) {
	      return list.clear();
	    }

	    var newLevel = list._level;
	    var newRoot = list._root;

	    // New origin might need creating a higher root.
	    var offsetShift = 0;
	    while (newOrigin + offsetShift < 0) {
	      newRoot = new VNode(newRoot && newRoot.array.length ? [undefined, newRoot] : [], owner);
	      newLevel += SHIFT;
	      offsetShift += 1 << newLevel;
	    }
	    if (offsetShift) {
	      newOrigin += offsetShift;
	      oldOrigin += offsetShift;
	      newCapacity += offsetShift;
	      oldCapacity += offsetShift;
	    }

	    var oldTailOffset = getTailOffset(oldCapacity);
	    var newTailOffset = getTailOffset(newCapacity);

	    // New size might need creating a higher root.
	    while (newTailOffset >= 1 << (newLevel + SHIFT)) {
	      newRoot = new VNode(newRoot && newRoot.array.length ? [newRoot] : [], owner);
	      newLevel += SHIFT;
	    }

	    // Locate or create the new tail.
	    var oldTail = list._tail;
	    var newTail = newTailOffset < oldTailOffset ?
	      listNodeFor(list, newCapacity - 1) :
	      newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;

	    // Merge Tail into tree.
	    if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {
	      newRoot = editableVNode(newRoot, owner);
	      var node = newRoot;
	      for (var level = newLevel; level > SHIFT; level -= SHIFT) {
	        var idx = (oldTailOffset >>> level) & MASK;
	        node = node.array[idx] = editableVNode(node.array[idx], owner);
	      }
	      node.array[(oldTailOffset >>> SHIFT) & MASK] = oldTail;
	    }

	    // If the size has been reduced, there's a chance the tail needs to be trimmed.
	    if (newCapacity < oldCapacity) {
	      newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);
	    }

	    // If the new origin is within the tail, then we do not need a root.
	    if (newOrigin >= newTailOffset) {
	      newOrigin -= newTailOffset;
	      newCapacity -= newTailOffset;
	      newLevel = SHIFT;
	      newRoot = null;
	      newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);

	    // Otherwise, if the root has been trimmed, garbage collect.
	    } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {
	      offsetShift = 0;

	      // Identify the new top root node of the subtree of the old root.
	      while (newRoot) {
	        var beginIndex = (newOrigin >>> newLevel) & MASK;
	        if (beginIndex !== (newTailOffset >>> newLevel) & MASK) {
	          break;
	        }
	        if (beginIndex) {
	          offsetShift += (1 << newLevel) * beginIndex;
	        }
	        newLevel -= SHIFT;
	        newRoot = newRoot.array[beginIndex];
	      }

	      // Trim the new sides of the new root.
	      if (newRoot && newOrigin > oldOrigin) {
	        newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);
	      }
	      if (newRoot && newTailOffset < oldTailOffset) {
	        newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);
	      }
	      if (offsetShift) {
	        newOrigin -= offsetShift;
	        newCapacity -= offsetShift;
	      }
	    }

	    if (list.__ownerID) {
	      list.size = newCapacity - newOrigin;
	      list._origin = newOrigin;
	      list._capacity = newCapacity;
	      list._level = newLevel;
	      list._root = newRoot;
	      list._tail = newTail;
	      list.__hash = undefined;
	      list.__altered = true;
	      return list;
	    }
	    return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);
	  }

	  function mergeIntoListWith(list, merger, iterables) {
	    var iters = [];
	    var maxSize = 0;
	    for (var ii = 0; ii < iterables.length; ii++) {
	      var value = iterables[ii];
	      var iter = IndexedIterable(value);
	      if (iter.size > maxSize) {
	        maxSize = iter.size;
	      }
	      if (!isIterable(value)) {
	        iter = iter.map(function(v ) {return fromJS(v)});
	      }
	      iters.push(iter);
	    }
	    if (maxSize > list.size) {
	      list = list.setSize(maxSize);
	    }
	    return mergeIntoCollectionWith(list, merger, iters);
	  }

	  function getTailOffset(size) {
	    return size < SIZE ? 0 : (((size - 1) >>> SHIFT) << SHIFT);
	  }

	  createClass(OrderedMap, Map);

	    // @pragma Construction

	    function OrderedMap(value) {
	      return value === null || value === undefined ? emptyOrderedMap() :
	        isOrderedMap(value) ? value :
	        emptyOrderedMap().withMutations(function(map ) {
	          var iter = KeyedIterable(value);
	          assertNotInfinite(iter.size);
	          iter.forEach(function(v, k)  {return map.set(k, v)});
	        });
	    }

	    OrderedMap.of = function(/*...values*/) {
	      return this(arguments);
	    };

	    OrderedMap.prototype.toString = function() {
	      return this.__toString('OrderedMap {', '}');
	    };

	    // @pragma Access

	    OrderedMap.prototype.get = function(k, notSetValue) {
	      var index = this._map.get(k);
	      return index !== undefined ? this._list.get(index)[1] : notSetValue;
	    };

	    // @pragma Modification

	    OrderedMap.prototype.clear = function() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = 0;
	        this._map.clear();
	        this._list.clear();
	        return this;
	      }
	      return emptyOrderedMap();
	    };

	    OrderedMap.prototype.set = function(k, v) {
	      return updateOrderedMap(this, k, v);
	    };

	    OrderedMap.prototype.remove = function(k) {
	      return updateOrderedMap(this, k, NOT_SET);
	    };

	    OrderedMap.prototype.wasAltered = function() {
	      return this._map.wasAltered() || this._list.wasAltered();
	    };

	    OrderedMap.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return this._list.__iterate(
	        function(entry ) {return entry && fn(entry[1], entry[0], this$0)},
	        reverse
	      );
	    };

	    OrderedMap.prototype.__iterator = function(type, reverse) {
	      return this._list.fromEntrySeq().__iterator(type, reverse);
	    };

	    OrderedMap.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      var newMap = this._map.__ensureOwner(ownerID);
	      var newList = this._list.__ensureOwner(ownerID);
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this._map = newMap;
	        this._list = newList;
	        return this;
	      }
	      return makeOrderedMap(newMap, newList, ownerID, this.__hash);
	    };


	  function isOrderedMap(maybeOrderedMap) {
	    return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);
	  }

	  OrderedMap.isOrderedMap = isOrderedMap;

	  OrderedMap.prototype[IS_ORDERED_SENTINEL] = true;
	  OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;



	  function makeOrderedMap(map, list, ownerID, hash) {
	    var omap = Object.create(OrderedMap.prototype);
	    omap.size = map ? map.size : 0;
	    omap._map = map;
	    omap._list = list;
	    omap.__ownerID = ownerID;
	    omap.__hash = hash;
	    return omap;
	  }

	  var EMPTY_ORDERED_MAP;
	  function emptyOrderedMap() {
	    return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));
	  }

	  function updateOrderedMap(omap, k, v) {
	    var map = omap._map;
	    var list = omap._list;
	    var i = map.get(k);
	    var has = i !== undefined;
	    var newMap;
	    var newList;
	    if (v === NOT_SET) { // removed
	      if (!has) {
	        return omap;
	      }
	      if (list.size >= SIZE && list.size >= map.size * 2) {
	        newList = list.filter(function(entry, idx)  {return entry !== undefined && i !== idx});
	        newMap = newList.toKeyedSeq().map(function(entry ) {return entry[0]}).flip().toMap();
	        if (omap.__ownerID) {
	          newMap.__ownerID = newList.__ownerID = omap.__ownerID;
	        }
	      } else {
	        newMap = map.remove(k);
	        newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);
	      }
	    } else {
	      if (has) {
	        if (v === list.get(i)[1]) {
	          return omap;
	        }
	        newMap = map;
	        newList = list.set(i, [k, v]);
	      } else {
	        newMap = map.set(k, list.size);
	        newList = list.set(list.size, [k, v]);
	      }
	    }
	    if (omap.__ownerID) {
	      omap.size = newMap.size;
	      omap._map = newMap;
	      omap._list = newList;
	      omap.__hash = undefined;
	      return omap;
	    }
	    return makeOrderedMap(newMap, newList);
	  }

	  createClass(ToKeyedSequence, KeyedSeq);
	    function ToKeyedSequence(indexed, useKeys) {
	      this._iter = indexed;
	      this._useKeys = useKeys;
	      this.size = indexed.size;
	    }

	    ToKeyedSequence.prototype.get = function(key, notSetValue) {
	      return this._iter.get(key, notSetValue);
	    };

	    ToKeyedSequence.prototype.has = function(key) {
	      return this._iter.has(key);
	    };

	    ToKeyedSequence.prototype.valueSeq = function() {
	      return this._iter.valueSeq();
	    };

	    ToKeyedSequence.prototype.reverse = function() {var this$0 = this;
	      var reversedSequence = reverseFactory(this, true);
	      if (!this._useKeys) {
	        reversedSequence.valueSeq = function()  {return this$0._iter.toSeq().reverse()};
	      }
	      return reversedSequence;
	    };

	    ToKeyedSequence.prototype.map = function(mapper, context) {var this$0 = this;
	      var mappedSequence = mapFactory(this, mapper, context);
	      if (!this._useKeys) {
	        mappedSequence.valueSeq = function()  {return this$0._iter.toSeq().map(mapper, context)};
	      }
	      return mappedSequence;
	    };

	    ToKeyedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      var ii;
	      return this._iter.__iterate(
	        this._useKeys ?
	          function(v, k)  {return fn(v, k, this$0)} :
	          ((ii = reverse ? resolveSize(this) : 0),
	            function(v ) {return fn(v, reverse ? --ii : ii++, this$0)}),
	        reverse
	      );
	    };

	    ToKeyedSequence.prototype.__iterator = function(type, reverse) {
	      if (this._useKeys) {
	        return this._iter.__iterator(type, reverse);
	      }
	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	      var ii = reverse ? resolveSize(this) : 0;
	      return new Iterator(function()  {
	        var step = iterator.next();
	        return step.done ? step :
	          iteratorValue(type, reverse ? --ii : ii++, step.value, step);
	      });
	    };

	  ToKeyedSequence.prototype[IS_ORDERED_SENTINEL] = true;


	  createClass(ToIndexedSequence, IndexedSeq);
	    function ToIndexedSequence(iter) {
	      this._iter = iter;
	      this.size = iter.size;
	    }

	    ToIndexedSequence.prototype.includes = function(value) {
	      return this._iter.includes(value);
	    };

	    ToIndexedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      var iterations = 0;
	      return this._iter.__iterate(function(v ) {return fn(v, iterations++, this$0)}, reverse);
	    };

	    ToIndexedSequence.prototype.__iterator = function(type, reverse) {
	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	      var iterations = 0;
	      return new Iterator(function()  {
	        var step = iterator.next();
	        return step.done ? step :
	          iteratorValue(type, iterations++, step.value, step)
	      });
	    };



	  createClass(ToSetSequence, SetSeq);
	    function ToSetSequence(iter) {
	      this._iter = iter;
	      this.size = iter.size;
	    }

	    ToSetSequence.prototype.has = function(key) {
	      return this._iter.includes(key);
	    };

	    ToSetSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return this._iter.__iterate(function(v ) {return fn(v, v, this$0)}, reverse);
	    };

	    ToSetSequence.prototype.__iterator = function(type, reverse) {
	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	      return new Iterator(function()  {
	        var step = iterator.next();
	        return step.done ? step :
	          iteratorValue(type, step.value, step.value, step);
	      });
	    };



	  createClass(FromEntriesSequence, KeyedSeq);
	    function FromEntriesSequence(entries) {
	      this._iter = entries;
	      this.size = entries.size;
	    }

	    FromEntriesSequence.prototype.entrySeq = function() {
	      return this._iter.toSeq();
	    };

	    FromEntriesSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return this._iter.__iterate(function(entry ) {
	        // Check if entry exists first so array access doesn't throw for holes
	        // in the parent iteration.
	        if (entry) {
	          validateEntry(entry);
	          var indexedIterable = isIterable(entry);
	          return fn(
	            indexedIterable ? entry.get(1) : entry[1],
	            indexedIterable ? entry.get(0) : entry[0],
	            this$0
	          );
	        }
	      }, reverse);
	    };

	    FromEntriesSequence.prototype.__iterator = function(type, reverse) {
	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	      return new Iterator(function()  {
	        while (true) {
	          var step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	          var entry = step.value;
	          // Check if entry exists first so array access doesn't throw for holes
	          // in the parent iteration.
	          if (entry) {
	            validateEntry(entry);
	            var indexedIterable = isIterable(entry);
	            return iteratorValue(
	              type,
	              indexedIterable ? entry.get(0) : entry[0],
	              indexedIterable ? entry.get(1) : entry[1],
	              step
	            );
	          }
	        }
	      });
	    };


	  ToIndexedSequence.prototype.cacheResult =
	  ToKeyedSequence.prototype.cacheResult =
	  ToSetSequence.prototype.cacheResult =
	  FromEntriesSequence.prototype.cacheResult =
	    cacheResultThrough;


	  function flipFactory(iterable) {
	    var flipSequence = makeSequence(iterable);
	    flipSequence._iter = iterable;
	    flipSequence.size = iterable.size;
	    flipSequence.flip = function()  {return iterable};
	    flipSequence.reverse = function () {
	      var reversedSequence = iterable.reverse.apply(this); // super.reverse()
	      reversedSequence.flip = function()  {return iterable.reverse()};
	      return reversedSequence;
	    };
	    flipSequence.has = function(key ) {return iterable.includes(key)};
	    flipSequence.includes = function(key ) {return iterable.has(key)};
	    flipSequence.cacheResult = cacheResultThrough;
	    flipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
	      return iterable.__iterate(function(v, k)  {return fn(k, v, this$0) !== false}, reverse);
	    }
	    flipSequence.__iteratorUncached = function(type, reverse) {
	      if (type === ITERATE_ENTRIES) {
	        var iterator = iterable.__iterator(type, reverse);
	        return new Iterator(function()  {
	          var step = iterator.next();
	          if (!step.done) {
	            var k = step.value[0];
	            step.value[0] = step.value[1];
	            step.value[1] = k;
	          }
	          return step;
	        });
	      }
	      return iterable.__iterator(
	        type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES,
	        reverse
	      );
	    }
	    return flipSequence;
	  }


	  function mapFactory(iterable, mapper, context) {
	    var mappedSequence = makeSequence(iterable);
	    mappedSequence.size = iterable.size;
	    mappedSequence.has = function(key ) {return iterable.has(key)};
	    mappedSequence.get = function(key, notSetValue)  {
	      var v = iterable.get(key, NOT_SET);
	      return v === NOT_SET ?
	        notSetValue :
	        mapper.call(context, v, key, iterable);
	    };
	    mappedSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
	      return iterable.__iterate(
	        function(v, k, c)  {return fn(mapper.call(context, v, k, c), k, this$0) !== false},
	        reverse
	      );
	    }
	    mappedSequence.__iteratorUncached = function (type, reverse) {
	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
	      return new Iterator(function()  {
	        var step = iterator.next();
	        if (step.done) {
	          return step;
	        }
	        var entry = step.value;
	        var key = entry[0];
	        return iteratorValue(
	          type,
	          key,
	          mapper.call(context, entry[1], key, iterable),
	          step
	        );
	      });
	    }
	    return mappedSequence;
	  }


	  function reverseFactory(iterable, useKeys) {
	    var reversedSequence = makeSequence(iterable);
	    reversedSequence._iter = iterable;
	    reversedSequence.size = iterable.size;
	    reversedSequence.reverse = function()  {return iterable};
	    if (iterable.flip) {
	      reversedSequence.flip = function () {
	        var flipSequence = flipFactory(iterable);
	        flipSequence.reverse = function()  {return iterable.flip()};
	        return flipSequence;
	      };
	    }
	    reversedSequence.get = function(key, notSetValue) 
	      {return iterable.get(useKeys ? key : -1 - key, notSetValue)};
	    reversedSequence.has = function(key )
	      {return iterable.has(useKeys ? key : -1 - key)};
	    reversedSequence.includes = function(value ) {return iterable.includes(value)};
	    reversedSequence.cacheResult = cacheResultThrough;
	    reversedSequence.__iterate = function (fn, reverse) {var this$0 = this;
	      return iterable.__iterate(function(v, k)  {return fn(v, k, this$0)}, !reverse);
	    };
	    reversedSequence.__iterator =
	      function(type, reverse)  {return iterable.__iterator(type, !reverse)};
	    return reversedSequence;
	  }


	  function filterFactory(iterable, predicate, context, useKeys) {
	    var filterSequence = makeSequence(iterable);
	    if (useKeys) {
	      filterSequence.has = function(key ) {
	        var v = iterable.get(key, NOT_SET);
	        return v !== NOT_SET && !!predicate.call(context, v, key, iterable);
	      };
	      filterSequence.get = function(key, notSetValue)  {
	        var v = iterable.get(key, NOT_SET);
	        return v !== NOT_SET && predicate.call(context, v, key, iterable) ?
	          v : notSetValue;
	      };
	    }
	    filterSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
	      var iterations = 0;
	      iterable.__iterate(function(v, k, c)  {
	        if (predicate.call(context, v, k, c)) {
	          iterations++;
	          return fn(v, useKeys ? k : iterations - 1, this$0);
	        }
	      }, reverse);
	      return iterations;
	    };
	    filterSequence.__iteratorUncached = function (type, reverse) {
	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
	      var iterations = 0;
	      return new Iterator(function()  {
	        while (true) {
	          var step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	          var entry = step.value;
	          var key = entry[0];
	          var value = entry[1];
	          if (predicate.call(context, value, key, iterable)) {
	            return iteratorValue(type, useKeys ? key : iterations++, value, step);
	          }
	        }
	      });
	    }
	    return filterSequence;
	  }


	  function countByFactory(iterable, grouper, context) {
	    var groups = Map().asMutable();
	    iterable.__iterate(function(v, k)  {
	      groups.update(
	        grouper.call(context, v, k, iterable),
	        0,
	        function(a ) {return a + 1}
	      );
	    });
	    return groups.asImmutable();
	  }


	  function groupByFactory(iterable, grouper, context) {
	    var isKeyedIter = isKeyed(iterable);
	    var groups = (isOrdered(iterable) ? OrderedMap() : Map()).asMutable();
	    iterable.__iterate(function(v, k)  {
	      groups.update(
	        grouper.call(context, v, k, iterable),
	        function(a ) {return (a = a || [], a.push(isKeyedIter ? [k, v] : v), a)}
	      );
	    });
	    var coerce = iterableClass(iterable);
	    return groups.map(function(arr ) {return reify(iterable, coerce(arr))});
	  }


	  function sliceFactory(iterable, begin, end, useKeys) {
	    var originalSize = iterable.size;

	    // Sanitize begin & end using this shorthand for ToInt32(argument)
	    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
	    if (begin !== undefined) {
	      begin = begin | 0;
	    }
	    if (end !== undefined) {
	      end = end | 0;
	    }

	    if (wholeSlice(begin, end, originalSize)) {
	      return iterable;
	    }

	    var resolvedBegin = resolveBegin(begin, originalSize);
	    var resolvedEnd = resolveEnd(end, originalSize);

	    // begin or end will be NaN if they were provided as negative numbers and
	    // this iterable's size is unknown. In that case, cache first so there is
	    // a known size and these do not resolve to NaN.
	    if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {
	      return sliceFactory(iterable.toSeq().cacheResult(), begin, end, useKeys);
	    }

	    // Note: resolvedEnd is undefined when the original sequence's length is
	    // unknown and this slice did not supply an end and should contain all
	    // elements after resolvedBegin.
	    // In that case, resolvedSize will be NaN and sliceSize will remain undefined.
	    var resolvedSize = resolvedEnd - resolvedBegin;
	    var sliceSize;
	    if (resolvedSize === resolvedSize) {
	      sliceSize = resolvedSize < 0 ? 0 : resolvedSize;
	    }

	    var sliceSeq = makeSequence(iterable);

	    // If iterable.size is undefined, the size of the realized sliceSeq is
	    // unknown at this point unless the number of items to slice is 0
	    sliceSeq.size = sliceSize === 0 ? sliceSize : iterable.size && sliceSize || undefined;

	    if (!useKeys && isSeq(iterable) && sliceSize >= 0) {
	      sliceSeq.get = function (index, notSetValue) {
	        index = wrapIndex(this, index);
	        return index >= 0 && index < sliceSize ?
	          iterable.get(index + resolvedBegin, notSetValue) :
	          notSetValue;
	      }
	    }

	    sliceSeq.__iterateUncached = function(fn, reverse) {var this$0 = this;
	      if (sliceSize === 0) {
	        return 0;
	      }
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var skipped = 0;
	      var isSkipping = true;
	      var iterations = 0;
	      iterable.__iterate(function(v, k)  {
	        if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {
	          iterations++;
	          return fn(v, useKeys ? k : iterations - 1, this$0) !== false &&
	                 iterations !== sliceSize;
	        }
	      });
	      return iterations;
	    };

	    sliceSeq.__iteratorUncached = function(type, reverse) {
	      if (sliceSize !== 0 && reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      // Don't bother instantiating parent iterator if taking 0.
	      var iterator = sliceSize !== 0 && iterable.__iterator(type, reverse);
	      var skipped = 0;
	      var iterations = 0;
	      return new Iterator(function()  {
	        while (skipped++ < resolvedBegin) {
	          iterator.next();
	        }
	        if (++iterations > sliceSize) {
	          return iteratorDone();
	        }
	        var step = iterator.next();
	        if (useKeys || type === ITERATE_VALUES) {
	          return step;
	        } else if (type === ITERATE_KEYS) {
	          return iteratorValue(type, iterations - 1, undefined, step);
	        } else {
	          return iteratorValue(type, iterations - 1, step.value[1], step);
	        }
	      });
	    }

	    return sliceSeq;
	  }


	  function takeWhileFactory(iterable, predicate, context) {
	    var takeSequence = makeSequence(iterable);
	    takeSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var iterations = 0;
	      iterable.__iterate(function(v, k, c) 
	        {return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$0)}
	      );
	      return iterations;
	    };
	    takeSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
	      var iterating = true;
	      return new Iterator(function()  {
	        if (!iterating) {
	          return iteratorDone();
	        }
	        var step = iterator.next();
	        if (step.done) {
	          return step;
	        }
	        var entry = step.value;
	        var k = entry[0];
	        var v = entry[1];
	        if (!predicate.call(context, v, k, this$0)) {
	          iterating = false;
	          return iteratorDone();
	        }
	        return type === ITERATE_ENTRIES ? step :
	          iteratorValue(type, k, v, step);
	      });
	    };
	    return takeSequence;
	  }


	  function skipWhileFactory(iterable, predicate, context, useKeys) {
	    var skipSequence = makeSequence(iterable);
	    skipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var isSkipping = true;
	      var iterations = 0;
	      iterable.__iterate(function(v, k, c)  {
	        if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {
	          iterations++;
	          return fn(v, useKeys ? k : iterations - 1, this$0);
	        }
	      });
	      return iterations;
	    };
	    skipSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
	      var skipping = true;
	      var iterations = 0;
	      return new Iterator(function()  {
	        var step, k, v;
	        do {
	          step = iterator.next();
	          if (step.done) {
	            if (useKeys || type === ITERATE_VALUES) {
	              return step;
	            } else if (type === ITERATE_KEYS) {
	              return iteratorValue(type, iterations++, undefined, step);
	            } else {
	              return iteratorValue(type, iterations++, step.value[1], step);
	            }
	          }
	          var entry = step.value;
	          k = entry[0];
	          v = entry[1];
	          skipping && (skipping = predicate.call(context, v, k, this$0));
	        } while (skipping);
	        return type === ITERATE_ENTRIES ? step :
	          iteratorValue(type, k, v, step);
	      });
	    };
	    return skipSequence;
	  }


	  function concatFactory(iterable, values) {
	    var isKeyedIterable = isKeyed(iterable);
	    var iters = [iterable].concat(values).map(function(v ) {
	      if (!isIterable(v)) {
	        v = isKeyedIterable ?
	          keyedSeqFromValue(v) :
	          indexedSeqFromValue(Array.isArray(v) ? v : [v]);
	      } else if (isKeyedIterable) {
	        v = KeyedIterable(v);
	      }
	      return v;
	    }).filter(function(v ) {return v.size !== 0});

	    if (iters.length === 0) {
	      return iterable;
	    }

	    if (iters.length === 1) {
	      var singleton = iters[0];
	      if (singleton === iterable ||
	          isKeyedIterable && isKeyed(singleton) ||
	          isIndexed(iterable) && isIndexed(singleton)) {
	        return singleton;
	      }
	    }

	    var concatSeq = new ArraySeq(iters);
	    if (isKeyedIterable) {
	      concatSeq = concatSeq.toKeyedSeq();
	    } else if (!isIndexed(iterable)) {
	      concatSeq = concatSeq.toSetSeq();
	    }
	    concatSeq = concatSeq.flatten(true);
	    concatSeq.size = iters.reduce(
	      function(sum, seq)  {
	        if (sum !== undefined) {
	          var size = seq.size;
	          if (size !== undefined) {
	            return sum + size;
	          }
	        }
	      },
	      0
	    );
	    return concatSeq;
	  }


	  function flattenFactory(iterable, depth, useKeys) {
	    var flatSequence = makeSequence(iterable);
	    flatSequence.__iterateUncached = function(fn, reverse) {
	      var iterations = 0;
	      var stopped = false;
	      function flatDeep(iter, currentDepth) {var this$0 = this;
	        iter.__iterate(function(v, k)  {
	          if ((!depth || currentDepth < depth) && isIterable(v)) {
	            flatDeep(v, currentDepth + 1);
	          } else if (fn(v, useKeys ? k : iterations++, this$0) === false) {
	            stopped = true;
	          }
	          return !stopped;
	        }, reverse);
	      }
	      flatDeep(iterable, 0);
	      return iterations;
	    }
	    flatSequence.__iteratorUncached = function(type, reverse) {
	      var iterator = iterable.__iterator(type, reverse);
	      var stack = [];
	      var iterations = 0;
	      return new Iterator(function()  {
	        while (iterator) {
	          var step = iterator.next();
	          if (step.done !== false) {
	            iterator = stack.pop();
	            continue;
	          }
	          var v = step.value;
	          if (type === ITERATE_ENTRIES) {
	            v = v[1];
	          }
	          if ((!depth || stack.length < depth) && isIterable(v)) {
	            stack.push(iterator);
	            iterator = v.__iterator(type, reverse);
	          } else {
	            return useKeys ? step : iteratorValue(type, iterations++, v, step);
	          }
	        }
	        return iteratorDone();
	      });
	    }
	    return flatSequence;
	  }


	  function flatMapFactory(iterable, mapper, context) {
	    var coerce = iterableClass(iterable);
	    return iterable.toSeq().map(
	      function(v, k)  {return coerce(mapper.call(context, v, k, iterable))}
	    ).flatten(true);
	  }


	  function interposeFactory(iterable, separator) {
	    var interposedSequence = makeSequence(iterable);
	    interposedSequence.size = iterable.size && iterable.size * 2 -1;
	    interposedSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;
	      var iterations = 0;
	      iterable.__iterate(function(v, k) 
	        {return (!iterations || fn(separator, iterations++, this$0) !== false) &&
	        fn(v, iterations++, this$0) !== false},
	        reverse
	      );
	      return iterations;
	    };
	    interposedSequence.__iteratorUncached = function(type, reverse) {
	      var iterator = iterable.__iterator(ITERATE_VALUES, reverse);
	      var iterations = 0;
	      var step;
	      return new Iterator(function()  {
	        if (!step || iterations % 2) {
	          step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	        }
	        return iterations % 2 ?
	          iteratorValue(type, iterations++, separator) :
	          iteratorValue(type, iterations++, step.value, step);
	      });
	    };
	    return interposedSequence;
	  }


	  function sortFactory(iterable, comparator, mapper) {
	    if (!comparator) {
	      comparator = defaultComparator;
	    }
	    var isKeyedIterable = isKeyed(iterable);
	    var index = 0;
	    var entries = iterable.toSeq().map(
	      function(v, k)  {return [k, v, index++, mapper ? mapper(v, k, iterable) : v]}
	    ).toArray();
	    entries.sort(function(a, b)  {return comparator(a[3], b[3]) || a[2] - b[2]}).forEach(
	      isKeyedIterable ?
	      function(v, i)  { entries[i].length = 2; } :
	      function(v, i)  { entries[i] = v[1]; }
	    );
	    return isKeyedIterable ? KeyedSeq(entries) :
	      isIndexed(iterable) ? IndexedSeq(entries) :
	      SetSeq(entries);
	  }


	  function maxFactory(iterable, comparator, mapper) {
	    if (!comparator) {
	      comparator = defaultComparator;
	    }
	    if (mapper) {
	      var entry = iterable.toSeq()
	        .map(function(v, k)  {return [v, mapper(v, k, iterable)]})
	        .reduce(function(a, b)  {return maxCompare(comparator, a[1], b[1]) ? b : a});
	      return entry && entry[0];
	    } else {
	      return iterable.reduce(function(a, b)  {return maxCompare(comparator, a, b) ? b : a});
	    }
	  }

	  function maxCompare(comparator, a, b) {
	    var comp = comparator(b, a);
	    // b is considered the new max if the comparator declares them equal, but
	    // they are not equal and b is in fact a nullish value.
	    return (comp === 0 && b !== a && (b === undefined || b === null || b !== b)) || comp > 0;
	  }


	  function zipWithFactory(keyIter, zipper, iters) {
	    var zipSequence = makeSequence(keyIter);
	    zipSequence.size = new ArraySeq(iters).map(function(i ) {return i.size}).min();
	    // Note: this a generic base implementation of __iterate in terms of
	    // __iterator which may be more generically useful in the future.
	    zipSequence.__iterate = function(fn, reverse) {
	      /* generic:
	      var iterator = this.__iterator(ITERATE_ENTRIES, reverse);
	      var step;
	      var iterations = 0;
	      while (!(step = iterator.next()).done) {
	        iterations++;
	        if (fn(step.value[1], step.value[0], this) === false) {
	          break;
	        }
	      }
	      return iterations;
	      */
	      // indexed:
	      var iterator = this.__iterator(ITERATE_VALUES, reverse);
	      var step;
	      var iterations = 0;
	      while (!(step = iterator.next()).done) {
	        if (fn(step.value, iterations++, this) === false) {
	          break;
	        }
	      }
	      return iterations;
	    };
	    zipSequence.__iteratorUncached = function(type, reverse) {
	      var iterators = iters.map(function(i )
	        {return (i = Iterable(i), getIterator(reverse ? i.reverse() : i))}
	      );
	      var iterations = 0;
	      var isDone = false;
	      return new Iterator(function()  {
	        var steps;
	        if (!isDone) {
	          steps = iterators.map(function(i ) {return i.next()});
	          isDone = steps.some(function(s ) {return s.done});
	        }
	        if (isDone) {
	          return iteratorDone();
	        }
	        return iteratorValue(
	          type,
	          iterations++,
	          zipper.apply(null, steps.map(function(s ) {return s.value}))
	        );
	      });
	    };
	    return zipSequence
	  }


	  // #pragma Helper Functions

	  function reify(iter, seq) {
	    return isSeq(iter) ? seq : iter.constructor(seq);
	  }

	  function validateEntry(entry) {
	    if (entry !== Object(entry)) {
	      throw new TypeError('Expected [K, V] tuple: ' + entry);
	    }
	  }

	  function resolveSize(iter) {
	    assertNotInfinite(iter.size);
	    return ensureSize(iter);
	  }

	  function iterableClass(iterable) {
	    return isKeyed(iterable) ? KeyedIterable :
	      isIndexed(iterable) ? IndexedIterable :
	      SetIterable;
	  }

	  function makeSequence(iterable) {
	    return Object.create(
	      (
	        isKeyed(iterable) ? KeyedSeq :
	        isIndexed(iterable) ? IndexedSeq :
	        SetSeq
	      ).prototype
	    );
	  }

	  function cacheResultThrough() {
	    if (this._iter.cacheResult) {
	      this._iter.cacheResult();
	      this.size = this._iter.size;
	      return this;
	    } else {
	      return Seq.prototype.cacheResult.call(this);
	    }
	  }

	  function defaultComparator(a, b) {
	    return a > b ? 1 : a < b ? -1 : 0;
	  }

	  function forceIterator(keyPath) {
	    var iter = getIterator(keyPath);
	    if (!iter) {
	      // Array might not be iterable in this environment, so we need a fallback
	      // to our wrapped type.
	      if (!isArrayLike(keyPath)) {
	        throw new TypeError('Expected iterable or array-like: ' + keyPath);
	      }
	      iter = getIterator(Iterable(keyPath));
	    }
	    return iter;
	  }

	  createClass(Record, KeyedCollection);

	    function Record(defaultValues, name) {
	      var hasInitialized;

	      var RecordType = function Record(values) {
	        if (values instanceof RecordType) {
	          return values;
	        }
	        if (!(this instanceof RecordType)) {
	          return new RecordType(values);
	        }
	        if (!hasInitialized) {
	          hasInitialized = true;
	          var keys = Object.keys(defaultValues);
	          setProps(RecordTypePrototype, keys);
	          RecordTypePrototype.size = keys.length;
	          RecordTypePrototype._name = name;
	          RecordTypePrototype._keys = keys;
	          RecordTypePrototype._defaultValues = defaultValues;
	        }
	        this._map = Map(values);
	      };

	      var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);
	      RecordTypePrototype.constructor = RecordType;

	      return RecordType;
	    }

	    Record.prototype.toString = function() {
	      return this.__toString(recordName(this) + ' {', '}');
	    };

	    // @pragma Access

	    Record.prototype.has = function(k) {
	      return this._defaultValues.hasOwnProperty(k);
	    };

	    Record.prototype.get = function(k, notSetValue) {
	      if (!this.has(k)) {
	        return notSetValue;
	      }
	      var defaultVal = this._defaultValues[k];
	      return this._map ? this._map.get(k, defaultVal) : defaultVal;
	    };

	    // @pragma Modification

	    Record.prototype.clear = function() {
	      if (this.__ownerID) {
	        this._map && this._map.clear();
	        return this;
	      }
	      var RecordType = this.constructor;
	      return RecordType._empty || (RecordType._empty = makeRecord(this, emptyMap()));
	    };

	    Record.prototype.set = function(k, v) {
	      if (!this.has(k)) {
	        throw new Error('Cannot set unknown key "' + k + '" on ' + recordName(this));
	      }
	      var newMap = this._map && this._map.set(k, v);
	      if (this.__ownerID || newMap === this._map) {
	        return this;
	      }
	      return makeRecord(this, newMap);
	    };

	    Record.prototype.remove = function(k) {
	      if (!this.has(k)) {
	        return this;
	      }
	      var newMap = this._map && this._map.remove(k);
	      if (this.__ownerID || newMap === this._map) {
	        return this;
	      }
	      return makeRecord(this, newMap);
	    };

	    Record.prototype.wasAltered = function() {
	      return this._map.wasAltered();
	    };

	    Record.prototype.__iterator = function(type, reverse) {var this$0 = this;
	      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterator(type, reverse);
	    };

	    Record.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterate(fn, reverse);
	    };

	    Record.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      var newMap = this._map && this._map.__ensureOwner(ownerID);
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this._map = newMap;
	        return this;
	      }
	      return makeRecord(this, newMap, ownerID);
	    };


	  var RecordPrototype = Record.prototype;
	  RecordPrototype[DELETE] = RecordPrototype.remove;
	  RecordPrototype.deleteIn =
	  RecordPrototype.removeIn = MapPrototype.removeIn;
	  RecordPrototype.merge = MapPrototype.merge;
	  RecordPrototype.mergeWith = MapPrototype.mergeWith;
	  RecordPrototype.mergeIn = MapPrototype.mergeIn;
	  RecordPrototype.mergeDeep = MapPrototype.mergeDeep;
	  RecordPrototype.mergeDeepWith = MapPrototype.mergeDeepWith;
	  RecordPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
	  RecordPrototype.setIn = MapPrototype.setIn;
	  RecordPrototype.update = MapPrototype.update;
	  RecordPrototype.updateIn = MapPrototype.updateIn;
	  RecordPrototype.withMutations = MapPrototype.withMutations;
	  RecordPrototype.asMutable = MapPrototype.asMutable;
	  RecordPrototype.asImmutable = MapPrototype.asImmutable;


	  function makeRecord(likeRecord, map, ownerID) {
	    var record = Object.create(Object.getPrototypeOf(likeRecord));
	    record._map = map;
	    record.__ownerID = ownerID;
	    return record;
	  }

	  function recordName(record) {
	    return record._name || record.constructor.name || 'Record';
	  }

	  function setProps(prototype, names) {
	    try {
	      names.forEach(setProp.bind(undefined, prototype));
	    } catch (error) {
	      // Object.defineProperty failed. Probably IE8.
	    }
	  }

	  function setProp(prototype, name) {
	    Object.defineProperty(prototype, name, {
	      get: function() {
	        return this.get(name);
	      },
	      set: function(value) {
	        invariant(this.__ownerID, 'Cannot set on an immutable record.');
	        this.set(name, value);
	      }
	    });
	  }

	  createClass(Set, SetCollection);

	    // @pragma Construction

	    function Set(value) {
	      return value === null || value === undefined ? emptySet() :
	        isSet(value) && !isOrdered(value) ? value :
	        emptySet().withMutations(function(set ) {
	          var iter = SetIterable(value);
	          assertNotInfinite(iter.size);
	          iter.forEach(function(v ) {return set.add(v)});
	        });
	    }

	    Set.of = function(/*...values*/) {
	      return this(arguments);
	    };

	    Set.fromKeys = function(value) {
	      return this(KeyedIterable(value).keySeq());
	    };

	    Set.prototype.toString = function() {
	      return this.__toString('Set {', '}');
	    };

	    // @pragma Access

	    Set.prototype.has = function(value) {
	      return this._map.has(value);
	    };

	    // @pragma Modification

	    Set.prototype.add = function(value) {
	      return updateSet(this, this._map.set(value, true));
	    };

	    Set.prototype.remove = function(value) {
	      return updateSet(this, this._map.remove(value));
	    };

	    Set.prototype.clear = function() {
	      return updateSet(this, this._map.clear());
	    };

	    // @pragma Composition

	    Set.prototype.union = function() {var iters = SLICE$0.call(arguments, 0);
	      iters = iters.filter(function(x ) {return x.size !== 0});
	      if (iters.length === 0) {
	        return this;
	      }
	      if (this.size === 0 && !this.__ownerID && iters.length === 1) {
	        return this.constructor(iters[0]);
	      }
	      return this.withMutations(function(set ) {
	        for (var ii = 0; ii < iters.length; ii++) {
	          SetIterable(iters[ii]).forEach(function(value ) {return set.add(value)});
	        }
	      });
	    };

	    Set.prototype.intersect = function() {var iters = SLICE$0.call(arguments, 0);
	      if (iters.length === 0) {
	        return this;
	      }
	      iters = iters.map(function(iter ) {return SetIterable(iter)});
	      var originalSet = this;
	      return this.withMutations(function(set ) {
	        originalSet.forEach(function(value ) {
	          if (!iters.every(function(iter ) {return iter.includes(value)})) {
	            set.remove(value);
	          }
	        });
	      });
	    };

	    Set.prototype.subtract = function() {var iters = SLICE$0.call(arguments, 0);
	      if (iters.length === 0) {
	        return this;
	      }
	      iters = iters.map(function(iter ) {return SetIterable(iter)});
	      var originalSet = this;
	      return this.withMutations(function(set ) {
	        originalSet.forEach(function(value ) {
	          if (iters.some(function(iter ) {return iter.includes(value)})) {
	            set.remove(value);
	          }
	        });
	      });
	    };

	    Set.prototype.merge = function() {
	      return this.union.apply(this, arguments);
	    };

	    Set.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return this.union.apply(this, iters);
	    };

	    Set.prototype.sort = function(comparator) {
	      // Late binding
	      return OrderedSet(sortFactory(this, comparator));
	    };

	    Set.prototype.sortBy = function(mapper, comparator) {
	      // Late binding
	      return OrderedSet(sortFactory(this, comparator, mapper));
	    };

	    Set.prototype.wasAltered = function() {
	      return this._map.wasAltered();
	    };

	    Set.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return this._map.__iterate(function(_, k)  {return fn(k, k, this$0)}, reverse);
	    };

	    Set.prototype.__iterator = function(type, reverse) {
	      return this._map.map(function(_, k)  {return k}).__iterator(type, reverse);
	    };

	    Set.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      var newMap = this._map.__ensureOwner(ownerID);
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this._map = newMap;
	        return this;
	      }
	      return this.__make(newMap, ownerID);
	    };


	  function isSet(maybeSet) {
	    return !!(maybeSet && maybeSet[IS_SET_SENTINEL]);
	  }

	  Set.isSet = isSet;

	  var IS_SET_SENTINEL = '@@__IMMUTABLE_SET__@@';

	  var SetPrototype = Set.prototype;
	  SetPrototype[IS_SET_SENTINEL] = true;
	  SetPrototype[DELETE] = SetPrototype.remove;
	  SetPrototype.mergeDeep = SetPrototype.merge;
	  SetPrototype.mergeDeepWith = SetPrototype.mergeWith;
	  SetPrototype.withMutations = MapPrototype.withMutations;
	  SetPrototype.asMutable = MapPrototype.asMutable;
	  SetPrototype.asImmutable = MapPrototype.asImmutable;

	  SetPrototype.__empty = emptySet;
	  SetPrototype.__make = makeSet;

	  function updateSet(set, newMap) {
	    if (set.__ownerID) {
	      set.size = newMap.size;
	      set._map = newMap;
	      return set;
	    }
	    return newMap === set._map ? set :
	      newMap.size === 0 ? set.__empty() :
	      set.__make(newMap);
	  }

	  function makeSet(map, ownerID) {
	    var set = Object.create(SetPrototype);
	    set.size = map ? map.size : 0;
	    set._map = map;
	    set.__ownerID = ownerID;
	    return set;
	  }

	  var EMPTY_SET;
	  function emptySet() {
	    return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));
	  }

	  createClass(OrderedSet, Set);

	    // @pragma Construction

	    function OrderedSet(value) {
	      return value === null || value === undefined ? emptyOrderedSet() :
	        isOrderedSet(value) ? value :
	        emptyOrderedSet().withMutations(function(set ) {
	          var iter = SetIterable(value);
	          assertNotInfinite(iter.size);
	          iter.forEach(function(v ) {return set.add(v)});
	        });
	    }

	    OrderedSet.of = function(/*...values*/) {
	      return this(arguments);
	    };

	    OrderedSet.fromKeys = function(value) {
	      return this(KeyedIterable(value).keySeq());
	    };

	    OrderedSet.prototype.toString = function() {
	      return this.__toString('OrderedSet {', '}');
	    };


	  function isOrderedSet(maybeOrderedSet) {
	    return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);
	  }

	  OrderedSet.isOrderedSet = isOrderedSet;

	  var OrderedSetPrototype = OrderedSet.prototype;
	  OrderedSetPrototype[IS_ORDERED_SENTINEL] = true;

	  OrderedSetPrototype.__empty = emptyOrderedSet;
	  OrderedSetPrototype.__make = makeOrderedSet;

	  function makeOrderedSet(map, ownerID) {
	    var set = Object.create(OrderedSetPrototype);
	    set.size = map ? map.size : 0;
	    set._map = map;
	    set.__ownerID = ownerID;
	    return set;
	  }

	  var EMPTY_ORDERED_SET;
	  function emptyOrderedSet() {
	    return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));
	  }

	  createClass(Stack, IndexedCollection);

	    // @pragma Construction

	    function Stack(value) {
	      return value === null || value === undefined ? emptyStack() :
	        isStack(value) ? value :
	        emptyStack().unshiftAll(value);
	    }

	    Stack.of = function(/*...values*/) {
	      return this(arguments);
	    };

	    Stack.prototype.toString = function() {
	      return this.__toString('Stack [', ']');
	    };

	    // @pragma Access

	    Stack.prototype.get = function(index, notSetValue) {
	      var head = this._head;
	      index = wrapIndex(this, index);
	      while (head && index--) {
	        head = head.next;
	      }
	      return head ? head.value : notSetValue;
	    };

	    Stack.prototype.peek = function() {
	      return this._head && this._head.value;
	    };

	    // @pragma Modification

	    Stack.prototype.push = function(/*...values*/) {
	      if (arguments.length === 0) {
	        return this;
	      }
	      var newSize = this.size + arguments.length;
	      var head = this._head;
	      for (var ii = arguments.length - 1; ii >= 0; ii--) {
	        head = {
	          value: arguments[ii],
	          next: head
	        };
	      }
	      if (this.__ownerID) {
	        this.size = newSize;
	        this._head = head;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return makeStack(newSize, head);
	    };

	    Stack.prototype.pushAll = function(iter) {
	      iter = IndexedIterable(iter);
	      if (iter.size === 0) {
	        return this;
	      }
	      assertNotInfinite(iter.size);
	      var newSize = this.size;
	      var head = this._head;
	      iter.reverse().forEach(function(value ) {
	        newSize++;
	        head = {
	          value: value,
	          next: head
	        };
	      });
	      if (this.__ownerID) {
	        this.size = newSize;
	        this._head = head;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return makeStack(newSize, head);
	    };

	    Stack.prototype.pop = function() {
	      return this.slice(1);
	    };

	    Stack.prototype.unshift = function(/*...values*/) {
	      return this.push.apply(this, arguments);
	    };

	    Stack.prototype.unshiftAll = function(iter) {
	      return this.pushAll(iter);
	    };

	    Stack.prototype.shift = function() {
	      return this.pop.apply(this, arguments);
	    };

	    Stack.prototype.clear = function() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = 0;
	        this._head = undefined;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return emptyStack();
	    };

	    Stack.prototype.slice = function(begin, end) {
	      if (wholeSlice(begin, end, this.size)) {
	        return this;
	      }
	      var resolvedBegin = resolveBegin(begin, this.size);
	      var resolvedEnd = resolveEnd(end, this.size);
	      if (resolvedEnd !== this.size) {
	        // super.slice(begin, end);
	        return IndexedCollection.prototype.slice.call(this, begin, end);
	      }
	      var newSize = this.size - resolvedBegin;
	      var head = this._head;
	      while (resolvedBegin--) {
	        head = head.next;
	      }
	      if (this.__ownerID) {
	        this.size = newSize;
	        this._head = head;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return makeStack(newSize, head);
	    };

	    // @pragma Mutability

	    Stack.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this.__altered = false;
	        return this;
	      }
	      return makeStack(this.size, this._head, ownerID, this.__hash);
	    };

	    // @pragma Iteration

	    Stack.prototype.__iterate = function(fn, reverse) {
	      if (reverse) {
	        return this.reverse().__iterate(fn);
	      }
	      var iterations = 0;
	      var node = this._head;
	      while (node) {
	        if (fn(node.value, iterations++, this) === false) {
	          break;
	        }
	        node = node.next;
	      }
	      return iterations;
	    };

	    Stack.prototype.__iterator = function(type, reverse) {
	      if (reverse) {
	        return this.reverse().__iterator(type);
	      }
	      var iterations = 0;
	      var node = this._head;
	      return new Iterator(function()  {
	        if (node) {
	          var value = node.value;
	          node = node.next;
	          return iteratorValue(type, iterations++, value);
	        }
	        return iteratorDone();
	      });
	    };


	  function isStack(maybeStack) {
	    return !!(maybeStack && maybeStack[IS_STACK_SENTINEL]);
	  }

	  Stack.isStack = isStack;

	  var IS_STACK_SENTINEL = '@@__IMMUTABLE_STACK__@@';

	  var StackPrototype = Stack.prototype;
	  StackPrototype[IS_STACK_SENTINEL] = true;
	  StackPrototype.withMutations = MapPrototype.withMutations;
	  StackPrototype.asMutable = MapPrototype.asMutable;
	  StackPrototype.asImmutable = MapPrototype.asImmutable;
	  StackPrototype.wasAltered = MapPrototype.wasAltered;


	  function makeStack(size, head, ownerID, hash) {
	    var map = Object.create(StackPrototype);
	    map.size = size;
	    map._head = head;
	    map.__ownerID = ownerID;
	    map.__hash = hash;
	    map.__altered = false;
	    return map;
	  }

	  var EMPTY_STACK;
	  function emptyStack() {
	    return EMPTY_STACK || (EMPTY_STACK = makeStack(0));
	  }

	  /**
	   * Contributes additional methods to a constructor
	   */
	  function mixin(ctor, methods) {
	    var keyCopier = function(key ) { ctor.prototype[key] = methods[key]; };
	    Object.keys(methods).forEach(keyCopier);
	    Object.getOwnPropertySymbols &&
	      Object.getOwnPropertySymbols(methods).forEach(keyCopier);
	    return ctor;
	  }

	  Iterable.Iterator = Iterator;

	  mixin(Iterable, {

	    // ### Conversion to other types

	    toArray: function() {
	      assertNotInfinite(this.size);
	      var array = new Array(this.size || 0);
	      this.valueSeq().__iterate(function(v, i)  { array[i] = v; });
	      return array;
	    },

	    toIndexedSeq: function() {
	      return new ToIndexedSequence(this);
	    },

	    toJS: function() {
	      return this.toSeq().map(
	        function(value ) {return value && typeof value.toJS === 'function' ? value.toJS() : value}
	      ).__toJS();
	    },

	    toJSON: function() {
	      return this.toSeq().map(
	        function(value ) {return value && typeof value.toJSON === 'function' ? value.toJSON() : value}
	      ).__toJS();
	    },

	    toKeyedSeq: function() {
	      return new ToKeyedSequence(this, true);
	    },

	    toMap: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return Map(this.toKeyedSeq());
	    },

	    toObject: function() {
	      assertNotInfinite(this.size);
	      var object = {};
	      this.__iterate(function(v, k)  { object[k] = v; });
	      return object;
	    },

	    toOrderedMap: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return OrderedMap(this.toKeyedSeq());
	    },

	    toOrderedSet: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return OrderedSet(isKeyed(this) ? this.valueSeq() : this);
	    },

	    toSet: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return Set(isKeyed(this) ? this.valueSeq() : this);
	    },

	    toSetSeq: function() {
	      return new ToSetSequence(this);
	    },

	    toSeq: function() {
	      return isIndexed(this) ? this.toIndexedSeq() :
	        isKeyed(this) ? this.toKeyedSeq() :
	        this.toSetSeq();
	    },

	    toStack: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return Stack(isKeyed(this) ? this.valueSeq() : this);
	    },

	    toList: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return List(isKeyed(this) ? this.valueSeq() : this);
	    },


	    // ### Common JavaScript methods and properties

	    toString: function() {
	      return '[Iterable]';
	    },

	    __toString: function(head, tail) {
	      if (this.size === 0) {
	        return head + tail;
	      }
	      return head + ' ' + this.toSeq().map(this.__toStringMapper).join(', ') + ' ' + tail;
	    },


	    // ### ES6 Collection methods (ES6 Array and Map)

	    concat: function() {var values = SLICE$0.call(arguments, 0);
	      return reify(this, concatFactory(this, values));
	    },

	    includes: function(searchValue) {
	      return this.some(function(value ) {return is(value, searchValue)});
	    },

	    entries: function() {
	      return this.__iterator(ITERATE_ENTRIES);
	    },

	    every: function(predicate, context) {
	      assertNotInfinite(this.size);
	      var returnValue = true;
	      this.__iterate(function(v, k, c)  {
	        if (!predicate.call(context, v, k, c)) {
	          returnValue = false;
	          return false;
	        }
	      });
	      return returnValue;
	    },

	    filter: function(predicate, context) {
	      return reify(this, filterFactory(this, predicate, context, true));
	    },

	    find: function(predicate, context, notSetValue) {
	      var entry = this.findEntry(predicate, context);
	      return entry ? entry[1] : notSetValue;
	    },

	    findEntry: function(predicate, context) {
	      var found;
	      this.__iterate(function(v, k, c)  {
	        if (predicate.call(context, v, k, c)) {
	          found = [k, v];
	          return false;
	        }
	      });
	      return found;
	    },

	    findLastEntry: function(predicate, context) {
	      return this.toSeq().reverse().findEntry(predicate, context);
	    },

	    forEach: function(sideEffect, context) {
	      assertNotInfinite(this.size);
	      return this.__iterate(context ? sideEffect.bind(context) : sideEffect);
	    },

	    join: function(separator) {
	      assertNotInfinite(this.size);
	      separator = separator !== undefined ? '' + separator : ',';
	      var joined = '';
	      var isFirst = true;
	      this.__iterate(function(v ) {
	        isFirst ? (isFirst = false) : (joined += separator);
	        joined += v !== null && v !== undefined ? v.toString() : '';
	      });
	      return joined;
	    },

	    keys: function() {
	      return this.__iterator(ITERATE_KEYS);
	    },

	    map: function(mapper, context) {
	      return reify(this, mapFactory(this, mapper, context));
	    },

	    reduce: function(reducer, initialReduction, context) {
	      assertNotInfinite(this.size);
	      var reduction;
	      var useFirst;
	      if (arguments.length < 2) {
	        useFirst = true;
	      } else {
	        reduction = initialReduction;
	      }
	      this.__iterate(function(v, k, c)  {
	        if (useFirst) {
	          useFirst = false;
	          reduction = v;
	        } else {
	          reduction = reducer.call(context, reduction, v, k, c);
	        }
	      });
	      return reduction;
	    },

	    reduceRight: function(reducer, initialReduction, context) {
	      var reversed = this.toKeyedSeq().reverse();
	      return reversed.reduce.apply(reversed, arguments);
	    },

	    reverse: function() {
	      return reify(this, reverseFactory(this, true));
	    },

	    slice: function(begin, end) {
	      return reify(this, sliceFactory(this, begin, end, true));
	    },

	    some: function(predicate, context) {
	      return !this.every(not(predicate), context);
	    },

	    sort: function(comparator) {
	      return reify(this, sortFactory(this, comparator));
	    },

	    values: function() {
	      return this.__iterator(ITERATE_VALUES);
	    },


	    // ### More sequential methods

	    butLast: function() {
	      return this.slice(0, -1);
	    },

	    isEmpty: function() {
	      return this.size !== undefined ? this.size === 0 : !this.some(function()  {return true});
	    },

	    count: function(predicate, context) {
	      return ensureSize(
	        predicate ? this.toSeq().filter(predicate, context) : this
	      );
	    },

	    countBy: function(grouper, context) {
	      return countByFactory(this, grouper, context);
	    },

	    equals: function(other) {
	      return deepEqual(this, other);
	    },

	    entrySeq: function() {
	      var iterable = this;
	      if (iterable._cache) {
	        // We cache as an entries array, so we can just return the cache!
	        return new ArraySeq(iterable._cache);
	      }
	      var entriesSequence = iterable.toSeq().map(entryMapper).toIndexedSeq();
	      entriesSequence.fromEntrySeq = function()  {return iterable.toSeq()};
	      return entriesSequence;
	    },

	    filterNot: function(predicate, context) {
	      return this.filter(not(predicate), context);
	    },

	    findLast: function(predicate, context, notSetValue) {
	      return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);
	    },

	    first: function() {
	      return this.find(returnTrue);
	    },

	    flatMap: function(mapper, context) {
	      return reify(this, flatMapFactory(this, mapper, context));
	    },

	    flatten: function(depth) {
	      return reify(this, flattenFactory(this, depth, true));
	    },

	    fromEntrySeq: function() {
	      return new FromEntriesSequence(this);
	    },

	    get: function(searchKey, notSetValue) {
	      return this.find(function(_, key)  {return is(key, searchKey)}, undefined, notSetValue);
	    },

	    getIn: function(searchKeyPath, notSetValue) {
	      var nested = this;
	      // Note: in an ES6 environment, we would prefer:
	      // for (var key of searchKeyPath) {
	      var iter = forceIterator(searchKeyPath);
	      var step;
	      while (!(step = iter.next()).done) {
	        var key = step.value;
	        nested = nested && nested.get ? nested.get(key, NOT_SET) : NOT_SET;
	        if (nested === NOT_SET) {
	          return notSetValue;
	        }
	      }
	      return nested;
	    },

	    groupBy: function(grouper, context) {
	      return groupByFactory(this, grouper, context);
	    },

	    has: function(searchKey) {
	      return this.get(searchKey, NOT_SET) !== NOT_SET;
	    },

	    hasIn: function(searchKeyPath) {
	      return this.getIn(searchKeyPath, NOT_SET) !== NOT_SET;
	    },

	    isSubset: function(iter) {
	      iter = typeof iter.includes === 'function' ? iter : Iterable(iter);
	      return this.every(function(value ) {return iter.includes(value)});
	    },

	    isSuperset: function(iter) {
	      iter = typeof iter.isSubset === 'function' ? iter : Iterable(iter);
	      return iter.isSubset(this);
	    },

	    keySeq: function() {
	      return this.toSeq().map(keyMapper).toIndexedSeq();
	    },

	    last: function() {
	      return this.toSeq().reverse().first();
	    },

	    max: function(comparator) {
	      return maxFactory(this, comparator);
	    },

	    maxBy: function(mapper, comparator) {
	      return maxFactory(this, comparator, mapper);
	    },

	    min: function(comparator) {
	      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator);
	    },

	    minBy: function(mapper, comparator) {
	      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator, mapper);
	    },

	    rest: function() {
	      return this.slice(1);
	    },

	    skip: function(amount) {
	      return this.slice(Math.max(0, amount));
	    },

	    skipLast: function(amount) {
	      return reify(this, this.toSeq().reverse().skip(amount).reverse());
	    },

	    skipWhile: function(predicate, context) {
	      return reify(this, skipWhileFactory(this, predicate, context, true));
	    },

	    skipUntil: function(predicate, context) {
	      return this.skipWhile(not(predicate), context);
	    },

	    sortBy: function(mapper, comparator) {
	      return reify(this, sortFactory(this, comparator, mapper));
	    },

	    take: function(amount) {
	      return this.slice(0, Math.max(0, amount));
	    },

	    takeLast: function(amount) {
	      return reify(this, this.toSeq().reverse().take(amount).reverse());
	    },

	    takeWhile: function(predicate, context) {
	      return reify(this, takeWhileFactory(this, predicate, context));
	    },

	    takeUntil: function(predicate, context) {
	      return this.takeWhile(not(predicate), context);
	    },

	    valueSeq: function() {
	      return this.toIndexedSeq();
	    },


	    // ### Hashable Object

	    hashCode: function() {
	      return this.__hash || (this.__hash = hashIterable(this));
	    }


	    // ### Internal

	    // abstract __iterate(fn, reverse)

	    // abstract __iterator(type, reverse)
	  });

	  // var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
	  // var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
	  // var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';
	  // var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';

	  var IterablePrototype = Iterable.prototype;
	  IterablePrototype[IS_ITERABLE_SENTINEL] = true;
	  IterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.values;
	  IterablePrototype.__toJS = IterablePrototype.toArray;
	  IterablePrototype.__toStringMapper = quoteString;
	  IterablePrototype.inspect =
	  IterablePrototype.toSource = function() { return this.toString(); };
	  IterablePrototype.chain = IterablePrototype.flatMap;
	  IterablePrototype.contains = IterablePrototype.includes;

	  // Temporary warning about using length
	  (function () {
	    try {
	      Object.defineProperty(IterablePrototype, 'length', {
	        get: function () {
	          if (!Iterable.noLengthWarning) {
	            var stack;
	            try {
	              throw new Error();
	            } catch (error) {
	              stack = error.stack;
	            }
	            if (stack.indexOf('_wrapObject') === -1) {
	              console && console.warn && console.warn(
	                'iterable.length has been deprecated, '+
	                'use iterable.size or iterable.count(). '+
	                'This warning will become a silent error in a future version. ' +
	                stack
	              );
	              return this.size;
	            }
	          }
	        }
	      });
	    } catch (e) {}
	  })();



	  mixin(KeyedIterable, {

	    // ### More sequential methods

	    flip: function() {
	      return reify(this, flipFactory(this));
	    },

	    findKey: function(predicate, context) {
	      var entry = this.findEntry(predicate, context);
	      return entry && entry[0];
	    },

	    findLastKey: function(predicate, context) {
	      return this.toSeq().reverse().findKey(predicate, context);
	    },

	    keyOf: function(searchValue) {
	      return this.findKey(function(value ) {return is(value, searchValue)});
	    },

	    lastKeyOf: function(searchValue) {
	      return this.findLastKey(function(value ) {return is(value, searchValue)});
	    },

	    mapEntries: function(mapper, context) {var this$0 = this;
	      var iterations = 0;
	      return reify(this,
	        this.toSeq().map(
	          function(v, k)  {return mapper.call(context, [k, v], iterations++, this$0)}
	        ).fromEntrySeq()
	      );
	    },

	    mapKeys: function(mapper, context) {var this$0 = this;
	      return reify(this,
	        this.toSeq().flip().map(
	          function(k, v)  {return mapper.call(context, k, v, this$0)}
	        ).flip()
	      );
	    }

	  });

	  var KeyedIterablePrototype = KeyedIterable.prototype;
	  KeyedIterablePrototype[IS_KEYED_SENTINEL] = true;
	  KeyedIterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.entries;
	  KeyedIterablePrototype.__toJS = IterablePrototype.toObject;
	  KeyedIterablePrototype.__toStringMapper = function(v, k)  {return JSON.stringify(k) + ': ' + quoteString(v)};



	  mixin(IndexedIterable, {

	    // ### Conversion to other types

	    toKeyedSeq: function() {
	      return new ToKeyedSequence(this, false);
	    },


	    // ### ES6 Collection methods (ES6 Array and Map)

	    filter: function(predicate, context) {
	      return reify(this, filterFactory(this, predicate, context, false));
	    },

	    findIndex: function(predicate, context) {
	      var entry = this.findEntry(predicate, context);
	      return entry ? entry[0] : -1;
	    },

	    indexOf: function(searchValue) {
	      var key = this.toKeyedSeq().keyOf(searchValue);
	      return key === undefined ? -1 : key;
	    },

	    lastIndexOf: function(searchValue) {
	      var key = this.toKeyedSeq().reverse().keyOf(searchValue);
	      return key === undefined ? -1 : key;

	      // var index =
	      // return this.toSeq().reverse().indexOf(searchValue);
	    },

	    reverse: function() {
	      return reify(this, reverseFactory(this, false));
	    },

	    slice: function(begin, end) {
	      return reify(this, sliceFactory(this, begin, end, false));
	    },

	    splice: function(index, removeNum /*, ...values*/) {
	      var numArgs = arguments.length;
	      removeNum = Math.max(removeNum | 0, 0);
	      if (numArgs === 0 || (numArgs === 2 && !removeNum)) {
	        return this;
	      }
	      // If index is negative, it should resolve relative to the size of the
	      // collection. However size may be expensive to compute if not cached, so
	      // only call count() if the number is in fact negative.
	      index = resolveBegin(index, index < 0 ? this.count() : this.size);
	      var spliced = this.slice(0, index);
	      return reify(
	        this,
	        numArgs === 1 ?
	          spliced :
	          spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum))
	      );
	    },


	    // ### More collection methods

	    findLastIndex: function(predicate, context) {
	      var key = this.toKeyedSeq().findLastKey(predicate, context);
	      return key === undefined ? -1 : key;
	    },

	    first: function() {
	      return this.get(0);
	    },

	    flatten: function(depth) {
	      return reify(this, flattenFactory(this, depth, false));
	    },

	    get: function(index, notSetValue) {
	      index = wrapIndex(this, index);
	      return (index < 0 || (this.size === Infinity ||
	          (this.size !== undefined && index > this.size))) ?
	        notSetValue :
	        this.find(function(_, key)  {return key === index}, undefined, notSetValue);
	    },

	    has: function(index) {
	      index = wrapIndex(this, index);
	      return index >= 0 && (this.size !== undefined ?
	        this.size === Infinity || index < this.size :
	        this.indexOf(index) !== -1
	      );
	    },

	    interpose: function(separator) {
	      return reify(this, interposeFactory(this, separator));
	    },

	    interleave: function(/*...iterables*/) {
	      var iterables = [this].concat(arrCopy(arguments));
	      var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, iterables);
	      var interleaved = zipped.flatten(true);
	      if (zipped.size) {
	        interleaved.size = zipped.size * iterables.length;
	      }
	      return reify(this, interleaved);
	    },

	    last: function() {
	      return this.get(-1);
	    },

	    skipWhile: function(predicate, context) {
	      return reify(this, skipWhileFactory(this, predicate, context, false));
	    },

	    zip: function(/*, ...iterables */) {
	      var iterables = [this].concat(arrCopy(arguments));
	      return reify(this, zipWithFactory(this, defaultZipper, iterables));
	    },

	    zipWith: function(zipper/*, ...iterables */) {
	      var iterables = arrCopy(arguments);
	      iterables[0] = this;
	      return reify(this, zipWithFactory(this, zipper, iterables));
	    }

	  });

	  IndexedIterable.prototype[IS_INDEXED_SENTINEL] = true;
	  IndexedIterable.prototype[IS_ORDERED_SENTINEL] = true;



	  mixin(SetIterable, {

	    // ### ES6 Collection methods (ES6 Array and Map)

	    get: function(value, notSetValue) {
	      return this.has(value) ? value : notSetValue;
	    },

	    includes: function(value) {
	      return this.has(value);
	    },


	    // ### More sequential methods

	    keySeq: function() {
	      return this.valueSeq();
	    }

	  });

	  SetIterable.prototype.has = IterablePrototype.includes;


	  // Mixin subclasses

	  mixin(KeyedSeq, KeyedIterable.prototype);
	  mixin(IndexedSeq, IndexedIterable.prototype);
	  mixin(SetSeq, SetIterable.prototype);

	  mixin(KeyedCollection, KeyedIterable.prototype);
	  mixin(IndexedCollection, IndexedIterable.prototype);
	  mixin(SetCollection, SetIterable.prototype);


	  // #pragma Helper functions

	  function keyMapper(v, k) {
	    return k;
	  }

	  function entryMapper(v, k) {
	    return [k, v];
	  }

	  function not(predicate) {
	    return function() {
	      return !predicate.apply(this, arguments);
	    }
	  }

	  function neg(predicate) {
	    return function() {
	      return -predicate.apply(this, arguments);
	    }
	  }

	  function quoteString(value) {
	    return typeof value === 'string' ? JSON.stringify(value) : value;
	  }

	  function defaultZipper() {
	    return arrCopy(arguments);
	  }

	  function defaultNegComparator(a, b) {
	    return a < b ? 1 : a > b ? -1 : 0;
	  }

	  function hashIterable(iterable) {
	    if (iterable.size === Infinity) {
	      return 0;
	    }
	    var ordered = isOrdered(iterable);
	    var keyed = isKeyed(iterable);
	    var h = ordered ? 1 : 0;
	    var size = iterable.__iterate(
	      keyed ?
	        ordered ?
	          function(v, k)  { h = 31 * h + hashMerge(hash(v), hash(k)) | 0; } :
	          function(v, k)  { h = h + hashMerge(hash(v), hash(k)) | 0; } :
	        ordered ?
	          function(v ) { h = 31 * h + hash(v) | 0; } :
	          function(v ) { h = h + hash(v) | 0; }
	    );
	    return murmurHashOfSize(size, h);
	  }

	  function murmurHashOfSize(size, h) {
	    h = imul(h, 0xCC9E2D51);
	    h = imul(h << 15 | h >>> -15, 0x1B873593);
	    h = imul(h << 13 | h >>> -13, 5);
	    h = (h + 0xE6546B64 | 0) ^ size;
	    h = imul(h ^ h >>> 16, 0x85EBCA6B);
	    h = imul(h ^ h >>> 13, 0xC2B2AE35);
	    h = smi(h ^ h >>> 16);
	    return h;
	  }

	  function hashMerge(a, b) {
	    return a ^ b + 0x9E3779B9 + (a << 6) + (a >> 2) | 0; // int
	  }

	  var Immutable = {

	    Iterable: Iterable,

	    Seq: Seq,
	    Collection: Collection,
	    Map: Map,
	    OrderedMap: OrderedMap,
	    List: List,
	    Stack: Stack,
	    Set: Set,
	    OrderedSet: OrderedSet,

	    Record: Record,
	    Range: Range,
	    Repeat: Repeat,

	    is: is,
	    fromJS: fromJS

	  };

	  return Immutable;

	}));

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _immutable = __webpack_require__(15);

	exports['default'] = function (value) {
	    if (_immutable.Iterable.isIterable(value)) {
	        return value.toJS();
	    }

	    return value;
	};

	module.exports = exports['default'];

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 */

	'use strict';

	/**
	 * Similar to invariant but only logs a warning if the condition is not met.
	 * This can be used to log issues in development environments in critical
	 * paths. Removing the logging code for production environments will keep the
	 * same logic and follow the same code paths.
	 */

	var warning = function() {};

	if (process.env.NODE_ENV !== 'production') {
	  warning = function(condition, format, args) {
	    var len = arguments.length;
	    args = new Array(len > 2 ? len - 2 : 0);
	    for (var key = 2; key < len; key++) {
	      args[key - 2] = arguments[key];
	    }
	    if (format === undefined) {
	      throw new Error(
	        '`warning(condition, format, ...args)` requires a warning ' +
	        'message argument'
	      );
	    }

	    if (format.length < 10 || (/^[s\W]*$/).test(format)) {
	      throw new Error(
	        'The warning format should be able to uniquely identify this ' +
	        'warning. Please, use a more descriptive format than: ' + format
	      );
	    }

	    if (!condition) {
	      var argIndex = 0;
	      var message = 'Warning: ' +
	        format.replace(/%s/g, function() {
	          return args[argIndex++];
	        });
	      if (typeof console !== 'undefined') {
	        console.error(message);
	      }
	      try {
	        // This error was thrown as a convenience so that you can use this stack
	        // to find the callsite that caused this warning to fire.
	        throw new Error(message);
	      } catch(x) {}
	    }
	  };
	}

	module.exports = warning;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(18)))

/***/ },
/* 18 */
/***/ function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};

	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.

	var cachedSetTimeout;
	var cachedClearTimeout;

	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }


	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }



	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}

	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};

	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _qs = __webpack_require__(20);

	var _qs2 = _interopRequireDefault(_qs);

	var _warning = __webpack_require__(17);

	var _warning2 = _interopRequireDefault(_warning);

	function parseBody(response) {
	    return response.text().then(function (text) {
	        if (!text || !text.length) {
	            (0, _warning2['default'])(response.status === 204, 'You should return a 204 status code with an empty body.');
	            return null;
	        }

	        (0, _warning2['default'])(response.status !== 204, 'You should return an empty body with a 204 status code.');

	        try {
	            return JSON.parse(text);
	        } catch (error) {
	            return text;
	        }
	    });
	}

	exports['default'] = function (fetch) {
	    return function (config) {
	        var url = config.url;
	        delete config.url;

	        if (config.data) {
	            config.body = /application\/json/.test(config.headers['Content-Type']) ? JSON.stringify(config.data) : config.data;
	            delete config.data;
	        }

	        var queryString = _qs2['default'].stringify(config.params || {}, { arrayFormat: 'brackets' });
	        delete config.params;

	        return fetch(!queryString.length ? url : url + '?' + queryString, config).then(function (response) {
	            return parseBody(response).then(function (json) {
	                var headers = {};

	                if (typeof Headers.prototype.forEach === 'function') {
	                    response.headers.forEach(function (value, name) {
	                        headers[name] = value;
	                    });
	                } else if (typeof Headers.prototype.keys === 'function') {
	                    var keys = response.headers.keys();
	                    var _iteratorNormalCompletion = true;
	                    var _didIteratorError = false;
	                    var _iteratorError = undefined;

	                    try {
	                        for (var _iterator = keys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	                            var key = _step.value;

	                            headers[key] = response.headers.get(key);
	                        }
	                    } catch (err) {
	                        _didIteratorError = true;
	                        _iteratorError = err;
	                    } finally {
	                        try {
	                            if (!_iteratorNormalCompletion && _iterator['return']) {
	                                _iterator['return']();
	                            }
	                        } finally {
	                            if (_didIteratorError) {
	                                throw _iteratorError;
	                            }
	                        }
	                    }
	                } else {
	                    headers = response.headers;
	                }

	                var responsePayload = {
	                    data: json,
	                    headers: headers,
	                    method: config.method ? config.method.toLowerCase() : 'get',
	                    statusCode: response.status
	                };

	                if (response.status >= 200 && response.status < 300) {
	                    return responsePayload;
	                }

	                var error = new Error(response.statusText);
	                error.response = responsePayload;
	                throw error;
	            });
	        });
	    };
	};

	module.exports = exports['default'];

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	// Load modules

	var Stringify = __webpack_require__(21);
	var Parse = __webpack_require__(23);


	// Declare internals

	var internals = {};


	module.exports = {
	    stringify: Stringify,
	    parse: Parse
	};


/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	// Load modules

	var Utils = __webpack_require__(22);


	// Declare internals

	var internals = {
	    delimiter: '&',
	    arrayPrefixGenerators: {
	        brackets: function (prefix, key) {

	            return prefix + '[]';
	        },
	        indices: function (prefix, key) {

	            return prefix + '[' + key + ']';
	        },
	        repeat: function (prefix, key) {

	            return prefix;
	        }
	    },
	    strictNullHandling: false,
	    skipNulls: false,
	    encode: true
	};


	internals.stringify = function (obj, prefix, generateArrayPrefix, strictNullHandling, skipNulls, encode, filter, sort) {

	    if (typeof filter === 'function') {
	        obj = filter(prefix, obj);
	    }
	    else if (Utils.isBuffer(obj)) {
	        obj = obj.toString();
	    }
	    else if (obj instanceof Date) {
	        obj = obj.toISOString();
	    }
	    else if (obj === null) {
	        if (strictNullHandling) {
	            return encode ? Utils.encode(prefix) : prefix;
	        }

	        obj = '';
	    }

	    if (typeof obj === 'string' ||
	        typeof obj === 'number' ||
	        typeof obj === 'boolean') {

	        if (encode) {
	            return [Utils.encode(prefix) + '=' + Utils.encode(obj)];
	        }
	        return [prefix + '=' + obj];
	    }

	    var values = [];

	    if (typeof obj === 'undefined') {
	        return values;
	    }

	    var objKeys;
	    if (Array.isArray(filter)) {
	        objKeys = filter;
	    } else {
	        var keys = Object.keys(obj);
	        objKeys = sort ? keys.sort(sort) : keys;
	    }

	    for (var i = 0, il = objKeys.length; i < il; ++i) {
	        var key = objKeys[i];

	        if (skipNulls &&
	            obj[key] === null) {

	            continue;
	        }

	        if (Array.isArray(obj)) {
	            values = values.concat(internals.stringify(obj[key], generateArrayPrefix(prefix, key), generateArrayPrefix, strictNullHandling, skipNulls, encode, filter));
	        }
	        else {
	            values = values.concat(internals.stringify(obj[key], prefix + '[' + key + ']', generateArrayPrefix, strictNullHandling, skipNulls, encode, filter));
	        }
	    }

	    return values;
	};


	module.exports = function (obj, options) {

	    options = options || {};
	    var delimiter = typeof options.delimiter === 'undefined' ? internals.delimiter : options.delimiter;
	    var strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : internals.strictNullHandling;
	    var skipNulls = typeof options.skipNulls === 'boolean' ? options.skipNulls : internals.skipNulls;
	    var encode = typeof options.encode === 'boolean' ? options.encode : internals.encode;
	    var sort = typeof options.sort === 'function' ? options.sort : null;
	    var objKeys;
	    var filter;
	    if (typeof options.filter === 'function') {
	        filter = options.filter;
	        obj = filter('', obj);
	    }
	    else if (Array.isArray(options.filter)) {
	        objKeys = filter = options.filter;
	    }

	    var keys = [];

	    if (typeof obj !== 'object' ||
	        obj === null) {

	        return '';
	    }

	    var arrayFormat;
	    if (options.arrayFormat in internals.arrayPrefixGenerators) {
	        arrayFormat = options.arrayFormat;
	    }
	    else if ('indices' in options) {
	        arrayFormat = options.indices ? 'indices' : 'repeat';
	    }
	    else {
	        arrayFormat = 'indices';
	    }

	    var generateArrayPrefix = internals.arrayPrefixGenerators[arrayFormat];

	    if (!objKeys) {
	        objKeys = Object.keys(obj);
	    }

	    if (sort) {
	        objKeys.sort(sort);
	    }

	    for (var i = 0, il = objKeys.length; i < il; ++i) {
	        var key = objKeys[i];

	        if (skipNulls &&
	            obj[key] === null) {

	            continue;
	        }

	        keys = keys.concat(internals.stringify(obj[key], key, generateArrayPrefix, strictNullHandling, skipNulls, encode, filter, sort));
	    }

	    return keys.join(delimiter);
	};


/***/ },
/* 22 */
/***/ function(module, exports) {

	// Load modules


	// Declare internals

	var internals = {};
	internals.hexTable = new Array(256);
	for (var h = 0; h < 256; ++h) {
	    internals.hexTable[h] = '%' + ((h < 16 ? '0' : '') + h.toString(16)).toUpperCase();
	}


	exports.arrayToObject = function (source, options) {

	    var obj = options.plainObjects ? Object.create(null) : {};
	    for (var i = 0, il = source.length; i < il; ++i) {
	        if (typeof source[i] !== 'undefined') {

	            obj[i] = source[i];
	        }
	    }

	    return obj;
	};


	exports.merge = function (target, source, options) {

	    if (!source) {
	        return target;
	    }

	    if (typeof source !== 'object') {
	        if (Array.isArray(target)) {
	            target.push(source);
	        }
	        else if (typeof target === 'object') {
	            target[source] = true;
	        }
	        else {
	            target = [target, source];
	        }

	        return target;
	    }

	    if (typeof target !== 'object') {
	        target = [target].concat(source);
	        return target;
	    }

	    if (Array.isArray(target) &&
	        !Array.isArray(source)) {

	        target = exports.arrayToObject(target, options);
	    }

	    var keys = Object.keys(source);
	    for (var k = 0, kl = keys.length; k < kl; ++k) {
	        var key = keys[k];
	        var value = source[key];

	        if (!Object.prototype.hasOwnProperty.call(target, key)) {
	            target[key] = value;
	        }
	        else {
	            target[key] = exports.merge(target[key], value, options);
	        }
	    }

	    return target;
	};


	exports.decode = function (str) {

	    try {
	        return decodeURIComponent(str.replace(/\+/g, ' '));
	    } catch (e) {
	        return str;
	    }
	};

	exports.encode = function (str) {

	    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
	    // It has been adapted here for stricter adherence to RFC 3986
	    if (str.length === 0) {
	        return str;
	    }

	    if (typeof str !== 'string') {
	        str = '' + str;
	    }

	    var out = '';
	    for (var i = 0, il = str.length; i < il; ++i) {
	        var c = str.charCodeAt(i);

	        if (c === 0x2D || // -
	            c === 0x2E || // .
	            c === 0x5F || // _
	            c === 0x7E || // ~
	            (c >= 0x30 && c <= 0x39) || // 0-9
	            (c >= 0x41 && c <= 0x5A) || // a-z
	            (c >= 0x61 && c <= 0x7A)) { // A-Z

	            out += str[i];
	            continue;
	        }

	        if (c < 0x80) {
	            out += internals.hexTable[c];
	            continue;
	        }

	        if (c < 0x800) {
	            out += internals.hexTable[0xC0 | (c >> 6)] + internals.hexTable[0x80 | (c & 0x3F)];
	            continue;
	        }

	        if (c < 0xD800 || c >= 0xE000) {
	            out += internals.hexTable[0xE0 | (c >> 12)] + internals.hexTable[0x80 | ((c >> 6) & 0x3F)] + internals.hexTable[0x80 | (c & 0x3F)];
	            continue;
	        }

	        ++i;
	        c = 0x10000 + (((c & 0x3FF) << 10) | (str.charCodeAt(i) & 0x3FF));
	        out += internals.hexTable[0xF0 | (c >> 18)] + internals.hexTable[0x80 | ((c >> 12) & 0x3F)] + internals.hexTable[0x80 | ((c >> 6) & 0x3F)] + internals.hexTable[0x80 | (c & 0x3F)];
	    }

	    return out;
	};

	exports.compact = function (obj, refs) {

	    if (typeof obj !== 'object' ||
	        obj === null) {

	        return obj;
	    }

	    refs = refs || [];
	    var lookup = refs.indexOf(obj);
	    if (lookup !== -1) {
	        return refs[lookup];
	    }

	    refs.push(obj);

	    if (Array.isArray(obj)) {
	        var compacted = [];

	        for (var i = 0, il = obj.length; i < il; ++i) {
	            if (typeof obj[i] !== 'undefined') {
	                compacted.push(obj[i]);
	            }
	        }

	        return compacted;
	    }

	    var keys = Object.keys(obj);
	    for (i = 0, il = keys.length; i < il; ++i) {
	        var key = keys[i];
	        obj[key] = exports.compact(obj[key], refs);
	    }

	    return obj;
	};


	exports.isRegExp = function (obj) {

	    return Object.prototype.toString.call(obj) === '[object RegExp]';
	};


	exports.isBuffer = function (obj) {

	    if (obj === null ||
	        typeof obj === 'undefined') {

	        return false;
	    }

	    return !!(obj.constructor &&
	              obj.constructor.isBuffer &&
	              obj.constructor.isBuffer(obj));
	};


/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	// Load modules

	var Utils = __webpack_require__(22);


	// Declare internals

	var internals = {
	    delimiter: '&',
	    depth: 5,
	    arrayLimit: 20,
	    parameterLimit: 1000,
	    strictNullHandling: false,
	    plainObjects: false,
	    allowPrototypes: false,
	    allowDots: false
	};


	internals.parseValues = function (str, options) {

	    var obj = {};
	    var parts = str.split(options.delimiter, options.parameterLimit === Infinity ? undefined : options.parameterLimit);

	    for (var i = 0, il = parts.length; i < il; ++i) {
	        var part = parts[i];
	        var pos = part.indexOf(']=') === -1 ? part.indexOf('=') : part.indexOf(']=') + 1;

	        if (pos === -1) {
	            obj[Utils.decode(part)] = '';

	            if (options.strictNullHandling) {
	                obj[Utils.decode(part)] = null;
	            }
	        }
	        else {
	            var key = Utils.decode(part.slice(0, pos));
	            var val = Utils.decode(part.slice(pos + 1));

	            if (!Object.prototype.hasOwnProperty.call(obj, key)) {
	                obj[key] = val;
	            }
	            else {
	                obj[key] = [].concat(obj[key]).concat(val);
	            }
	        }
	    }

	    return obj;
	};


	internals.parseObject = function (chain, val, options) {

	    if (!chain.length) {
	        return val;
	    }

	    var root = chain.shift();

	    var obj;
	    if (root === '[]') {
	        obj = [];
	        obj = obj.concat(internals.parseObject(chain, val, options));
	    }
	    else {
	        obj = options.plainObjects ? Object.create(null) : {};
	        var cleanRoot = root[0] === '[' && root[root.length - 1] === ']' ? root.slice(1, root.length - 1) : root;
	        var index = parseInt(cleanRoot, 10);
	        var indexString = '' + index;
	        if (!isNaN(index) &&
	            root !== cleanRoot &&
	            indexString === cleanRoot &&
	            index >= 0 &&
	            (options.parseArrays &&
	             index <= options.arrayLimit)) {

	            obj = [];
	            obj[index] = internals.parseObject(chain, val, options);
	        }
	        else {
	            obj[cleanRoot] = internals.parseObject(chain, val, options);
	        }
	    }

	    return obj;
	};


	internals.parseKeys = function (key, val, options) {

	    if (!key) {
	        return;
	    }

	    // Transform dot notation to bracket notation

	    if (options.allowDots) {
	        key = key.replace(/\.([^\.\[]+)/g, '[$1]');
	    }

	    // The regex chunks

	    var parent = /^([^\[\]]*)/;
	    var child = /(\[[^\[\]]*\])/g;

	    // Get the parent

	    var segment = parent.exec(key);

	    // Stash the parent if it exists

	    var keys = [];
	    if (segment[1]) {
	        // If we aren't using plain objects, optionally prefix keys
	        // that would overwrite object prototype properties
	        if (!options.plainObjects &&
	            Object.prototype.hasOwnProperty(segment[1])) {

	            if (!options.allowPrototypes) {
	                return;
	            }
	        }

	        keys.push(segment[1]);
	    }

	    // Loop through children appending to the array until we hit depth

	    var i = 0;
	    while ((segment = child.exec(key)) !== null && i < options.depth) {

	        ++i;
	        if (!options.plainObjects &&
	            Object.prototype.hasOwnProperty(segment[1].replace(/\[|\]/g, ''))) {

	            if (!options.allowPrototypes) {
	                continue;
	            }
	        }
	        keys.push(segment[1]);
	    }

	    // If there's a remainder, just add whatever is left

	    if (segment) {
	        keys.push('[' + key.slice(segment.index) + ']');
	    }

	    return internals.parseObject(keys, val, options);
	};


	module.exports = function (str, options) {

	    options = options || {};
	    options.delimiter = typeof options.delimiter === 'string' || Utils.isRegExp(options.delimiter) ? options.delimiter : internals.delimiter;
	    options.depth = typeof options.depth === 'number' ? options.depth : internals.depth;
	    options.arrayLimit = typeof options.arrayLimit === 'number' ? options.arrayLimit : internals.arrayLimit;
	    options.parseArrays = options.parseArrays !== false;
	    options.allowDots = typeof options.allowDots === 'boolean' ? options.allowDots : internals.allowDots;
	    options.plainObjects = typeof options.plainObjects === 'boolean' ? options.plainObjects : internals.plainObjects;
	    options.allowPrototypes = typeof options.allowPrototypes === 'boolean' ? options.allowPrototypes : internals.allowPrototypes;
	    options.parameterLimit = typeof options.parameterLimit === 'number' ? options.parameterLimit : internals.parameterLimit;
	    options.strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : internals.strictNullHandling;

	    if (str === '' ||
	        str === null ||
	        typeof str === 'undefined') {

	        return options.plainObjects ? Object.create(null) : {};
	    }

	    var tempObj = typeof str === 'string' ? internals.parseValues(str, options) : str;
	    var obj = options.plainObjects ? Object.create(null) : {};

	    // Iterate over the keys and setup the new object

	    var keys = Object.keys(tempObj);
	    for (var i = 0, il = keys.length; i < il; ++i) {
	        var key = keys[i];
	        var newObj = internals.parseKeys(key, tempObj[key], options);
	        obj = Utils.merge(obj, newObj, options);
	    }

	    return Utils.compact(obj);
	};


/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }

	var _objectAssign = __webpack_require__(12);

	var _objectAssign2 = _interopRequireDefault(_objectAssign);

	var _immutable = __webpack_require__(15);

	var _utilSerialize = __webpack_require__(16);

	var _utilSerialize2 = _interopRequireDefault(_utilSerialize);

	/* eslint-disable new-cap */
	function reducePromiseList(emitter, list, initialValue) {
	    var params = arguments.length <= 3 || arguments[3] === undefined ? [] : arguments[3];

	    return list.reduce(function (promise, nextItem) {
	        return promise.then(function (currentValue) {
	            emitter.apply(undefined, ['pre', (0, _utilSerialize2['default'])(currentValue)].concat(_toConsumableArray(params), [nextItem.name]));
	            return Promise.resolve(nextItem.apply(undefined, [(0, _utilSerialize2['default'])(currentValue)].concat(_toConsumableArray(params)))).then(function (nextValue) {
	                if (!_immutable.Iterable.isIterable(currentValue)) {
	                    return (0, _objectAssign2['default'])({}, currentValue, nextValue);
	                }

	                return currentValue.mergeDeep(nextValue);
	            }).then(function (nextValue) {
	                emitter.apply(undefined, ['post', (0, _utilSerialize2['default'])(nextValue)].concat(_toConsumableArray(params), [nextItem.name]));

	                return nextValue;
	            });
	        });
	    }, Promise.resolve(initialValue));
	}

	exports['default'] = function (httpBackend) {
	    return function (config, emitter) {
	        var errorInterceptors = (0, _immutable.List)(config.get('errorInterceptors'));
	        var requestInterceptors = (0, _immutable.List)(config.get('requestInterceptors'));
	        var responseInterceptors = (0, _immutable.List)(config.get('responseInterceptors'));
	        var currentConfig = config['delete']('errorInterceptors')['delete']('requestInterceptors')['delete']('responseInterceptors');

	        function emitterFactory(type) {
	            return function (event) {
	                for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	                    args[_key - 1] = arguments[_key];
	                }

	                emitter.apply(undefined, [type + ':' + event].concat(args));
	            };
	        }

	        return reducePromiseList(emitterFactory('request:interceptor'), requestInterceptors, currentConfig).then(function (transformedConfig) {
	            emitter('request', (0, _utilSerialize2['default'])(transformedConfig));
	            return httpBackend((0, _utilSerialize2['default'])(transformedConfig)).then(function (response) {
	                return reducePromiseList(emitterFactory('response:interceptor'), responseInterceptors, (0, _immutable.fromJS)(response), [(0, _utilSerialize2['default'])(transformedConfig)]);
	            });
	        }).then(null, function (error) {
	            return reducePromiseList(emitterFactory('error:interceptor'), errorInterceptors, error, [(0, _utilSerialize2['default'])(currentConfig)]).then(function (transformedError) {
	                return Promise.reject(transformedError);
	            });
	        });
	    };
	};

	module.exports = exports['default'];

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});
	exports.custom = custom;
	exports.collection = collection;
	exports.member = member;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _objectAssign = __webpack_require__(12);

	var _objectAssign2 = _interopRequireDefault(_objectAssign);

	function custom(endpoint) {
	    return function (name) {
	        var relative = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

	        if (relative) {
	            return member(endpoint['new'](endpoint.url() + '/' + name)); // eslint-disable-line no-use-before-define
	        }

	        return member(endpoint['new'](name)); // eslint-disable-line no-use-before-define
	    };
	}

	function collection(endpoint) {
	    function _bindHttpMethod(method) {
	        return function () {
	            var _member;

	            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	                args[_key] = arguments[_key];
	            }

	            var id = args.shift();
	            return (_member = member(endpoint['new'](endpoint.url() + '/' + id)))[method].apply(_member, args); // eslint-disable-line no-use-before-define
	        };
	    }

	    return (0, _objectAssign2['default'])(endpoint, {
	        custom: custom(endpoint),
	        'delete': _bindHttpMethod('delete'),
	        getAll: endpoint.get,
	        get: _bindHttpMethod('get'),
	        head: _bindHttpMethod('head'),
	        patch: _bindHttpMethod('patch'),
	        put: _bindHttpMethod('put')
	    });
	}

	function member(endpoint) {
	    return (0, _objectAssign2['default'])(endpoint, {
	        all: function all(name) {
	            return collection(endpoint['new'](endpoint.url() + '/' + name));
	        },
	        custom: custom(endpoint),
	        one: function one(name, id) {
	            return member(endpoint['new'](endpoint.url() + '/' + name + '/' + id));
	        }
	    });
	}

/***/ },
/* 26 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	exports['default'] = function (request) {
	    return function (config) {
	        if (config.data) {
	            config.form = /application\/json/.test(config.headers['Content-Type']) ? JSON.stringify(config.data) : config.data;
	            delete config.data;
	        }

	        if (config.params) {
	            config.qs = config.params;
	            delete config.params;
	        }

	        return new Promise(function (resolve, reject) {
	            request(config, function (err, response, body) {
	                if (err) {
	                    throw err;
	                }

	                var data = undefined;

	                try {
	                    data = JSON.parse(body);
	                } catch (e) {
	                    data = body;
	                }

	                var responsePayload = {
	                    data: data,
	                    headers: response.headers,
	                    statusCode: response.statusCode
	                };

	                if (response.statusCode >= 200 && response.statusCode < 300) {
	                    return resolve(responsePayload);
	                }

	                var error = new Error(response.statusMessage);
	                error.response = responsePayload;

	                reject(error);
	            });
	        });
	    };
	};

	module.exports = exports['default'];

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});
	exports['default'] = scopeFactory;

	var _events = __webpack_require__(28);

	var _immutable = __webpack_require__(15);

	/* eslint-disable new-cap */

	function scopeFactory(parentScope) {
	    var _data = (0, _immutable.Map)();
	    var _emitter = new _events.EventEmitter();

	    var scope = {
	        assign: function assign(key, subKey, value) {
	            if (!scope.has(key)) {
	                scope.set(key, (0, _immutable.Map)());
	            }

	            _data = _data.setIn([key, subKey], value);
	            return scope;
	        },
	        emit: function emit() {
	            _emitter.emit.apply(_emitter, arguments);

	            if (parentScope) {
	                parentScope.emit.apply(parentScope, arguments);
	            }
	        },
	        get: function get(key) {
	            var datum = _data.get(key);

	            if (scope.has(key) && !_immutable.Iterable.isIterable(datum) || !parentScope) {
	                return datum;
	            } else if (!scope.has(key) && parentScope) {
	                return parentScope.get(key);
	            }

	            var parentDatum = parentScope.get(key);

	            if (!parentDatum) {
	                return datum;
	            }

	            if (_immutable.List.isList(parentDatum)) {
	                return parentDatum.concat(datum);
	            }

	            return parentDatum.mergeDeep(datum);
	        },
	        has: function has(key) {
	            return _data.has(key);
	        },
	        'new': function _new() {
	            return scopeFactory(scope);
	        },
	        on: _emitter.on.bind(_emitter),
	        once: _emitter.once.bind(_emitter),
	        push: function push(key, value) {
	            if (!scope.has(key)) {
	                scope.set(key, (0, _immutable.List)());
	            }

	            _data = _data.update(key, function (list) {
	                return list.push(value);
	            });
	            return scope;
	        },
	        set: function set(key, value) {
	            _data = _data.set(key, value);
	            return scope;
	        }
	    };

	    return scope;
	}

	module.exports = exports['default'];

/***/ },
/* 28 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	function EventEmitter() {
	  this._events = this._events || {};
	  this._maxListeners = this._maxListeners || undefined;
	}
	module.exports = EventEmitter;

	// Backwards-compat with node 0.10.x
	EventEmitter.EventEmitter = EventEmitter;

	EventEmitter.prototype._events = undefined;
	EventEmitter.prototype._maxListeners = undefined;

	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	EventEmitter.defaultMaxListeners = 10;

	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter.prototype.setMaxListeners = function(n) {
	  if (!isNumber(n) || n < 0 || isNaN(n))
	    throw TypeError('n must be a positive number');
	  this._maxListeners = n;
	  return this;
	};

	EventEmitter.prototype.emit = function(type) {
	  var er, handler, len, args, i, listeners;

	  if (!this._events)
	    this._events = {};

	  // If there is no 'error' event listener then throw.
	  if (type === 'error') {
	    if (!this._events.error ||
	        (isObject(this._events.error) && !this._events.error.length)) {
	      er = arguments[1];
	      if (er instanceof Error) {
	        throw er; // Unhandled 'error' event
	      } else {
	        // At least give some kind of context to the user
	        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
	        err.context = er;
	        throw err;
	      }
	    }
	  }

	  handler = this._events[type];

	  if (isUndefined(handler))
	    return false;

	  if (isFunction(handler)) {
	    switch (arguments.length) {
	      // fast cases
	      case 1:
	        handler.call(this);
	        break;
	      case 2:
	        handler.call(this, arguments[1]);
	        break;
	      case 3:
	        handler.call(this, arguments[1], arguments[2]);
	        break;
	      // slower
	      default:
	        args = Array.prototype.slice.call(arguments, 1);
	        handler.apply(this, args);
	    }
	  } else if (isObject(handler)) {
	    args = Array.prototype.slice.call(arguments, 1);
	    listeners = handler.slice();
	    len = listeners.length;
	    for (i = 0; i < len; i++)
	      listeners[i].apply(this, args);
	  }

	  return true;
	};

	EventEmitter.prototype.addListener = function(type, listener) {
	  var m;

	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  if (!this._events)
	    this._events = {};

	  // To avoid recursion in the case that type === "newListener"! Before
	  // adding it to the listeners, first emit "newListener".
	  if (this._events.newListener)
	    this.emit('newListener', type,
	              isFunction(listener.listener) ?
	              listener.listener : listener);

	  if (!this._events[type])
	    // Optimize the case of one listener. Don't need the extra array object.
	    this._events[type] = listener;
	  else if (isObject(this._events[type]))
	    // If we've already got an array, just append.
	    this._events[type].push(listener);
	  else
	    // Adding the second element, need to change to array.
	    this._events[type] = [this._events[type], listener];

	  // Check for listener leak
	  if (isObject(this._events[type]) && !this._events[type].warned) {
	    if (!isUndefined(this._maxListeners)) {
	      m = this._maxListeners;
	    } else {
	      m = EventEmitter.defaultMaxListeners;
	    }

	    if (m && m > 0 && this._events[type].length > m) {
	      this._events[type].warned = true;
	      console.error('(node) warning: possible EventEmitter memory ' +
	                    'leak detected. %d listeners added. ' +
	                    'Use emitter.setMaxListeners() to increase limit.',
	                    this._events[type].length);
	      if (typeof console.trace === 'function') {
	        // not supported in IE 10
	        console.trace();
	      }
	    }
	  }

	  return this;
	};

	EventEmitter.prototype.on = EventEmitter.prototype.addListener;

	EventEmitter.prototype.once = function(type, listener) {
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  var fired = false;

	  function g() {
	    this.removeListener(type, g);

	    if (!fired) {
	      fired = true;
	      listener.apply(this, arguments);
	    }
	  }

	  g.listener = listener;
	  this.on(type, g);

	  return this;
	};

	// emits a 'removeListener' event iff the listener was removed
	EventEmitter.prototype.removeListener = function(type, listener) {
	  var list, position, length, i;

	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  if (!this._events || !this._events[type])
	    return this;

	  list = this._events[type];
	  length = list.length;
	  position = -1;

	  if (list === listener ||
	      (isFunction(list.listener) && list.listener === listener)) {
	    delete this._events[type];
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);

	  } else if (isObject(list)) {
	    for (i = length; i-- > 0;) {
	      if (list[i] === listener ||
	          (list[i].listener && list[i].listener === listener)) {
	        position = i;
	        break;
	      }
	    }

	    if (position < 0)
	      return this;

	    if (list.length === 1) {
	      list.length = 0;
	      delete this._events[type];
	    } else {
	      list.splice(position, 1);
	    }

	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	  }

	  return this;
	};

	EventEmitter.prototype.removeAllListeners = function(type) {
	  var key, listeners;

	  if (!this._events)
	    return this;

	  // not listening for removeListener, no need to emit
	  if (!this._events.removeListener) {
	    if (arguments.length === 0)
	      this._events = {};
	    else if (this._events[type])
	      delete this._events[type];
	    return this;
	  }

	  // emit removeListener for all listeners on all events
	  if (arguments.length === 0) {
	    for (key in this._events) {
	      if (key === 'removeListener') continue;
	      this.removeAllListeners(key);
	    }
	    this.removeAllListeners('removeListener');
	    this._events = {};
	    return this;
	  }

	  listeners = this._events[type];

	  if (isFunction(listeners)) {
	    this.removeListener(type, listeners);
	  } else if (listeners) {
	    // LIFO order
	    while (listeners.length)
	      this.removeListener(type, listeners[listeners.length - 1]);
	  }
	  delete this._events[type];

	  return this;
	};

	EventEmitter.prototype.listeners = function(type) {
	  var ret;
	  if (!this._events || !this._events[type])
	    ret = [];
	  else if (isFunction(this._events[type]))
	    ret = [this._events[type]];
	  else
	    ret = this._events[type].slice();
	  return ret;
	};

	EventEmitter.prototype.listenerCount = function(type) {
	  if (this._events) {
	    var evlistener = this._events[type];

	    if (isFunction(evlistener))
	      return 1;
	    else if (evlistener)
	      return evlistener.length;
	  }
	  return 0;
	};

	EventEmitter.listenerCount = function(emitter, type) {
	  return emitter.listenerCount(type);
	};

	function isFunction(arg) {
	  return typeof arg === 'function';
	}

	function isNumber(arg) {
	  return typeof arg === 'number';
	}

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}

	function isUndefined(arg) {
	  return arg === void 0;
	}


/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * JavaScript Cookie v2.1.3
	 * https://github.com/js-cookie/js-cookie
	 *
	 * Copyright 2006, 2015 Klaus Hartl & Fagner Brack
	 * Released under the MIT license
	 */
	;(function (factory) {
		var registeredInModuleLoader = false;
		if (true) {
			!(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
			registeredInModuleLoader = true;
		}
		if (true) {
			module.exports = factory();
			registeredInModuleLoader = true;
		}
		if (!registeredInModuleLoader) {
			var OldCookies = window.Cookies;
			var api = window.Cookies = factory();
			api.noConflict = function () {
				window.Cookies = OldCookies;
				return api;
			};
		}
	}(function () {
		function extend () {
			var i = 0;
			var result = {};
			for (; i < arguments.length; i++) {
				var attributes = arguments[ i ];
				for (var key in attributes) {
					result[key] = attributes[key];
				}
			}
			return result;
		}

		function init (converter) {
			function api (key, value, attributes) {
				var result;
				if (typeof document === 'undefined') {
					return;
				}

				// Write

				if (arguments.length > 1) {
					attributes = extend({
						path: '/'
					}, api.defaults, attributes);

					if (typeof attributes.expires === 'number') {
						var expires = new Date();
						expires.setMilliseconds(expires.getMilliseconds() + attributes.expires * 864e+5);
						attributes.expires = expires;
					}

					try {
						result = JSON.stringify(value);
						if (/^[\{\[]/.test(result)) {
							value = result;
						}
					} catch (e) {}

					if (!converter.write) {
						value = encodeURIComponent(String(value))
							.replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent);
					} else {
						value = converter.write(value, key);
					}

					key = encodeURIComponent(String(key));
					key = key.replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent);
					key = key.replace(/[\(\)]/g, escape);

					return (document.cookie = [
						key, '=', value,
						attributes.expires ? '; expires=' + attributes.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE
						attributes.path ? '; path=' + attributes.path : '',
						attributes.domain ? '; domain=' + attributes.domain : '',
						attributes.secure ? '; secure' : ''
					].join(''));
				}

				// Read

				if (!key) {
					result = {};
				}

				// To prevent the for loop in the first place assign an empty array
				// in case there are no cookies at all. Also prevents odd result when
				// calling "get()"
				var cookies = document.cookie ? document.cookie.split('; ') : [];
				var rdecode = /(%[0-9A-Z]{2})+/g;
				var i = 0;

				for (; i < cookies.length; i++) {
					var parts = cookies[i].split('=');
					var cookie = parts.slice(1).join('=');

					if (cookie.charAt(0) === '"') {
						cookie = cookie.slice(1, -1);
					}

					try {
						var name = parts[0].replace(rdecode, decodeURIComponent);
						cookie = converter.read ?
							converter.read(cookie, name) : converter(cookie, name) ||
							cookie.replace(rdecode, decodeURIComponent);

						if (this.json) {
							try {
								cookie = JSON.parse(cookie);
							} catch (e) {}
						}

						if (key === name) {
							result = cookie;
							break;
						}

						if (!key) {
							result[name] = cookie;
						}
					} catch (e) {}
				}

				return result;
			}

			api.set = api;
			api.get = function (key) {
				return api.call(api, key);
			};
			api.getJSON = function () {
				return api.apply({
					json: true
				}, [].slice.call(arguments));
			};
			api.defaults = {};

			api.remove = function (key, attributes) {
				api(key, '', extend(attributes, {
					expires: -1
				}));
			};

			api.withConverter = init;

			return api;
		}

		return init(function () {});
	}));


/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(page, m, jQuery, Bullet) {"use strict";

	var Merge = function Merge(obj1, obj2) {

	    for (var p in obj2) {
	        try {
	            // Property in destination object set; update its value.
	            if (obj2[p].constructor == Object) {
	                obj1[p] = Merge(obj1[p], obj2[p]);
	            } else {
	                obj1[p] = obj2[p];
	            }
	        } catch (e) {
	            // Property in destination object not set; create it and set its value.
	            obj1[p] = obj2[p];
	        }
	    }

	    return obj1;
	};
	var routing = function routing(data, options) {

	    //add routing prefix from states.
	    this.addPrefix = function (route) {

	        return route;
	    };

	    this._state = data.state;
	    //state of parent
	    this._parent = data.parent ? typeof data.parent === "undefined" ? false : data.parent : false;
	    this._ctrl = data.ctrl;
	    this._url = this.addPrefix(data.url);
	    this._options = options;
	    this.States = {};
	    this._id = data.id || 0;

	    this.load = function (element, ctrl, parent) {

	        var that = this;
	        console.log(that._url, that._state);
	        page(that._url, function (ctx) {

	            for (var i = 0; i < that._id; i++) {
	                console.log(i);
	            }
	            if (parent) {
	                //mountParent here
	                that.mount(parent._options.mainElement, parent._ctrl, ctx).then(function () {
	                    parent._ctrl.child = ctrl; //make it secondary controller
	                    m.redraw();
	                });
	            } else {

	                that.mount(element, ctrl, ctx);
	            }
	        });
	    };

	    this.mount = function (element, ctrl, ctx) {
	        var deferred = m.deferred();
	        ctrl.routeParams = ctx;
	        m.mount(element, ctrl);
	        deferred.resolve();
	        return deferred.promise;
	    };

	    //update states and div sections records
	    this.mountedRecords = function (state, url, id) {
	        this.States[state] = url;
	    };

	    //execute this route and all its child routes
	    this.exec = function () {

	        if (this._options.loaded) {
	            throw "CANNOT RUN ONCE EXEC IS PERFORMED";
	        } else {
	            this.run();
	        }
	    };

	    this.run = function () {
	        this.load(this._options.mainElement, this._ctrl);
	        this._options.loaded = true;
	        this.mountedRecords(this._state, this._url);
	        page();
	    };

	    this.addNew = function (data) {
	        return this.add(data, true);
	    };

	    this.add = function (data, newRoute) {
	        var parent = this;

	        data.id = parent._id + 1;

	        var child = new routing(data, {});

	        //carry forward initial options & states
	        parent._options = child._options = Merge(parent._options, child._options);
	        parent.States = child.States = Merge(parent.States, child.States);

	        parent.mountedRecords(child._state, child._url);

	        child.load(parent._options.mainElement, child._ctrl, parent);

	        return newRoute ? child : parent;
	    };

	    return this;
	};
	var r = new routing({
	    ctrl: __webpack_require__(34),
	    state: "home",
	    url: "/"
	}, {
	    mainElement: document.body,
	    secondElement: null
	});

	r.add({
	    ctrl: __webpack_require__(38),
	    parentState: "home", //this will be bound to parent url
	    url: "/signup",
	    state: "signup" //name of state + url after slash /
	}).add({
	    ctrl: __webpack_require__(40),
	    parentState: "home", //this will be bound to parent url
	    url: "/login",
	    state: "login" //name of state + url after slash /
	}).exec();

	//console.log(r.States);
	//custom animations
	m.mainElement = document.body;

	m.fadesOutPage = function (element, isInitialized, context) {

	    if (!isInitialized) {
	        element.onclick = function (e) {
	            e.preventDefault();

	            jQuery(element).siblings('.active').removeClass('active');
	            jQuery(element).addClass('active');

	            page(element.getAttribute("href"));
	        };
	    }
	};

	//am I inside parent route or child?
	//m.whereAmI = m.prop("parent");

	//if parent page is mounted?
	//m.parentMounted = m.prop(false);

	// var HomeRoutes = {
	//     "/": {
	//         noAnimate: true,
	//         state: 'home',
	//         gotChild: true,
	//         defaultChild: require('modules/home/splash'),
	//         ctrl: require('modules/home')
	//     },
	//     "/404": {
	//         noAnimate: true,
	//         state: 'home',
	//         gotChild: true,
	//         defaultChild: require('modules/home/404'),
	//         ctrl: require('modules/home')
	//     },
	//     "/login": {
	//         noAnimate: false,
	//         state: 'login',
	//         gotChild: false,
	//         parent: "/",
	//         ctrl: require('modules/home/login')
	//     },
	//     "/signup": {
	//         noAnimate: false,
	//         state: 'signup',
	//         gotChild: false,
	//         parent: "/",
	//         ctrl: require('modules/home/signup')
	//     }
	// }

	// Object.keys(HomeRoutes).map(function(route) {

	//     var r = HomeRoutes[route]


	//     page(route, function(ctx) {

	//         m.params = ctx.params;

	//         //need to update child element only.
	//         if (r.gotChild) {
	//             m.whereAmI = m.prop("child");
	//         }


	//         m.secondElem = m.prop((r.defaultChild || null));

	//         //if got child is true, this probably be a parent
	//         if (!r.gotChild && r.parent) {

	//             //initialise child
	//             m.secondElem = m.prop(r.ctrl)

	//             //mount parent
	//             m.mount(m.mainElement, HomeRoutes[r.parent].ctrl);

	//             r.ctrl.loaded() ? (console.log("LOADED")) : (console.log("DIDNT LOAD"));

	//         } else {
	//             m.mount(m.mainElement, r.ctrl);
	//         }

	//         // if (!r.noAnimate)
	//         // //animate primary div
	//         //     jQuery(m.secondDiv)
	//         //     .transition({
	//         //         animation: 'fade top',
	//         //         onComplete: function() {
	//         //             //page(element.getAttribute("href"))
	//         //             jQuery(m.secondDiv).transition('fade top')
	//         //         }
	//         //     })
	//     });
	// });


	// var DashboardRoutes = {
	//     "/dashboard": {
	//         noAnimate: false,
	//         state: 'dashboard',
	//         gotChild: true,
	//         defaultChild: require('modules/dashboard/analytics'),
	//         ctrl: require('modules/dashboard')
	//     },
	//     "/settings": {
	//         state: "settings",
	//         parent: "/dashboard",
	//         ctrl: require('modules/dashboard/settings')
	//     },
	//     "/network": {
	//         state: "network",
	//         noParentUrl: true,
	//         parent: "/dashboard",
	//         ctrl: require('modules/dashboard/network')
	//     },
	//     "/new": {
	//         state: "new",
	//         noParentUrl: true,
	//         parent: "/dashboard",
	//         ctrl: require('modules/dashboard/new')
	//     },

	//     "/logout": {
	//         state: "logout",
	//         noParentUrl: true,
	//         parent: "/logout",
	//         ctrl: require('modules/dashboard/logout')
	//     }
	// }

	// Object.keys(DashboardRoutes).map(function(route) {

	//     var r = DashboardRoutes[route]

	//     if (r.parent && !r.noParentUrl) {
	//         route = r.parent + route // 
	//     }

	//     page(route, function(ctx) {

	//         m.params = ctx.params;

	//         //need to update child element only.
	//         if (r.gotChild) {
	//             m.whereAmI = m.prop("child");
	//         }

	//         //only mount parent if this has got child
	//         m.parentMounted = m.prop(r.gotChild);

	//         m.secondElem = m.prop(r.defaultChild || null);

	//         if (!m.parentMounted() && r.parent) {

	//             //initialise child
	//             m.secondElem = m.prop(r.ctrl)

	//             //mount parent
	//             m.mount(m.mainElement, DashboardRoutes[r.parent].ctrl);

	//             m.parentMounted = m.prop(true);

	//         } else {
	//             m.mount(m.mainElement, r.ctrl);
	//         }

	//     });
	// });


	// page('*', function() {
	//     page.redirect("/404")
	// })


	//create full screen animation here.
	//
	//m.mount(m.mainElement, require('modules/common/loader'));

	//ask Auth.js to do auth
	var Auth = __webpack_require__(36);

	Bullet.on('auth_done', function () {
	    //page();
	    m.redraw();
	});

	Auth.DoLogin();
	//page()
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(31), __webpack_require__(4), __webpack_require__(3), __webpack_require__(1)))

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(page, process) {  /* globals require, module */

	  'use strict';

	  /**
	   * Module dependencies.
	   */

	  var pathtoRegexp = __webpack_require__(32);

	  /**
	   * Module exports.
	   */

	  module.exports = page;

	  /**
	   * Detect click event
	   */
	  var clickEvent = ('undefined' !== typeof document) && document.ontouchstart ? 'touchstart' : 'click';

	  /**
	   * To work properly with the URL
	   * history.location generated polyfill in https://github.com/devote/HTML5-History-API
	   */

	  var location = ('undefined' !== typeof window) && (window.history.location || window.location);

	  /**
	   * Perform initial dispatch.
	   */

	  var dispatch = true;


	  /**
	   * Decode URL components (query string, pathname, hash).
	   * Accommodates both regular percent encoding and x-www-form-urlencoded format.
	   */
	  var decodeURLComponents = true;

	  /**
	   * Base path.
	   */

	  var base = '';

	  /**
	   * Running flag.
	   */

	  var running;

	  /**
	   * HashBang option
	   */

	  var hashbang = false;

	  /**
	   * Previous context, for capturing
	   * page exit events.
	   */

	  var prevContext;

	  /**
	   * Register `path` with callback `fn()`,
	   * or route `path`, or redirection,
	   * or `page.start()`.
	   *
	   *   page(fn);
	   *   page('*', fn);
	   *   page('/user/:id', load, user);
	   *   page('/user/' + user.id, { some: 'thing' });
	   *   page('/user/' + user.id);
	   *   page('/from', '/to')
	   *   page();
	   *
	   * @param {string|!Function|!Object} path
	   * @param {Function=} fn
	   * @api public
	   */

	  function page(path, fn) {
	    // <callback>
	    if ('function' === typeof path) {
	      return page('*', path);
	    }

	    // route <path> to <callback ...>
	    if ('function' === typeof fn) {
	      var route = new Route(/** @type {string} */ (path));
	      for (var i = 1; i < arguments.length; ++i) {
	        page.callbacks.push(route.middleware(arguments[i]));
	      }
	      // show <path> with [state]
	    } else if ('string' === typeof path) {
	      page['string' === typeof fn ? 'redirect' : 'show'](path, fn);
	      // start [options]
	    } else {
	      page.start(path);
	    }
	  }

	  /**
	   * Callback functions.
	   */

	  page.callbacks = [];
	  page.exits = [];

	  /**
	   * Current path being processed
	   * @type {string}
	   */
	  page.current = '';

	  /**
	   * Number of pages navigated to.
	   * @type {number}
	   *
	   *     page.len == 0;
	   *     page('/login');
	   *     page.len == 1;
	   */

	  page.len = 0;

	  /**
	   * Get or set basepath to `path`.
	   *
	   * @param {string} path
	   * @api public
	   */

	  page.base = function(path) {
	    if (0 === arguments.length) return base;
	    base = path;
	  };

	  /**
	   * Bind with the given `options`.
	   *
	   * Options:
	   *
	   *    - `click` bind to click events [true]
	   *    - `popstate` bind to popstate [true]
	   *    - `dispatch` perform initial dispatch [true]
	   *
	   * @param {Object} options
	   * @api public
	   */

	  page.start = function(options) {
	    options = options || {};
	    if (running) return;
	    running = true;
	    if (false === options.dispatch) dispatch = false;
	    if (false === options.decodeURLComponents) decodeURLComponents = false;
	    if (false !== options.popstate) window.addEventListener('popstate', onpopstate, false);
	    if (false !== options.click) {
	      document.addEventListener(clickEvent, onclick, false);
	    }
	    if (true === options.hashbang) hashbang = true;
	    if (!dispatch) return;
	    var url = (hashbang && ~location.hash.indexOf('#!')) ? location.hash.substr(2) + location.search : location.pathname + location.search + location.hash;
	    page.replace(url, null, true, dispatch);
	  };

	  /**
	   * Unbind click and popstate event handlers.
	   *
	   * @api public
	   */

	  page.stop = function() {
	    if (!running) return;
	    page.current = '';
	    page.len = 0;
	    running = false;
	    document.removeEventListener(clickEvent, onclick, false);
	    window.removeEventListener('popstate', onpopstate, false);
	  };

	  /**
	   * Show `path` with optional `state` object.
	   *
	   * @param {string} path
	   * @param {Object=} state
	   * @param {boolean=} dispatch
	   * @param {boolean=} push
	   * @return {!Context}
	   * @api public
	   */

	  page.show = function(path, state, dispatch, push) {
	    var ctx = new Context(path, state);
	    page.current = ctx.path;
	    if (false !== dispatch) page.dispatch(ctx);
	    if (false !== ctx.handled && false !== push) ctx.pushState();
	    return ctx;
	  };

	  /**
	   * Goes back in the history
	   * Back should always let the current route push state and then go back.
	   *
	   * @param {string} path - fallback path to go back if no more history exists, if undefined defaults to page.base
	   * @param {Object=} state
	   * @api public
	   */

	  page.back = function(path, state) {
	    if (page.len > 0) {
	      // this may need more testing to see if all browsers
	      // wait for the next tick to go back in history
	      history.back();
	      page.len--;
	    } else if (path) {
	      setTimeout(function() {
	        page.show(path, state);
	      });
	    }else{
	      setTimeout(function() {
	        page.show(base, state);
	      });
	    }
	  };


	  /**
	   * Register route to redirect from one path to other
	   * or just redirect to another route
	   *
	   * @param {string} from - if param 'to' is undefined redirects to 'from'
	   * @param {string=} to
	   * @api public
	   */
	  page.redirect = function(from, to) {
	    // Define route from a path to another
	    if ('string' === typeof from && 'string' === typeof to) {
	      page(from, function(e) {
	        setTimeout(function() {
	          page.replace(/** @type {!string} */ (to));
	        }, 0);
	      });
	    }

	    // Wait for the push state and replace it with another
	    if ('string' === typeof from && 'undefined' === typeof to) {
	      setTimeout(function() {
	        page.replace(from);
	      }, 0);
	    }
	  };

	  /**
	   * Replace `path` with optional `state` object.
	   *
	   * @param {string} path
	   * @param {Object=} state
	   * @param {boolean=} init
	   * @param {boolean=} dispatch
	   * @return {!Context}
	   * @api public
	   */


	  page.replace = function(path, state, init, dispatch) {
	    var ctx = new Context(path, state);
	    page.current = ctx.path;
	    ctx.init = init;
	    ctx.save(); // save before dispatching, which may redirect
	    if (false !== dispatch) page.dispatch(ctx);
	    return ctx;
	  };

	  /**
	   * Dispatch the given `ctx`.
	   *
	   * @param {Context} ctx
	   * @api private
	   */
	  page.dispatch = function(ctx) {
	    var prev = prevContext,
	      i = 0,
	      j = 0;

	    prevContext = ctx;

	    function nextExit() {
	      var fn = page.exits[j++];
	      if (!fn) return nextEnter();
	      fn(prev, nextExit);
	    }

	    function nextEnter() {
	      var fn = page.callbacks[i++];

	      if (ctx.path !== page.current) {
	        ctx.handled = false;
	        return;
	      }
	      if (!fn) return unhandled(ctx);
	      fn(ctx, nextEnter);
	    }

	    if (prev) {
	      nextExit();
	    } else {
	      nextEnter();
	    }
	  };

	  /**
	   * Unhandled `ctx`. When it's not the initial
	   * popstate then redirect. If you wish to handle
	   * 404s on your own use `page('*', callback)`.
	   *
	   * @param {Context} ctx
	   * @api private
	   */
	  function unhandled(ctx) {
	    if (ctx.handled) return;
	    var current;

	    if (hashbang) {
	      current = base + location.hash.replace('#!', '');
	    } else {
	      current = location.pathname + location.search;
	    }

	    if (current === ctx.canonicalPath) return;
	    page.stop();
	    ctx.handled = false;
	    location.href = ctx.canonicalPath;
	  }

	  /**
	   * Register an exit route on `path` with
	   * callback `fn()`, which will be called
	   * on the previous context when a new
	   * page is visited.
	   */
	  page.exit = function(path, fn) {
	    if (typeof path === 'function') {
	      return page.exit('*', path);
	    }

	    var route = new Route(path);
	    for (var i = 1; i < arguments.length; ++i) {
	      page.exits.push(route.middleware(arguments[i]));
	    }
	  };

	  /**
	   * Remove URL encoding from the given `str`.
	   * Accommodates whitespace in both x-www-form-urlencoded
	   * and regular percent-encoded form.
	   *
	   * @param {string} val - URL component to decode
	   */
	  function decodeURLEncodedURIComponent(val) {
	    if (typeof val !== 'string') { return val; }
	    return decodeURLComponents ? decodeURIComponent(val.replace(/\+/g, ' ')) : val;
	  }

	  /**
	   * Initialize a new "request" `Context`
	   * with the given `path` and optional initial `state`.
	   *
	   * @constructor
	   * @param {string} path
	   * @param {Object=} state
	   * @api public
	   */

	  function Context(path, state) {
	    if ('/' === path[0] && 0 !== path.indexOf(base)) path = base + (hashbang ? '#!' : '') + path;
	    var i = path.indexOf('?');

	    this.canonicalPath = path;
	    this.path = path.replace(base, '') || '/';
	    if (hashbang) this.path = this.path.replace('#!', '') || '/';

	    this.title = document.title;
	    this.state = state || {};
	    this.state.path = path;
	    this.querystring = ~i ? decodeURLEncodedURIComponent(path.slice(i + 1)) : '';
	    this.pathname = decodeURLEncodedURIComponent(~i ? path.slice(0, i) : path);
	    this.params = {};

	    // fragment
	    this.hash = '';
	    if (!hashbang) {
	      if (!~this.path.indexOf('#')) return;
	      var parts = this.path.split('#');
	      this.path = parts[0];
	      this.hash = decodeURLEncodedURIComponent(parts[1]) || '';
	      this.querystring = this.querystring.split('#')[0];
	    }
	  }

	  /**
	   * Expose `Context`.
	   */

	  page.Context = Context;

	  /**
	   * Push state.
	   *
	   * @api private
	   */

	  Context.prototype.pushState = function() {
	    page.len++;
	    history.pushState(this.state, this.title, hashbang && this.path !== '/' ? '#!' + this.path : this.canonicalPath);
	  };

	  /**
	   * Save the context state.
	   *
	   * @api public
	   */

	  Context.prototype.save = function() {
	    history.replaceState(this.state, this.title, hashbang && this.path !== '/' ? '#!' + this.path : this.canonicalPath);
	  };

	  /**
	   * Initialize `Route` with the given HTTP `path`,
	   * and an array of `callbacks` and `options`.
	   *
	   * Options:
	   *
	   *   - `sensitive`    enable case-sensitive routes
	   *   - `strict`       enable strict matching for trailing slashes
	   *
	   * @constructor
	   * @param {string} path
	   * @param {Object=} options
	   * @api private
	   */

	  function Route(path, options) {
	    options = options || {};
	    this.path = (path === '*') ? '(.*)' : path;
	    this.method = 'GET';
	    this.regexp = pathtoRegexp(this.path,
	      this.keys = [],
	      options);
	  }

	  /**
	   * Expose `Route`.
	   */

	  page.Route = Route;

	  /**
	   * Return route middleware with
	   * the given callback `fn()`.
	   *
	   * @param {Function} fn
	   * @return {Function}
	   * @api public
	   */

	  Route.prototype.middleware = function(fn) {
	    var self = this;
	    return function(ctx, next) {
	      if (self.match(ctx.path, ctx.params)) return fn(ctx, next);
	      next();
	    };
	  };

	  /**
	   * Check if this route matches `path`, if so
	   * populate `params`.
	   *
	   * @param {string} path
	   * @param {Object} params
	   * @return {boolean}
	   * @api private
	   */

	  Route.prototype.match = function(path, params) {
	    var keys = this.keys,
	      qsIndex = path.indexOf('?'),
	      pathname = ~qsIndex ? path.slice(0, qsIndex) : path,
	      m = this.regexp.exec(decodeURIComponent(pathname));

	    if (!m) return false;

	    for (var i = 1, len = m.length; i < len; ++i) {
	      var key = keys[i - 1];
	      var val = decodeURLEncodedURIComponent(m[i]);
	      if (val !== undefined || !(hasOwnProperty.call(params, key.name))) {
	        params[key.name] = val;
	      }
	    }

	    return true;
	  };


	  /**
	   * Handle "populate" events.
	   */

	  var onpopstate = (function () {
	    var loaded = false;
	    if ('undefined' === typeof window) {
	      return;
	    }
	    if (document.readyState === 'complete') {
	      loaded = true;
	    } else {
	      window.addEventListener('load', function() {
	        setTimeout(function() {
	          loaded = true;
	        }, 0);
	      });
	    }
	    return function onpopstate(e) {
	      if (!loaded) return;
	      if (e.state) {
	        var path = e.state.path;
	        page.replace(path, e.state);
	      } else {
	        page.show(location.pathname + location.hash, undefined, undefined, false);
	      }
	    };
	  })();
	  /**
	   * Handle "click" events.
	   */

	  function onclick(e) {

	    if (1 !== which(e)) return;

	    if (e.metaKey || e.ctrlKey || e.shiftKey) return;
	    if (e.defaultPrevented) return;



	    // ensure link
	    // use shadow dom when available
	    var el = e.path ? e.path[0] : e.target;
	    while (el && 'A' !== el.nodeName) el = el.parentNode;
	    if (!el || 'A' !== el.nodeName) return;



	    // Ignore if tag has
	    // 1. "download" attribute
	    // 2. rel="external" attribute
	    if (el.hasAttribute('download') || el.getAttribute('rel') === 'external') return;

	    // ensure non-hash for the same path
	    var link = el.getAttribute('href');
	    if (!hashbang && el.pathname === location.pathname && (el.hash || '#' === link)) return;



	    // Check for mailto: in the href
	    if (link && link.indexOf('mailto:') > -1) return;

	    // check target
	    if (el.target) return;

	    // x-origin
	    if (!sameOrigin(el.href)) return;



	    // rebuild path
	    var path = el.pathname + el.search + (el.hash || '');

	    // strip leading "/[drive letter]:" on NW.js on Windows
	    if (typeof process !== 'undefined' && path.match(/^\/[a-zA-Z]:\//)) {
	      path = path.replace(/^\/[a-zA-Z]:\//, '/');
	    }

	    // same page
	    var orig = path;

	    if (path.indexOf(base) === 0) {
	      path = path.substr(base.length);
	    }

	    if (hashbang) path = path.replace('#!', '');

	    if (base && orig === path) return;

	    e.preventDefault();
	    page.show(orig);
	  }

	  /**
	   * Event button.
	   */

	  function which(e) {
	    e = e || window.event;
	    return null === e.which ? e.button : e.which;
	  }

	  /**
	   * Check if `href` is the same origin.
	   */

	  function sameOrigin(href) {
	    var origin = location.protocol + '//' + location.hostname;
	    if (location.port) origin += ':' + location.port;
	    return (href && (0 === href.indexOf(origin)));
	  }

	  page.sameOrigin = sameOrigin;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(31), __webpack_require__(18)))

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	var isarray = __webpack_require__(33)

	/**
	 * Expose `pathToRegexp`.
	 */
	module.exports = pathToRegexp
	module.exports.parse = parse
	module.exports.compile = compile
	module.exports.tokensToFunction = tokensToFunction
	module.exports.tokensToRegExp = tokensToRegExp

	/**
	 * The main path matching regexp utility.
	 *
	 * @type {RegExp}
	 */
	var PATH_REGEXP = new RegExp([
	  // Match escaped characters that would otherwise appear in future matches.
	  // This allows the user to escape special characters that won't transform.
	  '(\\\\.)',
	  // Match Express-style parameters and un-named parameters with a prefix
	  // and optional suffixes. Matches appear as:
	  //
	  // "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?", undefined]
	  // "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined, undefined]
	  // "/*"            => ["/", undefined, undefined, undefined, undefined, "*"]
	  '([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^()])+)\\))?|\\(((?:\\\\.|[^()])+)\\))([+*?])?|(\\*))'
	].join('|'), 'g')

	/**
	 * Parse a string for the raw tokens.
	 *
	 * @param  {String} str
	 * @return {Array}
	 */
	function parse (str) {
	  var tokens = []
	  var key = 0
	  var index = 0
	  var path = ''
	  var res

	  while ((res = PATH_REGEXP.exec(str)) != null) {
	    var m = res[0]
	    var escaped = res[1]
	    var offset = res.index
	    path += str.slice(index, offset)
	    index = offset + m.length

	    // Ignore already escaped sequences.
	    if (escaped) {
	      path += escaped[1]
	      continue
	    }

	    // Push the current path onto the tokens.
	    if (path) {
	      tokens.push(path)
	      path = ''
	    }

	    var prefix = res[2]
	    var name = res[3]
	    var capture = res[4]
	    var group = res[5]
	    var suffix = res[6]
	    var asterisk = res[7]

	    var repeat = suffix === '+' || suffix === '*'
	    var optional = suffix === '?' || suffix === '*'
	    var delimiter = prefix || '/'
	    var pattern = capture || group || (asterisk ? '.*' : '[^' + delimiter + ']+?')

	    tokens.push({
	      name: name || key++,
	      prefix: prefix || '',
	      delimiter: delimiter,
	      optional: optional,
	      repeat: repeat,
	      pattern: escapeGroup(pattern)
	    })
	  }

	  // Match any characters still remaining.
	  if (index < str.length) {
	    path += str.substr(index)
	  }

	  // If the path exists, push it onto the end.
	  if (path) {
	    tokens.push(path)
	  }

	  return tokens
	}

	/**
	 * Compile a string to a template function for the path.
	 *
	 * @param  {String}   str
	 * @return {Function}
	 */
	function compile (str) {
	  return tokensToFunction(parse(str))
	}

	/**
	 * Expose a method for transforming tokens into the path function.
	 */
	function tokensToFunction (tokens) {
	  // Compile all the tokens into regexps.
	  var matches = new Array(tokens.length)

	  // Compile all the patterns before compilation.
	  for (var i = 0; i < tokens.length; i++) {
	    if (typeof tokens[i] === 'object') {
	      matches[i] = new RegExp('^' + tokens[i].pattern + '$')
	    }
	  }

	  return function (obj) {
	    var path = ''
	    var data = obj || {}

	    for (var i = 0; i < tokens.length; i++) {
	      var token = tokens[i]

	      if (typeof token === 'string') {
	        path += token

	        continue
	      }

	      var value = data[token.name]
	      var segment

	      if (value == null) {
	        if (token.optional) {
	          continue
	        } else {
	          throw new TypeError('Expected "' + token.name + '" to be defined')
	        }
	      }

	      if (isarray(value)) {
	        if (!token.repeat) {
	          throw new TypeError('Expected "' + token.name + '" to not repeat, but received "' + value + '"')
	        }

	        if (value.length === 0) {
	          if (token.optional) {
	            continue
	          } else {
	            throw new TypeError('Expected "' + token.name + '" to not be empty')
	          }
	        }

	        for (var j = 0; j < value.length; j++) {
	          segment = encodeURIComponent(value[j])

	          if (!matches[i].test(segment)) {
	            throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"')
	          }

	          path += (j === 0 ? token.prefix : token.delimiter) + segment
	        }

	        continue
	      }

	      segment = encodeURIComponent(value)

	      if (!matches[i].test(segment)) {
	        throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"')
	      }

	      path += token.prefix + segment
	    }

	    return path
	  }
	}

	/**
	 * Escape a regular expression string.
	 *
	 * @param  {String} str
	 * @return {String}
	 */
	function escapeString (str) {
	  return str.replace(/([.+*?=^!:${}()[\]|\/])/g, '\\$1')
	}

	/**
	 * Escape the capturing group by escaping special characters and meaning.
	 *
	 * @param  {String} group
	 * @return {String}
	 */
	function escapeGroup (group) {
	  return group.replace(/([=!:$\/()])/g, '\\$1')
	}

	/**
	 * Attach the keys as a property of the regexp.
	 *
	 * @param  {RegExp} re
	 * @param  {Array}  keys
	 * @return {RegExp}
	 */
	function attachKeys (re, keys) {
	  re.keys = keys
	  return re
	}

	/**
	 * Get the flags for a regexp from the options.
	 *
	 * @param  {Object} options
	 * @return {String}
	 */
	function flags (options) {
	  return options.sensitive ? '' : 'i'
	}

	/**
	 * Pull out keys from a regexp.
	 *
	 * @param  {RegExp} path
	 * @param  {Array}  keys
	 * @return {RegExp}
	 */
	function regexpToRegexp (path, keys) {
	  // Use a negative lookahead to match only capturing groups.
	  var groups = path.source.match(/\((?!\?)/g)

	  if (groups) {
	    for (var i = 0; i < groups.length; i++) {
	      keys.push({
	        name: i,
	        prefix: null,
	        delimiter: null,
	        optional: false,
	        repeat: false,
	        pattern: null
	      })
	    }
	  }

	  return attachKeys(path, keys)
	}

	/**
	 * Transform an array into a regexp.
	 *
	 * @param  {Array}  path
	 * @param  {Array}  keys
	 * @param  {Object} options
	 * @return {RegExp}
	 */
	function arrayToRegexp (path, keys, options) {
	  var parts = []

	  for (var i = 0; i < path.length; i++) {
	    parts.push(pathToRegexp(path[i], keys, options).source)
	  }

	  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options))

	  return attachKeys(regexp, keys)
	}

	/**
	 * Create a path regexp from string input.
	 *
	 * @param  {String} path
	 * @param  {Array}  keys
	 * @param  {Object} options
	 * @return {RegExp}
	 */
	function stringToRegexp (path, keys, options) {
	  var tokens = parse(path)
	  var re = tokensToRegExp(tokens, options)

	  // Attach keys back to the regexp.
	  for (var i = 0; i < tokens.length; i++) {
	    if (typeof tokens[i] !== 'string') {
	      keys.push(tokens[i])
	    }
	  }

	  return attachKeys(re, keys)
	}

	/**
	 * Expose a function for taking tokens and returning a RegExp.
	 *
	 * @param  {Array}  tokens
	 * @param  {Array}  keys
	 * @param  {Object} options
	 * @return {RegExp}
	 */
	function tokensToRegExp (tokens, options) {
	  options = options || {}

	  var strict = options.strict
	  var end = options.end !== false
	  var route = ''
	  var lastToken = tokens[tokens.length - 1]
	  var endsWithSlash = typeof lastToken === 'string' && /\/$/.test(lastToken)

	  // Iterate over the tokens and create our regexp string.
	  for (var i = 0; i < tokens.length; i++) {
	    var token = tokens[i]

	    if (typeof token === 'string') {
	      route += escapeString(token)
	    } else {
	      var prefix = escapeString(token.prefix)
	      var capture = token.pattern

	      if (token.repeat) {
	        capture += '(?:' + prefix + capture + ')*'
	      }

	      if (token.optional) {
	        if (prefix) {
	          capture = '(?:' + prefix + '(' + capture + '))?'
	        } else {
	          capture = '(' + capture + ')?'
	        }
	      } else {
	        capture = prefix + '(' + capture + ')'
	      }

	      route += capture
	    }
	  }

	  // In non-strict mode we allow a slash at the end of match. If the path to
	  // match already ends with a slash, we remove it for consistency. The slash
	  // is valid at the end of a path match, not in the middle. This is important
	  // in non-ending mode, where "/test/" shouldn't match "/test//route".
	  if (!strict) {
	    route = (endsWithSlash ? route.slice(0, -2) : route) + '(?:\\/(?=$))?'
	  }

	  if (end) {
	    route += '$'
	  } else {
	    // In non-ending mode, we need the capturing groups to match as much as
	    // possible by using a positive lookahead to the end or next path segment.
	    route += strict && endsWithSlash ? '' : '(?=\\/|$)'
	  }

	  return new RegExp('^' + route, flags(options))
	}

	/**
	 * Normalize the given path string, returning a regular expression.
	 *
	 * An empty array can be passed in for the keys, which will hold the
	 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
	 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
	 *
	 * @param  {(String|RegExp|Array)} path
	 * @param  {Array}                 [keys]
	 * @param  {Object}                [options]
	 * @return {RegExp}
	 */
	function pathToRegexp (path, keys, options) {
	  keys = keys || []

	  if (!isarray(keys)) {
	    options = keys
	    keys = []
	  } else if (!options) {
	    options = {}
	  }

	  if (path instanceof RegExp) {
	    return regexpToRegexp(path, keys, options)
	  }

	  if (isarray(path)) {
	    return arrayToRegexp(path, keys, options)
	  }

	  return stringToRegexp(path, keys, options)
	}


/***/ },
/* 33 */
/***/ function(module, exports) {

	module.exports = Array.isArray || function (arr) {
	  return Object.prototype.toString.call(arr) == '[object Array]';
	};


/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var HomePage = {};

	HomePage.onload = function (element) {

		return element;
	};
	HomePage.routeParams = null;
	HomePage.child = null;
	//CTRL
	HomePage.controller = function () {
		console.log("Home called", HomePage.routeParams);
	};

	HomePage.view = function (ctrl) {
		return { tag: "div", attrs: { class: "home" }, children: [__webpack_require__(35), { tag: "div", attrs: { class: "ui main container", config: HomePage.onload }, children: [HomePage.child] }, __webpack_require__(37)] };
	};

	HomePage.elements = function () {};

	module.exports = HomePage;

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(m) {"use strict";

	var Auth = __webpack_require__(36);
	//console.log(Auth.isLoggedIn());
	var Menu = {};

	//CTRL
	Menu.controller = function () {
		var ctrl = {};

		ctrl.scale = "huge";

		ctrl.menuItems = [{
			title: "Contact us",
			link: "/contact"
		}];

		ctrl.socialItems = [{
			link: "https://facebook.com/rightfit.io",
			icon: "facebook f"
		}];
		ctrl.nonMemberMenu = [{
			type: "item",
			title: "Signup",
			href: "/signup"
		}, {
			type: "item",
			title: "Dashboard",
			href: "/dashboard"
		}, {
			type: "item",
			title: "Settings",
			href: "/dashboard/settings"
		}];

		ctrl.memberMenu = [{
			type: "item",
			title: "Signup",
			href: "/signup"
		}, {
			type: "item",
			title: "Dashboard",
			href: "/dashboard"
		}, {
			type: "item",
			title: "Settings",
			href: "/dashboard/settings"
		}, {
			type: "item",
			title: "Logout",
			href: "/logout"
		}];

		ctrl.userMenu = ctrl.nonMemberMenu;
		ctrl.userMenuTitle = Auth.session_exists() ? "Dashboard" : "Login";
		ctrl.userMenuHref = Auth.session_exists() ? "/dashboard" : "/login";
		ctrl.userMenu = Auth.session_exists() ? ctrl.memberMenu : ctrl.nonMemberMenu;

		if (Auth.session_exists()) {
			//add admin menu
			ctrl.memberMenu.push({ type: "divider" });
			ctrl.memberMenu.push({ type: "item", title: "Administrator", href: "/admin" });
		}

		return ctrl;
	};

	Menu.view = function (ctrl) {
		return { tag: "div", attrs: { class: "ui fixed menu" }, children: [{ tag: "div", attrs: { class: "ui container" }, children: [{ tag: "div", attrs: { class: "right menu" }, children: [ctrl.socialItems.map(function (item) {

						return { tag: "a", attrs: { class: "ui item", href: item.link }, children: [" ", { tag: "i", attrs: { class: item.icon + " icon" } }, " "] };
					}), { tag: "div", attrs: { class: "ui simple dropdown item" }, children: [{ tag: "a", attrs: { href: ctrl.userMenuHref, class: "item" }, children: [ctrl.userMenuTitle, " ", { tag: "i", attrs: { class: "dropdown icon" } }] }, { tag: "div", attrs: { class: "menu" }, children: [ctrl.userMenu.map(function (item) {

								var currentItem = null;

								switch (item.type) {
									case "item":
										currentItem = { tag: "a", attrs: { href: item.href, config: m.fadesOutPage, class: "item" }, children: [item.title] };
										break;
									case "header":
										currentItem = { tag: "div", attrs: { class: "header" }, children: [item.title] };
										break;
									case "divider":
										currentItem = { tag: "div", attrs: { class: "divider" } };
										break;
								}
								return currentItem;
							})] }] }, ctrl.menuItems.map(function (item) {

						var currentItem = { tag: "a", attrs: { class: "ui item", href: item.link }, children: [" ", item.title] };

						if (item.icon) {
							currentItem = { tag: "a", attrs: { class: "ui item", href: item.link }, children: [" ", item.title, " ", { tag: "i", attrs: { class: item.icon + " icon" } }, " "] };
						}

						return currentItem;
					})] }] }] };
	};

	module.exports = Menu;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(m, Bullet) {"use strict";

	var Auth = {};

	Auth.session_exists = m.prop(false);
	Auth.token_set = m.prop(false);

	Auth.token = m.cookie.get("rf_session");

	Auth.user = function (data) {
	    console.log(data);
	    this.xmpp = {
	        username: data.xmpp_username,
	        password: data.xmpp_password
	    };
	    this.user = {
	        _id: data._id
	    };
	    this.iscompany = data.iscompany;
	};

	Auth.setSession = function (token) {
	    m.cookie.set("rf_session", token);

	    m.api.token(token);

	    this.session_exists = m.prop(true);
	};

	Auth.clearSession = function () {
	    m.cookie.remove("rf_session");
	    this.session_exists = m.prop(false);
	    this.token = null;
	    m.redraw();
	};
	Auth.PingServer = function () {

	    var that = this;

	    m.api.ping.read('').then(function (response, success, xhr) {
	        //successful!
	        if (success) {

	            that.session_exists = m.prop(true);

	            user = new that.user(response.data);
	            m.api.release('ping');
	            Bullet.trigger('auth_done');
	        }
	    }).error(function (xhr, error) {
	        Auth.clearSession();
	        m.api.release('ping');
	        Bullet.trigger('auth_done');
	    });
	};

	Auth.DoLogin = function () {

	    if (!this.token) {

	        this.session_exists = m.prop(false);
	        //no session exists, nothing to do
	        Bullet.trigger('auth_done');
	    } else {
	        m.api.token(this.token);
	        Auth.PingServer();
	    }
	};
	module.exports = Auth;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4), __webpack_require__(1)))

/***/ },
/* 37 */
/***/ function(module, exports) {

	"use strict";

	var Footer = {};

	//CTRL
	Footer.controller = function () {};

	Footer.view = function (ctrl) {
	  return { tag: "div", attrs: { class: "ui blue vertical footer segment" }, children: [{ tag: "div", attrs: { class: "ui center aligned container" }, children: [{ tag: "div", attrs: { class: "ui stackable pink divided grid" }, children: [{ tag: "div", attrs: { class: "three wide column" }, children: [{ tag: "h4", attrs: { class: "ui blue header" }, children: ["Helpful articles"] }, { tag: "div", attrs: { class: "ui blue link list" }, children: [{ tag: "a", attrs: { href: "#", class: "item" }, children: ["Link One"] }, { tag: "a", attrs: { href: "#", class: "item" }, children: ["Link Two"] }, { tag: "a", attrs: { href: "#", class: "item" }, children: ["Link Three"] }, { tag: "a", attrs: { href: "#", class: "item" }, children: ["Link Four"] }] }] }, { tag: "div", attrs: { class: "three wide column" }, children: [{ tag: "h4", attrs: { class: "ui blue header" }, children: ["Group 2"] }, { tag: "div", attrs: { class: "ui blue link list" }, children: [{ tag: "a", attrs: { href: "#", class: "item" }, children: ["Link One"] }, { tag: "a", attrs: { href: "#", class: "item" }, children: ["Link Two"] }, { tag: "a", attrs: { href: "#", class: "item" }, children: ["Link Three"] }, { tag: "a", attrs: { href: "#", class: "item" }, children: ["Link Four"] }] }] }, { tag: "div", attrs: { class: "three wide column" }, children: [{ tag: "h4", attrs: { class: "ui blue header" }, children: ["Group 3"] }, { tag: "div", attrs: { class: "ui blue link list" }, children: [{ tag: "a", attrs: { href: "#", class: "item" }, children: ["Link One"] }, { tag: "a", attrs: { href: "#", class: "item" }, children: ["Link Two"] }, { tag: "a", attrs: { href: "#", class: "item" }, children: ["Link Three"] }, { tag: "a", attrs: { href: "#", class: "item" }, children: ["Link Four"] }] }] }, { tag: "div", attrs: { class: "seven wide column" }, children: [{ tag: "h4", attrs: { class: "ui blue header" }, children: ["Contact Info"] }, { tag: "p", attrs: {}, children: ["Extra space for a call to action inside the footer that could help re-engage users."] }] }] }, { tag: "div", attrs: { class: "ui blue section divider" } }, { tag: "img", attrs: { src: "/assets/images/rightfit_logo.svg", class: "ui centered tiny image" } }, { tag: "div", attrs: { class: "ui horizontal pink small divided link list" }, children: [{ tag: "a", attrs: { class: "item", href: "#" }, children: ["Site Map"] }, { tag: "a", attrs: { class: "item", href: "#" }, children: ["Contact Us"] }, { tag: "a", attrs: { class: "item", href: "#" }, children: ["Terms and Conditions"] }, { tag: "a", attrs: { class: "item", href: "#" }, children: ["Privacy Policy"] }] }] }] };
	};

	module.exports = Footer;

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(m, Auth, page, jQuery) {"use strict";

	var Signup = {};

	Signup.loaded = m.prop(false);
	Signup.show_otp = m.prop(false);
	Signup.countries = null;
	Signup.token = m.prop("");

	Signup.model = function (data) {

		this.user = {
			email: data.email,
			phone: data.phone,
			country: data.country.substring(1),
			code: null
		};
		return this;
	};
	Signup.model.prototype.updateOtp = function (otp) {
		this.user.code = otp;
		return this.user;
	};

	Signup.User = null;

	//CTRL
	Signup.controller = function () {

		var that = this;

		that.selected_country = m.prop("");

		if (Auth.session_exists()) {
			return page.redirect('/dashboard');
		}

		that.change_country = function (e) {
			that.selected_country = m.prop(e.target.value);
		}.bind(that);

		that.dropdown = function (e) {
			jQuery(e).dropdown({
				useLabels: true
			});
		};

		m.startComputation();

		__webpack_require__.e/* nsure */(1, function (require) {/* WEBPACK VAR INJECTION */(function(jQuery, m, Auth, page) {
			Signup.countries = __webpack_require__(39);

			that.elements = {};

			that.focus = function (e) {
				jQuery(e).popup({ on: 'focus', prefer: 'opposite', setFluidWidth: true });
			};

			that.segmentLoading = function (e) {
				that.elements.formSegment = jQuery(e);
			};

			that.errors = function (e) {
				that.elements.errors = jQuery(e);
			};

			//after signup is done.
			that.confirmOtp = function (event, fields) {

				event.preventDefault();
				//loading
				that.elements.formSegment.addClass("loading");
				Signup.User.updateOtp(fields.otp);

				m.api.users.headers({ "Authorization": "Bearer " + Signup.token() });

				m.api.users.update(Signup.User.user).then(function (response, success, xhr) {
					m.startComputation();

					if (response.error === true) {

						jQuery(that.elements.form).removeClass('success').addClass('error');
						Object.keys(response.errors).forEach(function (error, i) {

							Signup.show_msg = true;
							Signup.errors = m.prop([response.errors[error]]);

							jQuery(that.elements.form).find("[name='" + error + "']").parent().addClass('error');
						});
					} else {
						Auth.setSession(response.data.token);
						page.redirect("/dashboard");
					}
					m.api.release('users');

					Signup.show_otp = m.prop(false);
					m.endComputation();
				}).error(function (xhr, error) {
					m.startComputation();

					//console.log("HERE",xhr.responseJSON)
					var response = xhr.responseJSON;
					jQuery(that.elements.form).removeClass('success').addClass('error');

					if (xhr.status == 401 || xhr.status == 403) {
						Object.keys(response.errors).forEach(function (error, i) {

							Signup.show_msg = m.prop(true);
							Signup.errors = m.prop([response.errors[error]]);

							jQuery(that.elements.form).find("[name='" + error + "']").parent().addClass('error');
						});
					} else {
						Signup.show_msg = m.prop(true);
						Signup.errors = m.prop([{ msg: response.userMessage || "Server error, please try again" }]);
						jQuery(that.elements.form).find("[name='" + error + "']").parent().addClass('error');
					}

					that.elements.formSegment.removeClass("loading");
					m.api.release('users');
					Signup.show_otp = m.prop(false);

					m.endComputation();
				});
			};

			that.signup = function (event, fields) {

				event.preventDefault();
				//loading
				that.elements.formSegment.addClass("loading");

				//jQuery(that.elements.form).form('remove prompt', 'email');
				//console.log(m.api.users.create('signup',fields))

				Signup.User = new Signup.model(fields);

				m.api.users.post(Signup.User.user).then(function (response, success, xhr) {

					m.startComputation();
					that.elements.formSegment.removeClass("loading");

					if (response.error === true) {

						jQuery(that.elements.form).removeClass('success').addClass('error');
						Object.keys(response.errors).forEach(function (error, i) {

							Signup.show_msg = true;
							Signup.errors = m.prop([response.errors[error]]);

							jQuery(that.elements.form).find("[name='" + error + "']").parent().addClass('error');
						});
					} else {
						Signup.token = m.prop(response.data.token);

						//Auth.setSession(response.data.token);
						Signup.show_otp = m.prop(true);

						//page.redirect("/dashboard")
					}
					m.api.release('users');
					//m.redraw();
					m.endComputation();
				}).error(function (xhr, error) {

					m.startComputation();
					//console.log("HERE",xhr.responseJSON)
					var response = xhr.responseJSON;
					jQuery(that.elements.form).removeClass('success').addClass('error');

					if (xhr.status == 401 || xhr.status == 403) {
						Object.keys(response.errors).forEach(function (error, i) {

							Signup.show_msg = m.prop(true);
							Signup.errors = m.prop([response.errors[error]]);

							jQuery(that.elements.form).find("[name='" + error + "']").parent().addClass('error');
						});
					} else {
						Signup.show_msg = m.prop(true);
						Signup.errors = m.prop([{ msg: response.userMessage || "Server error, please try again" }]);
						jQuery(that.elements.form).find("[name='" + error + "']").parent().addClass('error');
					}

					that.elements.formSegment.removeClass("loading");
					m.api.release('users');
					m.endComputation();
				});

				m.api.wait('users');
			};

			that.onOTPLoad = function (e) {

				that.elements.otpform = jQuery(e);

				jQuery(e).form({
					fields: {
						otp: {
							identifier: 'otp',
							rules: [{
								type: 'number',
								prompt: 'Please enter valid otp.'
							}, {
								type: 'minLength[4]',
								prompt: 'A valid 4 digit otp code is required.'
							}, {
								type: 'maxLength[4]',
								prompt: 'A valid 4 digit otp code is required.'
							}]
						}

					},
					inline: true,
					on: 'blur',
					onSuccess: that.confirmOtp
				});
			};

			that.onLoad = function (e) {

				that.elements.form = jQuery(e);

				jQuery(e).form({
					fields: {
						email: {
							identifier: 'email',
							rules: [{
								type: 'email',
								prompt: 'Please enter a valid e-mail.'
							}]
						},
						country: {
							identifier: 'country',
							rules: [{
								type: 'empty',
								prompt: 'Please select your country.'
							}]
						},
						phone: {
							identifier: 'phone',
							rules: [{
								type: 'empty',
								prompt: 'We really need your number here. You will receive a password on this.'
							}, {
								type: 'minLength[10]',
								prompt: 'A valid 10 digit mobile number is required. You will receive a password on this.'
							}]
						}

					},
					inline: true,
					on: 'blur',
					onSuccess: that.signup
				});
			};

			Signup.loaded = m.prop(true);

			m.endComputation();
		
	/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(3), __webpack_require__(4), __webpack_require__(36), __webpack_require__(31)))});
	};

	Signup.ErrorList = function (errors) {

		return this.show_msg() ? { tag: "ul", attrs: { class: "list" }, children: [errors.map(function (error, i) {
				console.log(error);
				return { tag: "li", attrs: {}, children: [" ", error.msg, " "] };
			})] } : null;
	};
	Signup.show_msg = m.prop(false);
	Signup.errors = m.prop([]);

	Signup.signupForm = function (ctrl) {
		return { tag: "div", attrs: { class: "ui raised segments" }, children: [{ tag: "div", attrs: { class: "ui center aligned segment" }, children: [{ tag: "h3", attrs: { class: "ui header" }, children: ["Create a new account"] }] }, { tag: "div", attrs: { class: "ui segment", config: ctrl.segmentLoading }, children: [{ tag: "form", attrs: { class: "ui form", config: ctrl.onLoad, method: "POST" }, children: [{ tag: "div", attrs: { class: "required field" }, children: [{ tag: "label", attrs: {}, children: ["Your country"] }, { tag: "div", attrs: { class: "ui fluid search selection dropdown", config: ctrl.dropdown }, children: [{ tag: "input", attrs: { onchange: ctrl.change_country, value: ctrl.selected_country(), type: "hidden", name: "country" } }, { tag: "i", attrs: { class: "dropdown icon" } }, { tag: "div", attrs: { class: "default text" }, children: ["Select Country"] }, { tag: "div", attrs: { class: "menu" }, children: [this.countries.map(function (c) {
									return { tag: "div", attrs: { class: "item", "data-value": c.dial_code }, children: [{ tag: "i", attrs: { class: c.code.toLowerCase() + " flag" } }, c.name, " (", c.dial_code, ")"] };
								})] }] }] }, { tag: "div", attrs: { class: "required field" }, children: [{ tag: "label", attrs: {}, children: ["Email address"] }, { tag: "div", attrs: { class: "ui left icon input" }, children: [{ tag: "input", attrs: { type: "text", name: "email", config: ctrl.focus, "data-content": "You will never receive spam! This is private.", placeholder: "Your primary email." } }, { tag: "i", attrs: { class: "mail icon" } }] }] }, { tag: "div", attrs: { class: "required field" }, children: [{ tag: "label", attrs: {}, children: ["Mobile ", ctrl.selected_country() ? String("(") + ctrl.selected_country() + String(")") : ""] }, { tag: "div", attrs: { class: "ui left icon input" }, children: [{ tag: "input", attrs: { type: "phone", name: "phone", config: ctrl.focus, "data-content": "You will receive a password on this number. We won't share your number with anyone until you accept interviews.", placeholder: "Required for interviews." } }, { tag: "i", attrs: { class: "phone icon" } }] }] }, { tag: "div", attrs: { class: "ui divider" } }, { tag: "button", attrs: { class: "fluid ui blue button", type: "submit" }, children: ["Signup"] }, { tag: "div", attrs: { class: "ui error message" }, children: [this.ErrorList(this.errors())] }] }] }, { tag: "div", attrs: { class: "ui segment" }, children: [{ tag: "div", attrs: { class: "ui" }, children: [{ tag: "a", attrs: { class: "ui right floated text", href: "/signup" }, children: ["Signup"] }, { tag: "a", attrs: { class: "left floated", href: "/signup" }, children: ["Signup"] }] }] }] };
	};

	Signup.otpForm = function (ctrl) {
		return { tag: "div", attrs: { class: "ui raised segments" }, children: [{ tag: "div", attrs: { class: "ui center aligned segment" }, children: [{ tag: "h3", attrs: { class: "ui header" }, children: ["Thanks! Check your phone for an OTP code."] }] }, { tag: "div", attrs: { class: "ui segment", config: ctrl.segmentLoading }, children: [{ tag: "form", attrs: { class: "ui form", config: ctrl.onOTPLoad, method: "POST" }, children: [{ tag: "div", attrs: { class: "required field" }, children: [{ tag: "label", attrs: {}, children: ["OTP"] }, { tag: "div", attrs: { class: "ui left icon input" }, children: [{ tag: "input", attrs: { type: "number", name: "otp", config: ctrl.focus, "data-content": "The OTP you received on your mobile number.", placeholder: "OTP code." } }, { tag: "i", attrs: { class: "phone icon" } }] }] }, { tag: "div", attrs: { class: "ui divider" } }, { tag: "button", attrs: { class: "fluid ui blue button", type: "submit" }, children: ["Confirm"] }, { tag: "div", attrs: { class: "ui error message" }, children: [this.ErrorList(this.errors())] }] }] }, { tag: "div", attrs: { class: "ui segment" }, children: [{ tag: "div", attrs: { class: "ui" }, children: [{ tag: "a", attrs: { class: "ui right floated text", href: "/signup" }, children: ["Signup"] }, { tag: "a", attrs: { class: "left floated", href: "/signup" }, children: ["Signup"] }] }] }] };
	};

	Signup.view = function (ctrl) {

		var that = this;

		return { tag: "div", attrs: { class: "ui centered grid" }, children: [{ tag: "div", attrs: { class: "sixteen wide mobile ten wide tablet six wide computer column " }, children: [this.loaded() ? this.show_otp() ? this.otpForm(ctrl) : this.signupForm(ctrl) : ''] }] };
	};

	module.exports = Signup;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4), __webpack_require__(36), __webpack_require__(31), __webpack_require__(3)))

/***/ },
/* 39 */,
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(m, jQuery, Auth, page) {"use strict";

	var Login = {};
	Login.showCountry = m.prop(false);

	// email validation
	function validateEmail(email) {
		var re = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
		return re.test(email);
	}
	function validateNumber(number) {
		var re = /^\d+$/;
		return re.test(number);
	}
	jQuery.fn.form.settings.rules.inputPassword = function (value, length) {
		if (Login.showCountry()) return true;

		if (value.length === 0) return true; //hack to not show message when its selected and moved on

		return Login.showCountry() || value.length > 6;
	};
	//custom validation fields
	jQuery.fn.form.settings.rules.inputLogin = function (value) {

		if (Login.showCountry()) return true;

		var isNumber = validateNumber(value);
		//console.log("I am calleds",value,parsedValue,isNaN(parsedValue));
		if (!isNumber) {
			//this is email probably
			if (validateEmail(value)) {
				return true;
			} else return false;
		} else {
			// this is a number, perhaps a mobile?
			if (value.length != 10) {
				return false;
			} else {
				return true;
			}
		}
	};

	Login.loaded = m.prop(false);
	//CTRL
	Login.controller = function () {

		var that = this;

		if (Auth.session_exists()) {
			page.redirect('/dashboard');
		}
		m.startComputation();

		__webpack_require__.e/* nsure */(1/* duplicate */, function (require) {/* WEBPACK VAR INJECTION */(function(m, jQuery, Auth, page) {

			//----variables for country----
			Login.countries = __webpack_require__(39);

			that.selected_country = m.prop("");

			that.change_country = function (e) {
				that.selected_country = m.prop(e.target.value);
			}.bind(that);

			that.dropdown = function (e) {
				jQuery(e).dropdown({
					useLabels: true
				});
			};
			//----variables end for coutry----

			//to hold all jquery elements required.
			that.elements = {};

			that.segmentLoading = function (e) {
				that.elements.formSegment = jQuery(e);
			};

			that.errors = function (e) {
				that.elements.errors = jQuery(e);
			};

			//the login string to validate
			that.loginString = that.loginString ? that.loginString() : m.prop("");
			//alert(that.loginString());
			that.inputLogin = function (e) {

				that.loginString = m.prop(e.target.value);

				var isNumber = validateNumber(that.loginString());

				if (!isNumber)
					//this is email probably
					Login.showCountry = m.prop(false);else // this is a number, perhaps a mobile?
					Login.showCountry = m.prop(true);

				m.withAttr("value", that.loginString());
			}.bind(that);

			//the main login after form validation
			that.login = function (event, fields) {

				var loginparam = Login.showCountry() ? m.api.login : m.api.emailLogin;

				event.preventDefault();
				//jQuery(that.elements.form).form('remove prompt', 'email');
				//console.log(m.api.users.create('login',fields))


				loginparam.post(fields).then(function (response, success, xhr) {

					if (response.error == true) {
						jQuery(that.elements.form).removeClass('success').addClass('error');
						Object.keys(response.errors).forEach(function (error, i) {

							Login.show_msg = m.prop(true);
							Login.errors = m.prop([response.errors[error]]);

							jQuery(that.elements.form).find("[name='" + error + "']").parent().addClass('error');
						});
						that.elements.formSegment.removeClass("loading");
					} else {
						Auth.setSession(response.data.token);
						page.redirect("/dashboard");
					}
					m.api.release('login');
					m.redraw();
				}).error(function (xhr, error) {
					//console.log("HERE",xhr.responseJSON)
					var response = xhr.responseJSON;
					jQuery(that.elements.form).removeClass('success').addClass('error');

					if (xhr.status == 401 || xhr.status == 403) {
						Object.keys(response.errors).forEach(function (error, i) {

							Login.show_msg = m.prop(true);
							Login.errors = m.prop([response.errors[error]]);
							jQuery(that.elements.form).find("[name='" + error + "']").parent().addClass('error');
						});
					} else {
						Login.show_msg = m.prop(true);
						Login.errors = m.prop([{ msg: response.userMessage || "Server error, please try again." }]);
						jQuery(that.elements.form).find("[name='" + error + "']").parent().addClass('error');
					}
					that.elements.formSegment.removeClass("loading");
					m.api.release('login');
					m.redraw();
				});

				m.api.wait('login');

				//loading
				that.elements.formSegment.addClass("loading");
			};

			//when form loads, this will validate fields
			that.onLoad = function (e) {

				that.elements.form = jQuery(e);

				jQuery(e).form({
					fields: {
						email: {
							identifier: 'email',
							rules: [{
								type: 'inputLogin',
								prompt: "A valid email address or 10 digits phone number is required"
							}]
						},
						password: {
							identifier: 'password',
							rules: [{
								type: 'inputPassword[6]',
								prompt: 'Please enter a valid password. Minimum 6 digits'
							}]
						}

					},
					inline: true,
					on: 'blur',
					onSuccess: that.login
				});
			};
			Login.loaded = m.prop(true);
			m.endComputation();
		
	/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(4), __webpack_require__(3), __webpack_require__(36), __webpack_require__(31)))});
	};

	Login.ErrorList = function (errors) {

		return this.show_msg() ? { tag: "ul", attrs: { class: "list" }, children: [errors.map(function (error, i) {
				return { tag: "li", attrs: {}, children: [" ", error.msg, " "] };
			})] } : null;
	};
	Login.show_msg = m.prop(false);
	Login.errors = m.prop([]);

	Login.form = function (ctrl) {

		var that = this;

		return { tag: "div", attrs: { class: "ui raised segments" }, children: [{ tag: "div", attrs: { class: "ui center aligned segment" }, children: [{ tag: "h3", attrs: { class: "ui header" }, children: ["Login to your account"] }] }, { tag: "div", attrs: { class: "ui segment", config: ctrl.segmentLoading }, children: [{ tag: "form", attrs: { class: "ui form", config: ctrl.onLoad, method: "POST" }, children: [{ tag: "div", attrs: { class: "field" }, children: [{ tag: "label", attrs: {}, children: ["Email address / Phone number"] }, { tag: "div", attrs: { class: "ui left icon input" }, children: [{ tag: "input", attrs: { type: "text", onkeyup: ctrl.inputLogin, value: ctrl.loginString(), name: "email", placeholder: "Your registered email" } }, { tag: "i", attrs: { class: "user icon" } }] }] }, !this.showCountry() ? { tag: "div", attrs: { class: "field" }, children: [{ tag: "label", attrs: {}, children: ["Password"] }, { tag: "div", attrs: { class: "ui left icon input" }, children: [{ tag: "input", attrs: { type: "password", name: "password", placeholder: "Password you remember" } }, { tag: "i", attrs: { class: "lock icon" } }] }] } : { tag: "div", attrs: { class: "field" }, children: [{ tag: "label", attrs: {}, children: ["Your country"] }, { tag: "div", attrs: { class: "ui fluid search selection dropdown", config: ctrl.dropdown }, children: [{ tag: "input", attrs: { onchange: ctrl.change_country, value: ctrl.selected_country(), type: "hidden", name: "country" } }, { tag: "i", attrs: { class: "dropdown icon" } }, { tag: "div", attrs: { class: "default text" }, children: ["Select Country"] }, { tag: "div", attrs: { class: "menu" }, children: [this.countries.map(function (c) {
									return { tag: "div", attrs: { class: "item", "data-value": c.dial_code }, children: [{ tag: "i", attrs: { class: c.code.toLowerCase() + " flag" } }, c.name, " (", c.dial_code, ")"] };
								})] }] }] }, { tag: "div", attrs: { class: "ui divider" } }, { tag: "button", attrs: { class: "fluid ui blue button", type: "submit" }, children: ["Submit"] }, { tag: "div", attrs: { class: "ui error message" }, children: [this.ErrorList(this.errors())] }] }] }, { tag: "div", attrs: { class: "ui segment" }, children: [{ tag: "div", attrs: { class: "ui" }, children: [{ tag: "a", attrs: { class: "ui right floated text", href: "/signup" }, children: ["Signup"] }, { tag: "a", attrs: { class: "left floated", href: "/signup" }, children: ["Signup"] }] }] }] };
	};

	Login.view = function (ctrl) {

		var that = this;

		return { tag: "div", attrs: { class: "ui centered grid" }, children: [{ tag: "div", attrs: { class: "sixteen wide mobile ten wide tablet six wide computer column " }, children: [this.loaded() ? this.form(ctrl) : ''] }] };
	};

	module.exports = Login;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4), __webpack_require__(3), __webpack_require__(36), __webpack_require__(31)))

/***/ }
]);